<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>硬核! golang [select case] 原理解析</title>
      <link href="/2021/08/18/golang-select-yuan-li/"/>
      <url>/2021/08/18/golang-select-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>Go 的select语句是一种仅能用于channl发送和接收消息的专用语句，此语句运行期间是阻塞的；当select中没有case语句的时候，会阻塞当前的groutine。所以，有人也会说select是用来阻塞监听goroutine的。<br> 还有人说：select是Golang在语言层面提供的I/O多路复用的机制，其专门用来检测多个channel是否准备完毕：可读或可写。</p><p>以上说法都正确。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>我们来回顾一下是什么是<code>I/O多路复用</code>。</p><h3 id="普通多线程（或进程）I-O"><a href="#普通多线程（或进程）I-O" class="headerlink" title="普通多线程（或进程）I/O"></a>普通多线程（或进程）I/O</h3><p>每来一个进程，都会建立连接，然后阻塞，直到接收到数据返回响应。<br> 普通这种方式的缺点其实很明显：系统需要创建和维护额外的线程或进程。因为大多数时候，大部分阻塞的线程或进程是处于等待状态，只有少部分会接收并处理响应，而其余的都在等待。系统为此还需要多做很多额外的线程或者进程的管理工作。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select1.webp" alt="img"></p><p>为了解决图中这些多余的线程或者进程，于是有了”I/O多路复用”</p><h3 id="I-O多路复用-1"><a href="#I-O多路复用-1" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select2.webp" alt="img"></p><p>每个线程或者进程都先到图中”装置“中注册，然后阻塞，然后只有一个线程在”运输“，当注册的线程或者进程准备好数据后，”装置“会根据注册的信息得到相应的数据。从始至终kernel只会使用图中这个黄黄的线程，无需再对额外的线程或者进程进行管理，提升了效率。</p><h2 id="select组成结构"><a href="#select组成结构" class="headerlink" title="select组成结构"></a>select组成结构</h2><p>select的实现经历了多个版本的修改，当前版本为：1.11<br> select这个语句底层实现实际上主要由两部分组成：<code>case语句</code>和<code>执行函数</code>。<br> 源码地址为：/go/src/runtime/select.go</p><p>每个case语句，单独抽象出以下结构体：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> scase <span class="token keyword">struct</span> <span class="token punctuation">{</span>    c           <span class="token operator">*</span>hchan         <span class="token comment">// chan</span>    elem        unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 读或者写的缓冲区地址</span>    kind        <span class="token builtin">uint16</span>   <span class="token comment">//case语句的类型，是default、传值写数据(channel &lt;-) 还是  取值读数据(&lt;- channel)</span>    pc          <span class="token builtin">uintptr</span> <span class="token comment">// race pc (for race detector / msan)</span>    releasetime <span class="token builtin">int64</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体可以用下图表示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select3.webp" alt="img"></p><p> 其中比较关键的是：<code>hchan</code>，它是channel的指针。<br> 在一个select中，所有的case语句会构成一个<code>scase</code>结构体的数组。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select4.webp" alt="img"></p><p>然后执行select语句实际上就是调用<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select5.webp" alt="img"></p><p><code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数参数：</p><ul><li>cas0 为上文提到的case语句抽象出的结构体<code>scase</code>数组的第一个元素地址</li><li>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder。</li><li>nncases表示<code>scase</code>数组的长度</li></ul><p><code>selectgo</code>返回所选scase的索引(该索引与其各自的select {recv，send，default}调用的序号位置相匹配)。此外，如果选择的scase是接收操作(recv)，则返回是否接收到值。</p><p>谁负责调用<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数呢？</p><p>在<code>/reflect/value.go</code>中有个<code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code>函数，此函数的实现在<code>/runtime/select.go</code>文件中的<code>func reflect_rselect(cases []runtimeSelect) (int, bool)</code>函数中:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">reflect_rselect</span><span class="token punctuation">(</span>cases <span class="token punctuation">[</span><span class="token punctuation">]</span>runtimeSelect<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">//如果cases语句为空，则阻塞当前groutine</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">//实例化case的结构体</span>    sel <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>scase<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span><span class="token punctuation">)</span>    order <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> cases <span class="token punctuation">{</span>        rc <span class="token operator">:=</span> <span class="token operator">&amp;</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">switch</span> rc<span class="token punctuation">.</span>dir <span class="token punctuation">{</span>        <span class="token keyword">case</span> selectDefault<span class="token punctuation">:</span>            sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scase<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> caseDefault<span class="token punctuation">}</span>        <span class="token keyword">case</span> selectSend<span class="token punctuation">:</span>            sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scase<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> caseSend<span class="token punctuation">,</span> c<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>val<span class="token punctuation">}</span>        <span class="token keyword">case</span> selectRecv<span class="token punctuation">:</span>            sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scase<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> caseRecv<span class="token punctuation">,</span> c<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>val<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> raceenabled <span class="token operator">||</span> msanenabled <span class="token punctuation">{</span>            <span class="token function">selectsetpc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">selectgo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sel<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>order<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那谁调用的<code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code>呢？<br> 在<code>/refect/value.go</code>中，有一个<code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code>的函数，其调用了<code>rselect</code>函数，并将最终Go中select语句的返回值的返回。</p><p>以上这三个函数的调用栈按顺序如下：</p><ul><li><code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code></li><li><code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code></li><li><code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code></li></ul><p>这仨函数中无论是返回值还是参数都大同小异，可以简单粗暴的认为：函数参数传入的是case语句，返回值返回被选中的case语句。<br> 那谁调用了<code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code>呢？<br> 可以简单的认为是系统了。<br> 来个简单的图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select6.webp" alt="img"></p><p>前两个函数<code>Select</code>和<code>rselect</code>都是做了简单的初始化参数，调用下一个函数的操作。select真正的核心功能，是在最后一个函数<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>中实现的。</p><h3 id="selectgo函数做了什么"><a href="#selectgo函数做了什么" class="headerlink" title="selectgo函数做了什么"></a>selectgo函数做了什么</h3><p>打乱传入的case结构体顺序</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select7.webp" alt="img"></p><p>锁住其中的所有的channel</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select8.webp" alt="img"></p><p>遍历所有的channel，查看其是否可读或者可写</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select9.webp" alt="img"></p><p>如果其中的channel可读或者可写，则解锁所有channel，并返回对应的channel数据</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select10.webp" alt="img"></p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select11.webp" alt="img"></p><p>假如没有channel可读或者可写，但是有default语句，则同上:返回default语句对应的scase并解锁所有的channel。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select11.webp" alt="img"></p><p>假如既没有channel可读或者可写，也没有default语句，则将当前运行的groutine阻塞，并加入到当前所有channel的等待队列中去。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select12.webp" alt="img"></p><p>然后解锁所有channel，等待被唤醒。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select13.webp" alt="img"></p><p>此时如果有个channel可读或者可写ready了，则唤醒，并再次加锁所有channel，</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select14.webp" alt="img"></p><p>遍历所有channel找到那个对应的channel和G，唤醒G，并将没有成功的G从所有channel的等待队列中移除。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select15.webp" alt="img"></p><p>如果对应的scase值不为空，则返回需要的值，并解锁所有channel</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select16.webp" alt="img"></p><p>如果对应的scase为空，则循环此过程。</p><h3 id="select和channel之间的关系"><a href="#select和channel之间的关系" class="headerlink" title="select和channel之间的关系"></a>select和channel之间的关系</h3><p>在想想select和channel做了什么事儿，我觉得和多路复用是一回事儿</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select17.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka 关键原理剖析</title>
      <link href="/2021/08/17/kafka/"/>
      <url>/2021/08/17/kafka/</url>
      
        <content type="html"><![CDATA[<p><strong>Kafka痛点分析&amp;核心目标</strong></p><p>当Kafka支撑的实时作业数量很多，单机承载的Topic和Partition数量很大。这种场景下很容易出现的问题是：同一台机器上不同Partition间竞争PageCache资源，相互影响，导致整个Broker的处理延迟上升、吞吐下降。</p><p><img src="https://image.fyxemmmm.cn/blog/images/kafka.png" alt="Kafka处理读写流程的示意图"></p><p><strong>对于Produce请求</strong>：Server端的I/O线程统一将请求中的数据写入到操作系统的PageCache后立即返回，当消息条数到达一定阈值后，Kafka应用本身或操作系统内核会触发强制刷盘操作（如左侧流程图所示）。</p><p><strong>对于Consume请求</strong>：主要利用了操作系统的ZeroCopy机制，当Kafka Broker接收到读数据请求时，会向操作系统发送sendfile系统调用，操作系统接收后，首先试图从PageCache中获取数据（如中间流程图所示）；如果数据不存在，会触发缺页异常中断将数据从磁盘读入到临时缓冲区中（如右侧流程图所示），随后通过DMA操作直接将数据拷贝到网卡缓冲区中等待后续的TCP传输。</p><p>综上所述，Kafka对于单一读写请求均拥有很好的吞吐和延迟。处理写请求时，数据写入PageCache后立即返回，数据通过异步方式批量刷入磁盘，既保证了多数写请求都能有较低的延迟，同时批量顺序刷盘对磁盘更加友好。处理读请求时，实时消费的作业可以直接从PageCache读取到数据，请求延迟较小，同时ZeroCopy机制能够减少数据传输过程中用户态与内核态的切换，大幅提升了数据传输的效率。</p><p>但当同一个Broker上同时存在多个Consumer时，就可能会由于多个Consumer竞争PageCache资源导致它们同时产生延迟。下面我们以两个Consumer为例详细说明：</p><p><img src="https://image.fyxemmmm.cn/blog/images/kafka2.png"></p><p>如上图所示，Producer将数据发送到Broker，PageCache会缓存这部分数据。当所有Consumer的消费能力充足时，所有的数据都会从PageCache读取，全部Consumer实例的延迟都较低。此时如果其中一个Consumer出现消费延迟（图中的Consumer Process2），根据读请求处理流程可知，此时会触发磁盘读取，在从磁盘读取数据的同时会预读部分数据到PageCache中。当PageCache空间不足时，会按照LRU策略开始淘汰数据，此时延迟消费的Consumer读取到的数据会替换PageCache中实时的缓存数据。后续当实时消费请求到达时，由于PageCache中的数据已被替换掉，会产生预期外的磁盘读取。这样会导致两个后果：</p><ol><li><strong>消费能力充足的Consumer消费时会失去PageCache的性能红利。</strong></li><li><strong>多个Consumer相互影响，预期外的磁盘读增多，HDD负载升高。</strong></li></ol><p><strong>数据分析</strong></p><p>如果Kafka集群TP99流量在170MB/s，TP95流量在100MB/s，TP50流量为50-60MB/s；单机的PageCache平均分配为80GB，取TP99的流量作为参考，在此流量以及PageCache分配情况下，PageCache最大可缓存数据时间跨度为80*1024/170/60 = 8min，可见当前Kafka服务整体对延迟消费作业的容忍性极低。该情况下，一旦部分作业消费延迟，实时消费作业就可能会受到影响。</p><p><strong>痛点分析总结</strong></p><p>总结上述的原理分析以及数据统计，目前Kafka存在如下问题：</p><ol><li>实时消费与延迟消费的作业在PageCache层次产生竞争，导致实时消费产生非预期磁盘读。</li><li>传统HDD随着读并发升高性能急剧下降。</li><li>存在20%的延迟消费作业。</li></ol><p>按目前的PageCache空间分配以及集群流量分析，Kafka无法对实时消费作业提供稳定的服务质量保障，该痛点亟待解决。</p><p><strong>预期目标</strong></p><p>根据上述痛点分析，我们的预期目标为保证实时消费作业不会由于PageCache竞争而被延迟消费作业影响，保证Kafka对实时消费作业提供稳定的服务质量保障。</p><p><strong>解决方案</strong></p><p><strong>可以选择使用SSD</strong></p><p>根据上述原因分析可知，解决目前痛点可从以下两个方向来考虑：</p><ol><li>消除实时消费与延迟消费间的PageCache竞争，如：让延迟消费作业读取的数据不回写PageCache，或增大PageCache的分配量等。</li><li>在HDD与内存之间加入新的设备，该设备拥有比HDD更好的读写带宽与IOPS。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp timewait 详解</title>
      <link href="/2021/08/17/tcp-timewait/"/>
      <url>/2021/08/17/tcp-timewait/</url>
      
        <content type="html"><![CDATA[<p><strong>你遇到过TIME_WAIT的问题吗？</strong></p><p>我相信很多都遇到过这个问题。一旦有用户在喊：网络变慢了。第一件事情就是，netstat -a | grep TIME_WAIT | wc -l 一下，哎呀妈呀，几千个TIME_WAIT。</p><p>然后，做的第一件事情就是：打开Google或者Bing，输入关键词：too many time wait。一定能找到解决方案，而排在最前面或者被很多人到处转载的解决方案一定是：</p><blockquote><p>打开 sysctl.conf 文件，修改以下几个参数：</p><p>net.ipv4.tcp_tw_recycle = 1</p><p>net.ipv4.tcp_tw_reuse = 1</p><p>net.ipv4.tcp_timestamps = 1</p></blockquote><p>你也会被告知，开启tw_recylce和tw_reuse一定需要timestamps的支持，而且这些配置一般不建议开启，但是对解决TIME_WAIT很多的问题，有很好的用处。</p><p>接下来，你就直接修改了这几个参数，reload一下，发现，咦，没几分钟，TIME_WAIT的数量真的降低了，也没发现哪个用户说有问题，然后就没有然后了。</p><p>做到这一步，相信50%或者更高比例的开发就已经止步了。问题好像解决了，但是，要彻底理解并解决这个问题，可能就没这么简单，或者说，还有很长的路要走！</p><p><strong>什么是TIME-WAIT和CLOSE-WAIT?</strong></p><p>所谓，要解决问题，就要先理解问题。随便改两行代码，发现bug“没有了”，也不是bug真的没有了，只是隐藏在更深的地方，你没有发现，或者以你的知识水平，你无法发现而已。</p><p>大家知道，由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。</p><ul><li>主动关闭连接的一方，调用close()；<strong>协议层发送FIN包</strong></li><li><strong>被动关闭的一方收到FIN包后，协议层回复ACK</strong>；然后<strong>被动关闭的一方，进入CLOSE_WAIT状态，</strong>主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作</li><li>被动关闭的一方在完成所有数据发送后，调用close()操作；此时，<strong>协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态</strong>；</li><li><strong>主动关闭的一方收到FIN包，协议层回复ACK</strong>；此时，<strong>主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态</strong></li><li>等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态</li></ul><p>通过上面的一次socket关闭操作，你可以得出以下几点：</p><ol><li>主动关闭连接的一方 - 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态</li><li>被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接</li><li>TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；</li><li>在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！</li></ol><p>所以，这里凭你的直觉，TIME_WAIT并不可怕（not really，后面讲），CLOSE_WAIT才可怕，因为CLOSE_WAIT很多，表示说要么是你的应用程序写的有问题，没有合适的关闭socket；要么是说，你的服务器CPU处理不过来（CPU太忙）或者你的应用程序一直睡眠到其它地方(锁，或者文件I/O等等)，你的应用程序获得不到合适的调度时间，造成你的程序没法真正的执行close操作。</p><p>这里又出现两个问题：</p><ol><li>上文提到的连接重用，那连接到底是个什么概念？</li><li>协议层为什么要设计一个TIME_WAIT状态？这个状态为什么默认等待2MSL时间才会进入CLOSED</li></ol><p>先解释清楚这两个问题，我们再来看，开头提到的几个网络配置究竟有什么用，以及TIME_WAIT的后遗症问题。</p><p><strong>Socket连接到底是个什么概念？</strong></p><p>大家经常提socket，那么，到底什么是一个socket？其实，socket就是一个 五元组，包括：</p><ol><li>源IP</li><li>源端口</li><li>目的IP</li><li>目的端口</li><li>类型：TCP or UDP</li></ol><p>这个五元组，即标识了一条可用的连接。注意，有很多人把一个socket定义成四元组，也就是 源IP:源端口 + 目的IP:目的端口，这个定义是不正确的。</p><p>例如，如果你的本地出口IP是180.172.35.150，那么你的浏览器在连接某一个Web服务器，例如百度的时候，这条socket连接的四元组可能就是：</p><blockquote><p>[180.172.35.150:45678, tcp, 180.97.33.108:80]</p></blockquote><p>源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口。</p><p>如果这个时候，你再开一个浏览器，访问百度，将会产生一条新的连接：</p><blockquote><p>[180.172.35.150:43678, tcp, 180.97.33.108:80]</p></blockquote><p>这条新的连接的源端口为一个新的随机端口 43678。</p><p>如此来看，如果你的本机需要压测百度，那么，你最多可以创建多少个连接呢？</p><p><strong>第二个问题，TIME_WAIT有什么用？</strong></p><p>如果我们来做个类比的话，TIME_WAIT的出现，对应的是你的程序里的异常处理，它的出现，就是为了解决网络的丢包和网络不稳定所带来的其他问题：</p><p>第一，防止前一个连接【五元组，我们继续以 180.172.35.150:45678, tcp, 180.97.33.108:80 为例】上延迟的数据包或者丢失重传的数据包，被后面复用的连接【前一个连接关闭后，此时你再次访问百度，新的连接可能还是由180.172.35.150:45678, tcp, 180.97.33.108:80 这个五元组来表示，也就是源端口凑巧还是45678】错误的接收（异常：数据丢了，或者传输太慢了），参见下图：</p><ul><li>SEQ=3的数据包丢失，重传第一次，没有得到ACK确认</li><li>如果没有TIME_WAIT，或者TIME_WAIT时间非常端，那么关闭的连接【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】，马上被重用【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】，并连续发送SEQ=1,2 的数据包</li><li>此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收</li></ul><p>第二，确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的，参见下图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/img1.webp"></p><ul><li>主动关闭方关闭了连接，发送了FIN；</li><li>被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态</li><li>主动关闭的一方回去了ACK，主动关闭一方进入TIME_WAIT状态；</li><li>但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态</li><li>此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST</li><li>造成主动创建连接的一方，由于收到了RST，则连接无法成功</li></ul><p>所以，你看到了，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成数据粗乱，或者短暂性的连接失败。</p><p>那么，为什么说，TIME_WAIT状态会是持续2MSL（2倍的max segment lifetime）呢？这个时间可以通过修改内核参数调整吗？第一，这个2MSL，是RFC 793里定义的，参见RFC的截图标红的部分：</p><p><img src="https://image.fyxemmmm.cn/blog/images/img2.webp"></p><p>这个定义，更多的是一种保障（IP数据包里的TTL，即数据最多存活的跳数，真正反应的才是数据在网络上的存活时间），确保最后丢失了ACK，被动关闭的一方再次重发FIN并等待回复的ACK，一来一去两个来回。内核里，写死了这个MSL的时间为：30秒（有读者提醒，RFC里建议的MSL其实是2分钟，但是很多实现都是30秒），所以TIME_WAIT的即为1分钟：</p><p>所以，再次回想一下前面的问题，如果一条连接，即使在四次握手关闭了，由于TIME_WAIT的存在，这个连接，在1分钟之内，也无法再次被复用，那么，如果你用一台机器做压测的客户端，你一分钟能发送多少并发连接请求？如果这台是一个负载均衡服务器，一台负载均衡服务器，一分钟可以有多少个连接同时访问后端的服务器呢？</p><p><strong>TIME_WAIT很多，可怕吗？</strong></p><p>如果你通过 ss -tan state time-wait | wc -l 发现，系统中有很多TIME_WAIT，很多人都会紧张。多少算多呢？几百几千？如果是这个量级，其实真的没必要紧张。第一，这个量级，因为TIME_WAIT所占用的内存很少很少；因为记录和寻找可用的local port所消耗的CPU也基本可以忽略。</p><p><strong>会占用内存吗？当然</strong>！任何你可以看到的数据，内核里都需要有相关的数据结构来保存这个数据啊。一条Socket处于TIME_WAIT状态，它也是一条“存在”的socket，内核里也需要有保持它的数据：</p><ol><li><p>内核里有保存所有连接的一个hash table，这个hash table里面既包含TIME_WAIT状态的连接，也包含其他状态的连接。主要用于有新的数据到来的时候，从这个hash table里快速找到这条连接。不同的内核对这个hash table的大小设置不同，你可以通过dmesg命令去找到你的内核设置的大小：</p></li><li><p>还有一个hash table用来保存所有的bound ports，主要用于可以快速的找到一个可用的端口或者随机端口：</p></li></ol><p>由于内核需要保存这些数据，必然，会占用一定的内存。</p><p><strong>会消耗CPU吗？</strong>当然！每次找到一个随机端口，还是需要遍历一遍bound ports的吧，这必然需要一些CPU时间。</p><p>TIME_WAIT很多，既占内存又消耗CPU，这也是为什么很多人，看到TIME_WAIT很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1万条TIME_WAIT的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于CPU，能减少它当然更好，但是不至于因为1万多个hash item就担忧。</p><p>如果，你真的想去调优，还是需要搞清楚别人的调优建议，以及调优参数背后的意义！</p><p><strong>TIME_WAIT调优，你必须理解的几个调优参数</strong></p><p>在具体的图例之前，我们还是先解析一下相关的几个参数存在的意义。</p><ol><li><p><strong>net.ipv4.tcp_timestamps</strong></p><p>RFC 1323 在 TCP Reliability一节里，引入了timestamp的TCP option，两个4字节的时间戳字段，其中第一个4字节字段用来保存发送该数据包的时间，第二个4字节字段用来保存最近一次接收对方发送到数据的时间。有了这两个时间字段，也就有了后续优化的余地。</p><p>tcp_tw_reuse 和 tcp_tw_recycle就依赖这些时间字段。</p></li><li><p><strong>net.ipv4.tcp_tw_reuse</strong></p><p>字面意思，reuse TIME_WAIT状态的连接。</p><p>时刻记住一条socket连接，就是那个五元组，出现TIME_WAIT状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的HTTP请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用TIME_WAIT状态的连接。</p><p>通过字面解释，以及例子说明，你看到了，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接”连接其他服务器，总是自己先关闭连接(TIME_WAIT在自己这方)，关闭后又不断的重新连接对方。</p><p>那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。</p><p>这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用TIME_WAIT的socket。</p></li><li><p><strong>net.ipv4.tcp_tw_recycle</strong></p><p>字面意思，销毁掉 TIME_WAIT。</p><p>当开启了这个配置后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。</p><p>有了这个配置，还是需要保障 丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于TIME_WAIT状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入TIME_WAIT状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。</p><p>这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，TIME_WAIT状态的socket处于服务端，服务端快速的回收该状态的连接。</p></li></ol><p>由此，如果客户端处于NAT的网络(多个客户端，同一个IP出口的网络环境)，如果配置了tw_recycle，就可能在一个RTO的时间内，只能有一个客户端和自己连接成功(不同的客户端发包的时间不一致，造成服务端直接把数据包丢弃掉)。</p><p>我尽量尝试用文字解释清楚，但是，来点案例和图示，应该有助于我们彻底理解。</p><p>我们来看这样一个网络情况：</p><ol><li>客户端IP地址为：180.172.35.150，我们可以认为是浏览器</li><li>负载均衡有两个IP，外网IP地址为 115.29.253.156，内网地址为10.162.74.10；外网地址监听80端口</li><li>负载均衡背后有两台Web服务器，一台IP地址为 10.162.74.43，监听80端口；另一台为 10.162.74.44，监听 80 端口</li><li>Web服务器会连接数据服务器，IP地址为 10.162.74.45，监听 3306 端口</li></ol><p>这种简单的架构下，我们来看看，在不同的情况下，我们今天谈论的tw_reuse/tw_recycle对网络连接的影响。</p><p>先做个假定：</p><ol><li>客户端通过HTTP/1.1连接负载均衡，也就是说，HTTP协议投Connection为keep-alive，所以我们假定，客户端 对 负载均衡服务器 的socket连接，客户端会断开连接，所以，TIME_WAIT出现在客户端</li><li>Web服务器和MySQL服务器的连接，我们假定，Web服务器上的程序在连接结束的时候，调用close操作关闭socket资源连接，所以，TIME_WAIT出现在 Web 服务器端。</li></ol><p>那么，在这种假定下：</p><ol><li>Web服务器上，肯定可以配置开启的配置：tcp_tw_reuse；如果Web服务器有很多连向DB服务器的连接，可以保证socket连接的复用。</li><li>那么，负载均衡服务器和Web服务器，谁先关闭连接，则决定了我们怎么配置tcp_tw_reuse/tcp_tw_recycle了</li></ol><p><strong>场景一：负载均衡服务器首先关闭连接</strong> </p><p>在这种情况下，因为负载均衡服务器对Web服务器的连接，TIME_WAIT大都出现在负载均衡服务器上。</p><p>在负载均衡服务器上的配置：</p><ul><li>net.ipv4.tcp_tw_reuse = 1 //尽量复用连接</li><li>net.ipv4.tcp_tw_recycle = 0 //不能保证客户端不在NAT的网络啊</li></ul><p>在Web服务器上的配置为：</p><ul><li>net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用</li><li>net.ipv4.tcp_tw_recycle： 设置成1和0都没有任何意义。想一想，在负载均衡和它的连接中，它是服务端，但是TIME_WAIT出现在负载均衡服务器上；它和DB的连接，它是客户端，recycle对它并没有什么影响，关键是reuse</li></ul><p><strong>场景二：Web服务器首先关闭来自负载均衡服务器的连接</strong></p><p>在这种情况下，Web服务器变成TIME_WAIT的重灾区。负载均衡对Web服务器的连接，由Web服务器首先关闭连接，TIME_WAIT出现在Web服务器上；Web服务器对DB服务器的连接，由Web服务器关闭连接，TIME_WAIT也出现在它身上，此时，负载均衡服务器上的配置：</p><ul><li>net.ipv4.tcp_tw_reuse：0 或者 1 都行，都没有实际意义</li><li>net.ipv4.tcp_tw_recycle=0 //一定是关闭recycle</li></ul><p>在Web服务器上的配置：</p><ul><li>net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用</li><li>net.ipv4.tcp_tw_recycle=1 //由于在负载均衡和Web服务器之间并没有NAT的网络，可以考虑开启recycle，加速由于负载均衡和Web服务器之间的连接造成的大量TIME_WAIT</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes高可用集群搭建</title>
      <link href="/2021/08/16/k8s-install/"/>
      <url>/2021/08/16/k8s-install/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-高可用集群搭建"><a href="#k8s-高可用集群搭建" class="headerlink" title="k8s 高可用集群搭建"></a>k8s 高可用集群搭建</h1><p><code>docker的安装自行搞定即可, 尽量不要用太高版本到version.19即可</code></p><p><strong>本文基于centos的操作系统，kubeadm来作为搭建方式</strong></p><ol><li><p>新建yum源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFsudo yum makecachesudo yum -y install kubelet-1.20.2  kubeadm-1.20.2  kubectl-1.20.2sudo systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用systemd作为docker的cgroup driver</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo vi  /etc/docker/daemon.json   （没有则创建）加入{  "exec-opts": ["native.cgroupdriver=systemd"]}systemctl daemon-reload  &amp;&amp; systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>切换到root用户执行 <strong>关键步骤</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># （如果是重置机器，需要执行）kubeadm resetrm /etc/cni/net.d -friptables -F yum -y remove kubelet-1.18.6  kubeadm-1.18.6  kubectl-1.18.6# （重置end）yum -y install kubelet-1.20.2  kubeadm-1.20.2  kubectl-1.20.2echo 1 &gt; /proc/sys/net/ipv4/ip_forwardmodprobe br_netfilterecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptablessystemctl daemon-reload  # 可能会报错 可以不执行这个systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>master节点执行以下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#主机执行：kubeadm init --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers  --kubernetes-version=1.20.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>得到token之后给worker依次执行， 加入到集群当中去， <code>初步就完成了集群的搭建</code> <strong>还差一个网络插件</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#得到token后，给另外worker去执行kubeadm join 192.168.0.191:6443 --token zx5rj1.19yqkv7q2uehatit \--discovery-token-ca-cert-hash sha256:b5a066c56e73896dc14530d5464eadd45732de6bd3806e878c80ed589e4ea502<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>给节点做一些完善工作</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#然后退出到普通用户, 用kubectl命令执行#去除主节点污点kubectl taint nodes --all node-role.kubernetes.io/master-   # (后面一个 – 是需要的)给工作节点打标签kubectl label node huawei-worker  node-role.kubernetes.io/node=node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们需要让外网也可以访问， <strong>也就是通过kubectl客户端工具能连接主机的外部ip地址，需要做此工作</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#让外网可以访问#先删除 apiserver的证书和key#主节点上cd /etc/kubernetes/pki &amp;&amp; rm -f apiserver.key &amp;&amp; rm -f  apiserver.crtsudo kubeadm init phase certs apiserver   --apiserver-cert-extra-sans 121.36.226.197kubeadm alpha certs renew apiserver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装网络插件， <strong>这里我们选择flannel</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://github.com/flannel-io/flannelFor Kubernetes v1.17+ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# apply里面的镜像要替换下，可以用katacoda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="大功告成啦-可以愉快的玩耍了！"><a href="#大功告成啦-可以愉快的玩耍了！" class="headerlink" title="大功告成啦~   可以愉快的玩耍了！"></a>大功告成啦~   可以愉快的玩耍了！</h3>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang context实现原理</title>
      <link href="/2021/08/14/context-shi-xian-yuan-li/"/>
      <url>/2021/08/14/context-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p>本文主要谈谈以下几个方面的内容：</p><ol><li>context的使用。</li><li>context实现原理，哪些是需要注意的地方</li><li>context的最佳实践。</li></ol><p><code>context</code>是Go中广泛使用的程序包，由Google官方开发，在1.7版本引入。它用来简化在多个go routine传递上下文数据、(手动/超时)中止routine树等操作，比如，官方http包使用context传递请求的上下文数据，gRpc使用context来终止某个请求产生的routine树。由于它使用简单，现在基本成了编写go基础库的通用规范。笔者在使用context上有一些经验，遂分享下。</p><p>本文主要谈谈以下几个方面的内容：</p><ol><li>context的使用。</li><li>context实现原理，哪些是需要注意的地方。</li><li>在实践中遇到的问题，分析问题产生的原因。</li></ol><h2 id="1-使用"><a href="#1-使用" class="headerlink" title="1 使用"></a>1 使用</h2><h3 id="核心接口Context"><a href="#核心接口Context" class="headerlink" title="核心接口Context"></a>核心接口Context</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token comment">// Deadline returns the time when work done on behalf of this context</span>    <span class="token comment">// should be canceled. Deadline returns ok==false when no deadline is</span>    <span class="token comment">// set.</span>    <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token comment">// Done returns a channel that's closed when work done on behalf of this</span>    <span class="token comment">// context should be canceled.</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// Err returns a non-nil error value after Done is closed.</span>    <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>    <span class="token comment">// Value returns the value associated with this context for key.</span>    <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单介绍一下其中的方法：<br>- <code>Done</code>会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回。<br>- <code>Context</code>中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问。<br>- <code>Deadline</code>会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间。<br>- <code>Value</code>可以让routine共享一些数据，当然获得数据是协程安全的。</p><p>在请求处理的过程中，会调用各层的函数，每层的函数会创建自己的routine，是一个routine树。所以，context也应该反映并实现成一棵树。</p><p>要创建context树，第一步是要有一个根结点。<code>context.Background</code>函数的返回值是一个空的context，经常作为树的根结点，它一般由接收请求的第一个routine创建，不能被取消、没有值、也没有过期时间。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后该怎么创建其它的子孙节点呢？context包为我们提供了以下函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这四个函数的第一个参数都是父context，返回一个Context类型的值，这样就层层创建出不同的节点。子节点是从复制父节点得到的，并且根据接收的函数参数保存子节点的一些状态值，然后就可以将它传递给下层的routine了。</p><p><code>WithCancel</code>函数，返回一个额外的CancelFunc函数类型变量，该函数类型的定义为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> CancelFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用CancelFunc对象将撤销对应的Context对象，这样父结点的所在的环境中，获得了撤销子节点context的权利，当触发某些条件时，可以调用CancelFunc对象来终止子结点树的所有routine。在子节点的routine中，需要用类似下面的代码来判断何时退出routine：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>cxt<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">// do some cleaning and return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据cxt.Done()判断是否结束。当顶层的Request请求处理结束，或者外部取消了这次请求，就可以cancel掉顶层context，从而使整个请求的routine树得以退出。</p><p><code>WithDeadline</code>和<code>WithTimeout</code>比<code>WithCancel</code>多了一个时间参数，它指示context存活的最长时间。如果超过了过期时间，会自动撤销它的子context。所以context的生命期是由父context的routine和<code>deadline</code>共同决定的。</p><p><code>WithValue</code>返回parent的一个副本，该副本保存了传入的key/value，而调用Context接口的Value(key)方法就可以得到val。注意在同一个context中设置key/value，若key相同，值会被覆盖。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h2><h2 id="2-1-上下文数据的存储与查询"><a href="#2-1-上下文数据的存储与查询" class="headerlink" title="2.1 上下文数据的存储与查询"></a>2.1 上下文数据的存储与查询</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil key"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>valueCtx<span class="token punctuation">{</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>key <span class="token operator">==</span> key <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span>val    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>context上下文数据的存储就像一个树，每个结点只存储一个key/value对。<code>WithValue()</code>保存一个key/value对，它将父context嵌入到新的子context，并在节点中保存了key/value数据。<code>Value()</code>查询key对应的value数据，会从当前context中查询，如果查不到，会递归查询父context中的数据。</p><p>值得注意的是，<strong>context中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据。</strong></p><h2 id="2-2-手动cancel和超时cancel"><a href="#2-2-手动cancel和超时cancel" class="headerlink" title="2.2 手动cancel和超时cancel"></a>2.2 手动cancel和超时cancel</h2><p><code>cancelCtx</code>中嵌入了父Context，实现了canceler接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context      <span class="token comment">// 保存parent Context</span>    done <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    mu       sync<span class="token punctuation">.</span>Mutex    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    err      <span class="token builtin">error</span><span class="token punctuation">}</span><span class="token comment">// A canceler is a context type that can be canceled directly. The</span><span class="token comment">// implementations are *cancelCtx and *timerCtx.</span><span class="token keyword">type</span> canceler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cancelCtx</code>结构体中<code>children</code>保存它的所有<code>子canceler</code>， 当外部触发cancel时，会调用<code>children</code>中的所有<code>cancel()</code>来终止所有的<code>cancelCtx</code>。<code>done</code>用来标识是否已被cancel。当外部触发cancel、或者父Context的channel关闭时，此done也会关闭。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timerCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    cancelCtx     <span class="token comment">//cancelCtx.Done()关闭的时机：1）用户调用cancel 2）deadline到了 3）父Context的done关闭了</span>    timer    <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer    deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    c <span class="token operator">:=</span> <span class="token operator">&amp;</span>timerCtx<span class="token punctuation">{</span>        cancelCtx<span class="token punctuation">:</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>        deadline<span class="token punctuation">:</span>  deadline<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    d <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span>    <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span> <span class="token comment">// deadline has already passed</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>timerCtx</code>结构体中<code>deadline</code>保存了超时的时间，当超过这个时间，会触发<code>cancel</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/ctx1.jpg" alt="img"></p><p>可以看出，<strong>cancelCtx也是一棵树，当触发cancel时，会cancel本结点和其子树的所有cancelCtx</strong>。</p><h2 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h2><p>由于go大量的官方库、第三方库使用了context，所以调用<code>接收context的函数</code>时要小心，要清楚context在什么时候cancel，什么行为会触发cancel。笔者在程序经常使用gRpc传出来的context，产生了一些非预期的结果，之后花时间总结了gRpc、内部基础库中context的生命期及行为，以避免出现同样的问题。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> context </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
