<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tcp为什么要分片?</title>
      <link href="/2021/12/27/tcp-wei-shi-me-yao-fen-pian/"/>
      <url>/2021/12/27/tcp-wei-shi-me-yao-fen-pian/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-0.jpg"></p><h3 id="什么是TCP分段和IP分片"><a href="#什么是TCP分段和IP分片" class="headerlink" title="什么是TCP分段和IP分片"></a>什么是TCP分段和IP分片</h3><p>我们知道网络就像一根管子，而管子吧，就会有粗细。</p><p>一个数据包想从管子的一端到另一端，得过这个管子。<em>（废话）</em></p><p>但数据包的量<strong>有大有小</strong>，想过管子，数据包不能大于这根管子的粗细。</p><p>问题来了，数据包过大时怎么办？</p><p>答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-1.jpg" alt="数据分片"></p><p>回去看下网络分层协议，数据先过传输层，再到网络层。</p><p>这个行为在<strong>传输层和网络层</strong>都有可能发生。</p><p>在传输层（<code>TCP</code>协议）里，叫<strong>分段</strong>。</p><p>在网络层（<code>IP</code>层），叫<strong>分片</strong>。（注意以下提到的IP没有特殊说明的情况下，都是指<strong>IPV4</strong>）</p><p>那么不管是分片还是分段，肯定需要<strong>按照一定的长度</strong>切分。</p><p>在<code>TCP</code>里，这个长度是<code>MSS</code>。</p><p>在<code>IP</code>层里，这个长度是<code>MTU</code>。</p><h3 id="MSS是什么"><a href="#MSS是什么" class="headerlink" title="MSS是什么"></a>MSS是什么</h3><p><strong>MSS：Maximum Segment Size</strong> 。TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和  TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-2.jpg" alt="MSS分段"></p><h4 id="如何查看MSS？"><a href="#如何查看MSS？" class="headerlink" title="如何查看MSS？"></a>如何查看MSS？</h4><p>我们都知道TCP三次握手，而<code>MSS</code>会在三次握手的过程中传递给对方，用于通知对端本地最大可以接收的TCP报文数据大小（不包含TCP和IP报文首部）。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-3.jpg" alt="抓包mss"></p><p>比如上图中，B将自己的MSS发送给A，建议A在发数据给B的时候，采用<code>MSS=1420</code>进行分段。而B在发数据给A的时候，同样会带上<code>MSS=1372</code>。两者在对比后，会采用<strong>小的</strong>那个值（1372）作为通信的<code>MSS值</code>，这个过程叫<code>MSS协商</code>。</p><blockquote><p>另外，一般情况下MSS + 20（TCP头）+ 20（IP头）= MTU，上面抓包的图里对应的MTU分别是1372+40 和 1420+40。同一个路径上，<strong>MTU不一定是对称的</strong>，也就是说A到B和B到A，两条路径上的MTU可以是不同的，对应的MSS也一样。</p></blockquote><h4 id="三次握手中协商了MSS就不会改变了吗？"><a href="#三次握手中协商了MSS就不会改变了吗？" class="headerlink" title="三次握手中协商了MSS就不会改变了吗？"></a>三次握手中协商了MSS就不会改变了吗？</h4><p>当然不是，每次执行TCP发送消息的函数时，会重新计算一次MSS，再进行分段操作。</p><h4 id="对端不传MSS会怎么样？"><a href="#对端不传MSS会怎么样？" class="headerlink" title="对端不传MSS会怎么样？"></a>对端不传MSS会怎么样？</h4><p>我们再看TCP的报头。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-4.jpg" alt="TCP报头"></p><p>其实MSS是作为可选项引入的，只不过一般情况下MSS都会传，但是万一遇到了哪台机器的实现上比较调皮，<strong>不传MSS</strong>这个可选项。那对端该怎么办？</p><p><strong>如果没有接收到对端TCP的MSS，本端TCP默认采用MSS=536Byte</strong>。</p><p>那为什么会是<code>536</code>？</p><pre class="line-numbers language-none"><code class="language-none">536（data） + 20（tcp头）+20（ip头）= 576Byte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前面提到了IP会切片，那会切片，也就会重组，而这个576正好是 IP 最小重组缓冲区的大小。</p><h3 id="MTU是什么"><a href="#MTU是什么" class="headerlink" title="MTU是什么"></a>MTU是什么</h3><p><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。其实这个是由<strong>数据链路层</strong>提供，为了告诉上层IP层，自己的传输能力是多大。IP层就会根据它进行数据包切分。一般 MTU=<strong>1500 Byte</strong>。<br>假设IP层有 &lt;= <code>1500</code> byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有 &gt; <code>1500</code> byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同，同时为了分片后能在接收端把切片组装起来，还需要在分片后的IP包里加上各种信息。比如这个分片在原来的IP包里的偏移offset。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-5.jpg" alt="MTU分片"></p><h4 id="如何查看MTU"><a href="#如何查看MTU" class="headerlink" title="如何查看MTU"></a>如何查看MTU</h4><p>在<code>mac</code>控制台输入 <code>ifconfig</code>命令，可以看到MTU的值为多大。</p><pre class="line-numbers language-none"><code class="language-none">$ ipconfiglo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384    ...en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500    ...p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这上面有好几个<strong>MTU</strong>，可以简单理解为每个网卡的处理能力不同，所以对应的MTU也不同。当然这个值是可以修改的，但不在今天的讨论范畴内，不再展开。</p><p>在一台机器的应用层到这台机器的网卡，<strong>这条链路上</strong>，基本上可以保证，<code>MSS &lt; MTU</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-6.jpg" alt="MSS和MTU的区别"></p><h4 id="为什么MTU一般是1500"><a href="#为什么MTU一般是1500" class="headerlink" title="为什么MTU一般是1500"></a>为什么MTU一般是1500</h4><p>这其实是由传输效率决定的。首先，虽然我们平时用的网络感觉挺稳定的，但其实这是因为TCP在背地里做了各种重传等保证了传输的可靠，其实背地里线路是动不动就丢包的，而越大的包，发生丢包的概率就越大。</p><p>那是不是包越小就越好？也不是</p><p>但是如果选择一个比较小的长度，假设选择<code>MTU</code>为<code>300Byte</code>，<code>TCP payload = 300 - IP Header - TCP Header = 300 - 20 - 20 = 260 byte</code>。那有效传输效率<code>= 260 / 300 = 86%</code></p><p>而如果以太网长度为1500，那有效传输效率<code>= 1460 / 1500 = 96%</code> ，显然比 <code>86%</code> 高多了。</p><p>所以，包越小越不容易丢包，包越大，传输效率又越高，因此权衡之下，选了<code>1500</code>。</p><h3 id="为什么IP层会分片，TCP还要分段"><a href="#为什么IP层会分片，TCP还要分段" class="headerlink" title="为什么IP层会分片，TCP还要分段"></a>为什么IP层会分片，TCP还要分段</h3><p>由于本身IP层就会做分片这件事情。<strong>就算TCP不分段</strong>，到了IP层，数据包也会被分片，数据也能<strong>正常传输</strong>。</p><p>既然网络层就会分片了，那么TCP为什么还要分段？是不是有些多此一举？</p><p>假设有一份数据，较大，且在TCP层不分段，如果这份数据在发送的过程中出现<strong>丢包</strong>现象，TCP会发生重传，那么重传的就是这一大份数据（虽然IP层会把数据切分为MTU长度的N多个小包，但是TCP重传的单位却是那一大份数据）。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-7.jpg" alt="假设TCP不分段"></p><p>如果TCP把这份数据，分段为N个小于等于MSS长度的数据包，到了IP层后加上IP头和TCP头，还是小于MTU，那么IP层也不会再进行分包。此时在传输路上发生了丢包，那么TCP重传的时候也只是重传那一小部分的MSS段。效率会比TCP不分段时更高。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-8.jpg" alt="假设TCP分段"></p><p>类似的，传输层除了TCP外，还有UDP协议，但UDP本身不会分段，所以当数据量较大时，只能交给IP层去分片，然后传到底层进行发送。</p><p>也就是说，正常情况下，在一台机器的传输层到网络层<strong>这条链路上</strong>，如果传输层对数据做了分段，那么IP层就不会再分片。如果传输层没分段，那么IP层就可能会进行分片。</p><p>说白了，<strong>数据在TCP分段，就是为了在IP层不需要分片，同时发生重传的时候只重传分段后的小份数据</strong>。</p><h3 id="TCP分段了，IP层就一定不会分片了吗"><a href="#TCP分段了，IP层就一定不会分片了吗" class="headerlink" title="TCP分段了，IP层就一定不会分片了吗"></a>TCP分段了，IP层就一定不会分片了吗</h3><p>上面提到了，在发送端，TCP分段后，IP层就不会再分片了。</p><p>但是整个传输链路中，可能还会有其他网络层设备，而这些设备的MTU可能小于发送端的MTU。此时虽然数据包在发送端已经<strong>分段</strong>过了，但是在IP层就还会再分片一次。</p><p>如果链路上还有设备有<strong>更小的MTU</strong>，那么还会再分片，最后所有的分片都会在<strong>接收端</strong>处进行组装。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-9.jpg" alt="IP分片再分片"></p><p>因此，就算TCP分段过后，在链路上的其他节点的IP层也是有可能再分片的，而且哪怕数据被第一次IP分片过了，也是有可能被其他机器的IP层进行二次、三次、四次….分片的。</p><h3 id="IP层怎么做到不分片"><a href="#IP层怎么做到不分片" class="headerlink" title="IP层怎么做到不分片"></a>IP层怎么做到不分片</h3><p>上面提到的IP层在传输过程中<strong>因为各个节点间MTU</strong>可能不同，导致数据是可能被多次分片的。而且每次分片都要加上各种信息便于在接收端进行分片重组。那么IP层是否可以做到不分片？</p><p>如果有办法知道整个链路上，最小的MTU是多少，并且以最小MTU长度发送数据，那么不管数据传到哪个节点，都不会发生分片。</p><p>整个链路上，<strong>最小的MTU，就叫PMTU</strong>（path MTU）。</p><p>有一个<strong>获得这个PMTU的方法，叫 Path MTU Discovery</strong>。</p><pre class="line-numbers language-none"><code class="language-none">$cat /proc/sys/net/ipv4/ip_no_pmtu_disc0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认为<code>0</code>，意思是开启PMTU发现的功能。现在一般机器上都是开启的状态。</p><p>原理比较简单，首先我们先回去看下IP的数据报头。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-10.jpg" alt="IP报头DF"></p><p>这里有个标红的标志位<code>DF</code>（Don’t Fragment），当它置为1，意味着这个IP报文不分片。</p><p>当链路上某个路由器，收到了这个报文，当IP报文长度大于路由器的MTU时，路由器会看下这个IP报文的<code>DF</code></p><ul><li>如果为<code>0</code>（允许分片），就会分片并把分片后的数据传到下一个路由器</li><li>如果为<code>1</code>，就会把数据丢弃，同时返回一个ICMP包给发送端，并告诉它*”达咩!”*数据不可达，需要分片，同时带上当前机器的MTU</li></ul><p>理解了上面的原理后，我们再看下PMTU发现是怎么实现的。</p><ul><li>应用通过TCP正常发送消息，传输层<strong>TCP分段</strong>后，到<strong>网络层</strong>加上IP头，<strong>DF置为1</strong>，消息再到更底层执行发送</li><li>此时链路上有台<strong>路由器</strong>由于各种原因<strong>MTU变小了</strong></li><li>IP消息到这台路由器了，路由器发现消息长度大于自己的MTU，且消息自带DF不让分片。就把消息丢弃。同时返回一个<code>ICMP</code>错误给发送端，同时带上自己的<code>MTU</code>。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-11.jpg" alt="获得pmtu"></p><ul><li>发送端收到这个ICMP消息，会更新自己的MTU，同时记录到一个<strong>PMTU表</strong>中。</li><li>因为TCP的可靠性，会尝试重传这个消息，同时以这个新MTU值计算出MSS进行分段，此时新的IP包就可以顺利被刚才的路由器转发。</li><li>如果路径上还有更小的MTU的路由器，那上面发生的事情还会再发生一次。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp03-12.jpg" alt="获得pmtu后的TCP重传"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>数据在TCP分段，在IP层就不需要分片，同时发生重传的时候只重传分段后的小份数据</li><li>TCP分段时使用MSS，IP分片时使用MTU</li><li>MSS是通过MTU计算得到，在三次握手和发送消息时都有可能产生变化。</li><li>IP分片是<strong>不得已</strong>的行为，尽量不在IP层分片，尤其是链路上中间设备的IP分片。因此，在IPv6中已经禁止中间节点设备对IP报文进行分片，分片只能在链路的最开头和最末尾两端进行。</li><li>建立连接后，路径上节点的MTU值改变时，可以通过PMTU发现更新发送端MTU的值。这种情况下，PMTU发现通过浪费N次发送机会来换取的PMTU，TCP因为有重传可以保证可靠性，在UDP就相当于消息直接丢了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 协议 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>send出去, 数据就发送了么?</title>
      <link href="/2021/12/21/send-chu-qu-shu-ju-jiu-fa-song-liao-me/"/>
      <url>/2021/12/21/send-chu-qu-shu-ju-jiu-fa-song-liao-me/</url>
      
        <content type="html"><![CDATA[<p>代码执行send成功后，数据就发出去了吗？</p><p>回答这个问题之前，需要了解什么是<strong>Socket 缓冲区</strong>。</p><h2 id="Socket-缓冲区"><a href="#Socket-缓冲区" class="headerlink" title="Socket 缓冲区"></a>Socket 缓冲区</h2><h3 id="什么是-socket-缓冲区"><a href="#什么是-socket-缓冲区" class="headerlink" title="什么是 socket 缓冲区"></a>什么是 socket 缓冲区</h3><p>编程的时候，如果要跟某个IP建立连接，我们需要调用操作系统提供的 <code>socket API</code>。</p><p><strong>socket</strong> 在操作系统层面，可以理解为一个<strong>文件</strong>。</p><p>我们可以对这个文件进行一些<strong>方法操作</strong>。</p><p>用<code>listen</code>方法，可以让程序作为服务器<strong>监听</strong>其他客户端的连接。</p><p>用<code>connect</code>，可以作为客户端<strong>连接</strong>服务器。</p><p>用<code>send</code>或<code>write</code>可以<strong>发送</strong>数据，<code>recv</code>或<code>read</code>可以<strong>接收</strong>数据。</p><p>在建立好连接之后，这个 <strong>socket</strong> 文件就像是远端机器的 <strong>“代理人”</strong> 一样。比如，如果我们想给远端服务发点什么东西，那就只需要对这个文件执行写操作就行了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-3.jpg" alt="socket_api"></p><p>那写到了这个文件之后，剩下的发送工作自然就是由操作系统<strong>内核</strong>来完成了。</p><p>既然是写给操作系统，那操作系统就需要<strong>提供一个地方给用户写</strong>。同理，接收消息也是一样。</p><p>这个地方就是 <strong>socket 缓冲区</strong>。</p><p>用户<strong>发送</strong>消息的时候写给 send buffer（发送缓冲区）</p><p>用户<strong>接收</strong>消息的时候写给 recv buffer（接收缓冲区）</p><p>也就是说<strong>一个socket ，会带有两个缓冲区</strong>，一个用于发送，一个用于接收。因为这是个先进先出的结构，有时候也叫它们<strong>发送、接收队列</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-4.jpg" alt="一个socket有两个缓冲区"></p><h4 id="怎么观察-socket-缓冲区"><a href="#怎么观察-socket-缓冲区" class="headerlink" title="怎么观察 socket 缓冲区"></a>怎么观察 socket 缓冲区</h4><p>如果想要查看 socket 缓冲区，可以在linux环境下执行 <code>netstat -nt</code> 命令。</p><pre class="line-numbers language-none"><code class="language-none"># netstat -ntActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State      tcp        0     60 172.22.66.69:22         122.14.220.252:59889    ESTABLISHED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的IP信息，状态（State）是已连接。</p><p>还有<strong>Send-Q 是发送缓冲区</strong>，下面的数字60是指，当前还有60 Byte在发送缓冲区中未发送。而 <strong>Recv-Q 代表接收缓冲区</strong>， 此时是空的，数据都被应用进程接收干净了。</p><h2 id="TCP部分"><a href="#TCP部分" class="headerlink" title="TCP部分"></a>TCP部分</h2><p>【动图缓冲区的收发流程，TCP执行发收的流程】</p><p>我们在使用TCP建立连接之后，一般会使用 send 发送数据。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 创建socket</span>    sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 建立连接  </span>    <span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> 服务器ip信息<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// 执行 send 发送消息</span>    <span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// 关闭 socket</span>    <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是一段伪代码，仅用于展示大概逻辑，我们在建立好连接后，一般会在代码中执行 <code>send</code> 方法。那么此时，消息就会被立刻发到对端机器吗？</p><h3 id="执行-send-发送的字节，会立马发送吗？"><a href="#执行-send-发送的字节，会立马发送吗？" class="headerlink" title="执行 send 发送的字节，会立马发送吗？"></a>执行 send 发送的字节，会立马发送吗？</h3><p>答案是不确定！执行 send 之后，数据只是拷贝到了socket 缓冲区。至 什么时候会发数据，发多少数据，全听操作系统安排。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-5.jpg" alt="tcp_sendmsg 逻辑"></p><p>在用户进程中，程序通过操作 socket 会从用户态进入内核态，而 send方法会将数据一路传到传输层。在识别到是 TCP协议后，会调用 tcp_sendmsg 方法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// net/ipv4/tcp.c</span><span class="token comment">// 以下省略了大量逻辑</span><span class="token keyword">int</span> <span class="token function">tcp_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 如果还有可以放数据的空间</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 尝试拷贝待发送数据到发送缓冲区</span>    err <span class="token operator">=</span> <span class="token function">skb_add_data_nocache</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment">// 下面是尝试发送的逻辑代码,先省略     </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 tcp_sendmsg 中， 核心工作就是将待发送的数据组织按照先后顺序放入到发送缓冲区中， 然后根据实际情况（比如拥塞窗口等）判断是否要发数据。如果不发送数据，那么此时直接返回。</p><h3 id="如果缓冲区满了会怎么办"><a href="#如果缓冲区满了会怎么办" class="headerlink" title="如果缓冲区满了会怎么办"></a>如果缓冲区满了会怎么办</h3><p>前面提到的情况里是，发送缓冲区有足够的空间，可以用于拷贝待发送数据。</p><h4 id="如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？"><a href="#如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？" class="headerlink" title="如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？"></a>如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？</h4><p>这里分两种情况。</p><p>首先，socket在创建的时候，是可以设置是<strong>阻塞</strong>的还是<strong>非阻塞</strong>的。</p><pre class="line-numbers language-none"><code class="language-none">int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如通过上面的代码，就可以将 <code>socket</code> 设置为<strong>非阻塞</strong> （<code>SOCK_NONBLOCK</code>）。</p><p>当发送缓冲区<strong>满了</strong>，如果还向socket执行send</p><ul><li>如果此时 socket 是阻塞的，那么程序会在那<strong>干等、死等</strong>，直到释放出新的缓存空间，就继续把数据拷进去，然后<strong>返回</strong>。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-6.jpg" alt="send阻塞"></p><ul><li>如果此时 socket 是非阻塞的，程序就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是  <code>Try again</code> , 现在缓冲区满了，你也别等了，待会再试一次。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-7.jpg" alt="send非阻塞"></p><p>我们可以简单看下源码是怎么实现的。还是回到刚才的 <code>tcp_sendmsg</code> 发送方法中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ..如果有足够缓冲区就执行balabla</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果发送缓冲区没空间了，那就等到有空间，至于等的方式，分阻塞和非阻塞</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">sk_stream_wait_memory</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> do_error<span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token punctuation">}</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面提到的  <code>sk_stream_wait_memory</code> 会根据<code>socket</code>是否阻塞来决定是一直等等一会就返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sk_stream_wait_memory</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>timeo_p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 非阻塞模式时，会等到超时返回 EAGAIN</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>等待超时<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>          <span class="token comment">// 阻塞等待时，会等到发送缓冲区有足够的空间了，才跳出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sk_stream_memory_free</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm_wait<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如果接收缓冲区为空，执行-recv-会怎么样？"><a href="#如果接收缓冲区为空，执行-recv-会怎么样？" class="headerlink" title="如果接收缓冲区为空，执行 recv 会怎么样？"></a>如果接收缓冲区为空，执行 recv 会怎么样？</h4><p>接收缓冲区也是类似的情况。</p><p>当接收缓冲区<strong>为空</strong>，如果还向socket执行 recv</p><ul><li>如果此时 socket 是阻塞的，那么程序会在那<strong>干等</strong>，直到接收缓冲区有数据，就会把数据从接收缓冲区拷贝到用户缓冲区，然后<strong>返回</strong>。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-8.jpg" alt="recv阻塞"></p><ul><li>如果此时 socket 是非阻塞的，程序就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-9.jpg" alt="recv非阻塞"></p><p>下面用一张图汇总一下，方便大家保存面试的时候用哈哈哈。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp02-10.jpg" alt="recv非阻塞">socket读写缓冲区满了的情况汇总</p><h3 id="如果socket缓冲区还有数据，执行close了，会怎么样？"><a href="#如果socket缓冲区还有数据，执行close了，会怎么样？" class="headerlink" title="如果socket缓冲区还有数据，执行close了，会怎么样？"></a>如果socket缓冲区还有数据，执行close了，会怎么样？</h3><p>首先我们要知道，<strong>一般正常情况下，发送缓冲区和接收缓冲区 都应该是空的。</strong></p><p>如果发送、接收缓冲区长时间非空，说明有数据堆积，这往往是由于一些网络问题或用户应用层问题，导致数据没有正常处理。</p><p>那么正常情况下，如果 <code>socket</code> 缓冲区<strong>为空</strong>，执行 <code>close</code>。就会触发四次挥手。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjSfT17HEmqQ3YnuSic8aL9XJhGOEgdXkB14txCYzPSqjR8NDu0up6nRA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">TCP四次挥手</p><p>这个也是面试老八股文内容了，<strong>这里我们只需要关注第一次挥手，发的是 <code>FIN</code> 就够了</strong>。</p><h4 id="如果接收缓冲区有数据时，执行close了，会怎么样？"><a href="#如果接收缓冲区有数据时，执行close了，会怎么样？" class="headerlink" title="如果接收缓冲区有数据时，执行close了，会怎么样？"></a>如果接收缓冲区有数据时，执行close了，会怎么样？</h4><p><code>socket close</code> 时，主要的逻辑在 <code>tcp_close()</code> 里实现。</p><p>先说结论，关闭过程主要有两种情况：</p><ul><li>如果接收缓冲区还有数据未读，会先把接收缓冲区的数据清空，然后给对端发一个RST。</li><li>如果接收缓冲区是空的，那么就调用 <code>tcp_send_fin()</code> 开始进行四次挥手过程的第一次挥手。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 如果接收缓冲区有数据，那么清空数据</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>skb <span class="token operator">=</span> <span class="token function">__skb_dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_receive_queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        u32 len <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq <span class="token operator">-</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq <span class="token operator">-</span>              <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>fin<span class="token punctuation">;</span>        data_was_unread <span class="token operator">+=</span> len<span class="token punctuation">;</span>        <span class="token function">__kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>data_was_unread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果接收缓冲区的数据被清空了，发 RST</span>        <span class="token function">tcp_send_active_reset</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_close_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 正常四次挥手， 发 FIN</span>        <span class="token function">tcp_send_fin</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 等待关闭</span>    <span class="token function">sk_stream_wait_close</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjjP4WDVfnF2bmf32kZ6icQHfOa8OibmS5MZG9TFMQ96GNltYibOFDGFTkg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="图片">recvbuf非空</p><h4 id="如果发送缓冲区有数据时，执行close了，会怎么样？"><a href="#如果发送缓冲区有数据时，执行close了，会怎么样？" class="headerlink" title="如果发送缓冲区有数据时，执行close了，会怎么样？"></a>如果发送缓冲区有数据时，执行close了，会怎么样？</h4><p>以前以为，这种情况下，内核会把发送缓冲区数据清空，然后四次挥手。</p><p>但是发现源码<strong>并不是这样的</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_send_fin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 获得发送缓冲区的最后一块数据</span>    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token operator">*</span>tskb <span class="token operator">=</span> <span class="token function">tcp_write_queue_tail</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果发送缓冲区还有数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tskb <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">sk_under_memory_pressure</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>tskb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>tcp_flags <span class="token operator">|=</span> TCPHDR_FIN<span class="token punctuation">;</span> <span class="token comment">// 把最后一块数据值为 FIN </span>        <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>tskb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq<span class="token operator">++</span><span class="token punctuation">;</span>        tp<span class="token operator">-&gt;</span>write_seq<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 发送缓冲区没有数据，就造一个FIN包</span>  <span class="token punctuation">}</span>  <span class="token comment">// 发送数据</span>    <span class="token function">__tcp_push_pending_frames</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">tcp_current_mss</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> TCP_NAGLE_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，还有些数据没发出去，内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。</p><p><code>socket</code> 缓冲区是个<strong>先进先出</strong>的队列，这种情况是指内核会等待TCP层安静把发送缓冲区数据都发完，最后再执行 四次挥手的第一次挥手（FIN包）。</p><p>有一点需要注意的是，只有在<strong>接收缓冲区为空的前提下</strong>，我们才有可能走到 <code>tcp_send_fin()</code> 。而只有在进入了这个方法之后，我们才有可能考虑发送缓冲区是否为空的场景。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlQB0CrBiboEZGfE8keHGEsjWnK0M8ibXAAxOl5mudeZcVDYZU0icOfn4WcCME5iaHBdXib3oqZH7kyic1g/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="图片">sendbuf非空</p><h2 id="UDP部分"><a href="#UDP部分" class="headerlink" title="UDP部分"></a>UDP部分</h2><h3 id="UDP也有缓冲区吗"><a href="#UDP也有缓冲区吗" class="headerlink" title="UDP也有缓冲区吗"></a>UDP也有缓冲区吗</h3><p>说完TCP了，我们聊聊UDP。这对好基友，同时都是传输层里的重要协议。既然前面提到TCP有发送、接收缓冲区，那UDP有吗？</p><p>以前我以为。</p><blockquote><p>“每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。”</p></blockquote><p>后来我发现我错了。</p><p>UDP socket 也是 socket，一个socket 就是会有收和发两个缓冲区。跟用什么协议关系不大。</p><p>有没有是一回事，用不用又是一回事。</p><h3 id="UDP不用发送缓冲区？"><a href="#UDP不用发送缓冲区？" class="headerlink" title="UDP不用发送缓冲区？"></a>UDP不用发送缓冲区？</h3><p>事实上，UDP不仅有发送缓冲区，也用发送缓冲区。</p><p>一般正常情况下，会把数据直接拷到发送缓冲区后直接发送。</p><p>还有一种情况，是在发送数据的时候，设置一个 <code>MSG_MORE</code> 的标记。</p><pre class="line-numbers language-none"><code class="language-none">ssize_t send(int sock, const void *buf, size_t len, int flags); // flag 置为 MSG_MORE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大概的意思是告诉内核，待会还有其他<strong>更多消息</strong>要一起发，先别着急发出去。此时内核就会把这份数据先用<strong>发送缓冲区</strong>缓存起来，待会应用层说ok了，再一起发。</p><p>我们可以看下源码。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">udp_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// corkreq 为 true 表示是 MSG_MORE 的方式，仅仅组织报文，不发送；</span>    <span class="token keyword">int</span> corkreq <span class="token operator">=</span> up<span class="token operator">-&gt;</span>corkflag <span class="token operator">||</span> msg<span class="token operator">-&gt;</span>msg_flags<span class="token operator">&amp;</span>MSG_MORE；    <span class="token comment">//  将要发送的数据，按照MTU大小分割，每个片段一个skb；并且这些</span>    <span class="token comment">//  skb会放入到套接字的发送缓冲区中；该函数只是组织数据包，并不执行发送动作。</span>    err <span class="token operator">=</span> <span class="token function">ip_append_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> getfrag<span class="token punctuation">,</span> msg<span class="token operator">-&gt;</span>msg_iov<span class="token punctuation">,</span> ulen<span class="token punctuation">,</span>                 <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">udphdr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ipc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token punctuation">,</span>                 corkreq <span class="token operator">?</span> msg<span class="token operator">-&gt;</span>msg_flags<span class="token operator">|</span>MSG_MORE <span class="token operator">:</span> msg<span class="token operator">-&gt;</span>msg_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没有启用 MSG_MORE 特性，那么直接将发送队列中的数据发送给IP。 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>corkreq<span class="token punctuation">)</span>        err <span class="token operator">=</span> <span class="token function">udp_push_pending_frames</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，不管是不是 <code>MSG_MORE</code>， IP都会先把数据放到发送队列中，然后根据实际情况再考虑是不是立刻发送。</p><p>而我们大部分情况下，都不会用  <code>MSG_MORE</code>，也就是来一个数据包就直接发一个数据包。从这个行为上来说，<strong>虽然UDP用上了发送缓冲区，但实际上并没有起到”缓冲”的作用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 协议 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有accept, 是否能建立tcp?</title>
      <link href="/2021/12/15/mei-you-accept-neng-jian-li-tcp-me/"/>
      <url>/2021/12/15/mei-you-accept-neng-jian-li-tcp-me/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-0.gif" alt="握手建立连接流程"></p><p>上面这个动图，是我们平时客户端和服务端建立连接时的代码流程。</p><p>对应的是下面一段简化过的服务端伪代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/*Step 1: 创建服务器端监听socket描述符listen_fd*/</span>        listen_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*Step 2: bind绑定服务器端的IP和端口，所有客户端都向这个IP和端口发送和请求数据*/</span>        <span class="token function">bind</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*Step 3: 服务端开启监听*/</span>        <span class="token function">listen</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*Step 4: 服务器等待客户端的链接，返回值cfd为客户端的socket描述符*/</span>        cfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> xxx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/*Step 5: 读取客户端发来的数据*/</span>      n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>估计大家也是老熟悉这段伪代码了。</p><p>需要注意的是，在执行<code>listen()</code>方法之后还会执行一个<code>accept()</code>方法。</p><p><strong>一般情况</strong>下，如果启动服务器，会发现最后程序会<strong>阻塞在</strong><code>accept()</code>里。</p><p>此时服务端就算ok了，就等客户端了。</p><p>那么，再看下简化过的客户端伪代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/*Step 1: 创建客户端端socket描述符cfd*/</span>        cfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*Step 2: connect方法,对服务器端的IP和端口号发起连接*/</span>        ret <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> xxxx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*Step 4: 向服务器端写数据*/</span>    <span class="token function">write</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端比较简单，创建好<code>socket</code>之后，直接就发起<code>connect</code>方法。</p><p>此时回到服务端，会发现<strong>之前一直阻塞的accept方法，返回结果了</strong>。</p><p>这就算两端成功建立好了一条连接。之后就可以愉快的进行读写操作了。</p><p>那么，我们今天的问题是，<strong>如果没有这个accept方法，TCP连接还能建立起来吗？</strong></p><p>其实只要在执行<code>accept()</code> 之前执行一个 <code>sleep(20)</code>，然后立刻执行客户端相关的方法，同时抓个包，就能得出结论。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-1.jpg" alt="不执行accept时抓包结果"></p><p>从抓包结果看来，<strong>就算不执行accept()方法，三次握手照常进行，并顺利建立连接。</strong></p><p>更骚气的是，<strong>在服务端执行accept()前，如果客户端发送消息给服务端，服务端是能够正常回复ack确认包的。</strong></p><p>并且，<code>sleep(20)</code>结束后，服务端正常执行<code>accept()</code>，客户端前面发送的消息，还是能正常收到的。</p><p>通过这个现象，我们可以多想想为什么。顺便好好了解下三次握手的细节。</p><h3 id="三次握手的细节分析"><a href="#三次握手的细节分析" class="headerlink" title="三次握手的细节分析"></a>三次握手的细节分析</h3><p>我们先看面试八股文的老股，三次握手。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-2.jpg" alt="TCP三次握手"></p><p>服务端代码，对socket执行bind方法可以绑定监听端口，然后执行<code>listen方法</code>后，就会进入监听（<code>LISTEN</code>）状态。内核会为每一个处于<code>LISTEN</code>状态的<code>socket</code> 分配两个队列，分别叫<strong>半连接队列和全连接队列</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-3.jpg" alt="每个listen Socket都有一个全连接和半连接队列"></p><h4 id="半连接队列、全连接队列是什么"><a href="#半连接队列、全连接队列是什么" class="headerlink" title="半连接队列、全连接队列是什么"></a>半连接队列、全连接队列是什么</h4><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-4.jpg" alt="半连接队列和全连接队列"></p><ul><li><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</li><li><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></li></ul><p>看到这里，文章开头的问题就有了答案，建立连接的过程中根本不需要<code>accept()</code> 参与， <strong>执行accept()只是为了从全连接队列里取出一条连接。</strong></p><p>我们把话题再重新回到这两个队列上。</p><p>虽然都叫<strong>队列</strong>，但其实<strong>全连接队列（icsk_accept_queue）是个链表</strong>，而<strong>半连接队列（syn_table）是个哈希表</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-5.jpg" alt="半连接全连接队列的内部结构"></p><h4 id="为什么半连接队列要设计成哈希表"><a href="#为什么半连接队列要设计成哈希表" class="headerlink" title="为什么半连接队列要设计成哈希表"></a>为什么半连接队列要设计成哈希表</h4><p>先对比下<strong>全连接里队列</strong>，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为<code>O(1)</code>。</p><p>而<strong>半连接队列</strong>却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，<strong>如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。</strong></p><p>而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到<code>O(1)</code>了。</p><p>因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。</p><h4 id="怎么观察两个队列的大小"><a href="#怎么观察两个队列的大小" class="headerlink" title="怎么观察两个队列的大小"></a>怎么观察两个队列的大小</h4><h5 id="查看全连接队列"><a href="#查看全连接队列" class="headerlink" title="查看全连接队列"></a>查看全连接队列</h5><pre class="line-numbers language-none"><code class="language-none"># ss -lntState      Recv-Q Send-Q     Local Address:Port           Peer Address:PortLISTEN     0      128        127.0.0.1:46269              *:*              <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过<code>ss -lnt</code>命令，可以看到全连接队列的大小，其中<code>Send-Q</code>是指全连接队列的最大值，可以看到我这上面的最大值是<code>128</code>；<code>Recv-Q</code>是指当前的全连接队列的使用值，我这边用了<code>0</code>个，也就是全连接队列里为空，连接都被取出来了。</p><p>当上面<code>Send-Q</code>和<code>Recv-Q</code>数值很接近的时候，那么全连接队列可能已经满了。可以通过下面的命令查看是否发生过队列<strong>溢出</strong>。</p><pre class="line-numbers language-none"><code class="language-none"># netstat -s | grep overflowed    4343 times the listen queue of a socket overflowed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面说明发生过<code>4343次</code>全连接队列溢出的情况。这个查看到的是<strong>历史发生过的次数</strong>。</p><p>如果配合使用<code>watch -d</code> 命令，可以自动每<code>2s</code>间隔执行相同命令，还能高亮显示变化的数字部分，如果溢出的数字不断变多，说明<strong>正在发生</strong>溢出的行为。</p><pre class="line-numbers language-none"><code class="language-none"># watch -d 'netstat -s | grep overflowed'Every 2.0s: netstat -s | grep overflowed                                Fri Sep 17 09:00:45 2021    4343 times the listen queue of a socket overflowed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查看半连接队列"><a href="#查看半连接队列" class="headerlink" title="查看半连接队列"></a>查看半连接队列</h5><p>半连接队列没有命令可以直接查看到，但因为半连接队列里，放的都是<code>SYN_RECV</code> 状态的连接，那可以通过统计处于这个状态的连接的数量，间接获得半连接队列的长度。</p><pre class="line-numbers language-none"><code class="language-none"># netstat -nt | grep -i '127.0.0.1:8080' | grep -i 'SYN_RECV' | wc -l0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意半连接队列和全连接队列都是挂在某个<code>Listen socket</code>上的，我这里用的是<code>127.0.0.1:8080</code>，大家可以替换成自己想要查看的<strong>IP端口</strong>。</p><p>可以看到我的机器上的半连接队列长度为<code>0</code>，这个很正常，<strong>正经连接谁会没事老待在半连接队列里。</strong></p><p>当队列里的半连接不断增多，最终也是会发生溢出，可以通过下面的命令查看。</p><pre class="line-numbers language-none"><code class="language-none"># netstat -s | grep -i "SYNs to LISTEN sockets dropped"     26395 SYNs to LISTEN sockets dropped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，我的机器上一共发生了<code>26395</code>次半连接队列溢出。同样建议配合<code>watch -d</code> 命令使用。</p><pre class="line-numbers language-none"><code class="language-none"># watch -d 'netstat -s | grep -i "SYNs to LISTEN sockets dropped"'Every 2.0s: netstat -s | grep -i "SYNs to LISTEN sockets dropped"       Fri Sep 17 08:36:38 2021    26395 SYNs to LISTEN sockets dropped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全连接队列满了会怎么样？"><a href="#全连接队列满了会怎么样？" class="headerlink" title="全连接队列满了会怎么样？"></a>全连接队列满了会怎么样？</h4><p>如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。</p><p>但除了丢弃之外，还有一些附带行为，这会受 <code>tcp_abort_on_overflow</code> 参数的影响。</p><pre class="line-numbers language-none"><code class="language-none"># cat /proc/sys/net/ipv4/tcp_abort_on_overflow0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>tcp_abort_on_overflow</code>设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的<strong>半连接队列里的连接</strong>给删掉。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-6.jpg" alt="tcp_abort_on_overflow为0"></p><ul><li><code>tcp_abort_on_overflow</code>设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。</li></ul><p>这个现象是不是很熟悉，服务端<strong>端口未监听</strong>时，客户端尝试去连接，服务端也会回一个RST。这两个情况长一样，所以客户端这时候收到RST之后，其实无法区分到底是<strong>端口未监听</strong>，还是<strong>全连接队列满了</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-7.jpg" alt="tcp_abort_on_overflow为1"></p><h4 id="半连接队列要是满了会怎么样"><a href="#半连接队列要是满了会怎么样" class="headerlink" title="半连接队列要是满了会怎么样"></a>半连接队列要是满了会怎么样</h4><p><strong>一般是丢弃</strong>，但这个行为可以通过 <code>tcp_syncookies</code> 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。</p><p>首先我们需要明白，一般情况下，半连接的”生存”时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了<strong>SYN Flood攻击</strong>。</p><p>所谓<strong>SYN Flood攻击</strong>，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-8.jpg" alt="syn攻击"></p><p>那这种情况怎么处理？有没有一种方法可以<strong>绕过半连接队列</strong>？</p><p>有，上面提到的<code>tcp_syncookies</code>派上用场了。</p><pre class="line-numbers language-none"><code class="language-none"># cat /proc/sys/net/ipv4/tcp_syncookies1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当它被设置为1的时候，客户端发来<strong>第一次握手</strong>SYN时，服务端<strong>不会将其放入半连接队列中</strong>，而是直接生成一个<code>cookies</code>，这个<code>cookies</code>会跟着<strong>第二次握手</strong>，发回客户端。客户端在发<strong>第三次握手</strong>的时候带上这个<code>cookies</code>，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-9.jpg" alt="tcp_syncookies=1"></p><h5 id="会有一个cookies队列吗"><a href="#会有一个cookies队列吗" class="headerlink" title="会有一个cookies队列吗"></a>会有一个cookies队列吗</h5><p>生成是<code>cookies</code>，保存在哪呢？<strong>是不是会有一个队列保存这些cookies？</strong></p><p>我们可以反过来想一下，如果有<code>cookies</code>队列，那它会跟半连接队列一样，到头来，还是会被<strong>SYN Flood 攻击</strong>打满。</p><p>实际上<code>cookies</code>并不会有一个专门的队列保存，它是通过<strong>通信双方的IP地址端口、时间戳、MSS</strong>等信息进行<strong>实时计算</strong>的，保存在<strong>TCP报头</strong>的<code>seq</code>里。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-10.jpg" alt="tcp报头_seq的位置"></p><p>当服务端收到客户端发来的第三次握手包时，会通过seq还原出<strong>通信双方的IP地址端口、时间戳、MSS</strong>，验证通过则建立连接。</p><h5 id="cookies方案为什么不直接取代半连接队列？"><a href="#cookies方案为什么不直接取代半连接队列？" class="headerlink" title="cookies方案为什么不直接取代半连接队列？"></a>cookies方案为什么不直接取代半连接队列？</h5><p>目前看下来<code>syn cookies</code>方案省下了半连接队列所需要的队列内存，还能解决 <strong>SYN Flood攻击</strong>，那为什么不直接取代半连接队列？</p><p>凡事皆有利弊，<code>cookies</code>方案虽然能防 <strong>SYN Flood攻击</strong>，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</p><p>另外，编码解码<code>cookies</code>，都是比较<strong>耗CPU</strong>的，利用这一点，如果此时攻击者构造大量的<strong>第三次握手包（ACK包）</strong>，同时带上各种瞎编的<code>cookies</code>信息，服务端收到<code>ACK包</code>后<strong>以为是正经cookies</strong>，憨憨地跑去解码（<strong>耗CPU</strong>），最后发现不是正经数据包后才丢弃。</p><p>这种通过构造大量<code>ACK包</code>去消耗服务端资源的攻击，叫<strong>ACK攻击</strong>，受到攻击的服务器可能会因为<strong>CPU资源耗尽</strong>导致没能响应正经请求。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcp01-11.gif" alt="ack攻击"></p><h4 id="没有listen，为什么还能建立连接"><a href="#没有listen，为什么还能建立连接" class="headerlink" title="没有listen，为什么还能建立连接"></a>没有listen，为什么还能建立连接</h4><p>那既然没有<code>accept</code>方法能建立连接，那是不是没有<code>listen</code>方法，也能建立连接？是的，之前写的一篇文章提到过客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有listen，就能建立连接。</strong></p><p>当时文章最后也留了个疑问，<strong>没有listen，为什么还能建立连接？</strong></p><p>我们知道执行<code>listen</code>方法时，会创建半连接队列和全连接队列。</p><p>三次握手的过程中会在这两个队列中暂存连接信息。</p><p>所以形成连接，前提是你得<strong>有个地方存放着</strong>，方便握手的时候能根据IP端口等信息找到socket信息。</p><p><strong>那么客户端会有半连接队列吗？</strong></p><p><strong>显然没有</strong>，因为客户端没有执行<code>listen</code>，因为半连接队列和全连接队列都是在执行<code>listen</code>方法时，内核自动创建的。</p><p>但内核还有个<strong>全局hash表</strong>，可以用于存放<code>sock</code>连接的信息。这个全局<code>hash</code>表其实还细分为<code>ehash，bhash和listen_hash</code>等，但因为过于细节，大家理解成有一个<strong>全局hash</strong>就够了，</p><p>在TCP自连接的情况中，客户端在<code>connect</code>方法时，最后会将自己的连接信息放入到这个<strong>全局hash表</strong>中，然后将信息发出，消息在经过回环地址重新回到TCP传输层的时候，就会根据IP端口信息，再一次从这个<strong>全局hash</strong>中取出信息。于是握手包一来一回，最后成功建立连接。</p><p>TCP同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>每一个</strong><code>socket</code>执行<code>listen</code>时，内核都会自动创建一个半连接队列和全连接队列。</li><li>第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。</li><li><code>accept方法</code>只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong>。</li><li>出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了<strong>哈希表</strong>，而全连接队列本质是链表。</li><li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li><li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li><li>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 协议 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang字符串底层原理</title>
      <link href="/2021/12/04/zi-fu-chuan-di-ceng-yuan-li/"/>
      <url>/2021/12/04/zi-fu-chuan-di-ceng-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>string 是 Go 语言的基础类型，在实际项目中针对字符串的各种操作使用频率也较高。本文就介绍一下在使用 string 时容易犯的一些错误以及如何避免。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>01 字符串的一些基本概念</strong></p><p>首先我们看下字符串的基本的数据结构：</p><pre class="line-numbers language-none"><code class="language-none">type stringStruct struct {    str unsafe.Pointer    len int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由字符串的数据结构可知，字符串只包含两个成员：</p><ul><li>stringStruct.str：一个指向底层数据的指针</li><li>stringStruct.len：字符串的字节长度，非字符个数。假设，我们定义了一个字符串 “中国”， 如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">a := "中国"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 Go 语言对源代码默认使用 utf-8 编码方式，utf-8 对” 中 “使用 3 个字节，对应的编码是（我们这里每个字节编码用 10 进制表示）：228 184 173。同样 “国” 的 utf-8 编码是：229 155 189。如下存储示意图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-0.jpg"></p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><strong>02 rune 是什么</strong></p><p>要想理解 rune，就会涉及到 unicode 字符集和字符编码的概念以及二者之间的关系。</p><p>unicode 字符集是对世界上多种语言字符的通用编码，也叫万国码。在 unicode 字符集中，每一个字符都有一个对应的编号，我们称这个编号为 code point，而 Go 中的<strong>rune 类型就代表一个字符的 code point</strong>。</p><p>字符集只是将每个字符给了一个唯一的编码而已。而要想在计算机中进行存储，则必须要<strong>通过特定的编码转换成对应的二进制</strong>才行。所以就有了像 ASCII、UTF-8、UTF-16 等这样的编码方式。而在 Go 中默认是使用 UTF-8 字符编码进行编码的。所有 unicode 字符集合和字符编码之间的关系如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-1.jpg"></p><p>我们知道，UTF-8 字符编码是一种变长字节的编码方式，用 1 到 4 个字节对字符进行编码，即最多 4 个字节，按位表示就是 32 位。所以，在 Go 的源码中，我们会看到对 rune 的定义是 int32 的别名：</p><pre class="line-numbers language-none"><code class="language-none">// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values.type rune = int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>好，有了以上基础知识，我们来看看在使用 string 过程中有哪些需要注意的地方。</p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><p><strong>03 strings.TrimRight 和 strings.TrimSuffix 的区别</strong></p><p><strong>strings.TrimRight 函数</strong></p><p>该函数的定义如下：</p><pre class="line-numbers language-none"><code class="language-none">func TrimRight(s, cutset string) string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数的功能是：从 s 字符串的末尾依次查找每一个字符，如果该字符包含在 cutset 中，则被移除，直到遇到第一个不在 cutset 中的字符。例如：</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(strings.TrimRight("123abbc", "bac"))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行示例代码，会将字符串末尾的 abbc 都去除掉，打印出”123”。执行逻辑如下：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-2.jpg"></p><p><strong>strings.TrimSuffix 函数</strong></p><p>该函数是将字符串指定的后缀字符串移除。定义如下：</p><pre class="line-numbers language-none"><code class="language-none">func TrimSuffix(s, suffix string) string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数的实现原理是，从字符串 s 中截取末尾的长度和 suffix 字符串长度相等的子字符串，然后和 suffix 字符串进行比较，如果相等，则将 s 字符串末尾的子字符串移除，如果不等，则返回原来的 s 字符串，该函数只截取一次。</p><p>我们通过如下示例来了解下其执行逻辑：</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(strings.TrimSuffix("123abab", "ab"))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们注意到，该字符串末尾有两个 ab，但最终只有末尾的一个 ab 被去除掉，保留” 123ab”。执行逻辑如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-3.jpg"></p><p>以上的原理同样适用于 strings.TrimLeft 和 strings.Prefix 的字符串操作函数。而 strings.Trim 函数则同时包含了 strings.TrimLeft 和 strings.TrimRight 的功能。</p><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><p><strong>04 字符串拼接性能问题</strong></p><p>拼接字符串是在项目中经常使用的一个场景。然而，拼接字符串时的性能问题会常常被忽略。性能问题其本质上就是要注意在拼接字符串时<strong>是否会频繁的产生内存分配以及数据拷贝的操作</strong>。</p><p>我们来看一个性能较低的拼接字符串的例子：</p><pre class="line-numbers language-none"><code class="language-none">func concat(ids []string) string {    s := ""    for _, id := range ids {        s += id    }    return s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码执行逻辑上不会有任何问题，但是在进行 s += id 进行拼接时，由于字符串是不可变的，所以每次都会分配新的内存空间，并将两个字符串的内容拷贝到新的空间去，然后再让 s 指向新的空间字符串。由于分配的内存次数多，当然就会对性能造成影响。如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-4.jpg"></p><p>那该如何提高拼接的性能呢？<strong>可以通过 strings.Builder 进行改进。strings.Builder 本质上是分配了一个字节切片，然后通过 append 的操作，将字符串的字节依次加入到该字节切片中。因为切片预分配空间的特性，可参考切片扩容，以有效的减少内存分配的次数，以提高性能。</strong></p><pre class="line-numbers language-none"><code class="language-none">func concat(ids []string) string {    sb := strings.Builder{}     for _, id := range ids {        _, _ = sb.WriteString(id)     }    return sb.String() }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看下 strings.Builder 的数据结构：</p><pre class="line-numbers language-none"><code class="language-none">type Builder struct {    addr *Builder // of receiver, to detect copies by value    buf  []byte}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由此可见，Builder 的结构体中有一个 buf [] byte，当执行 sb.WriteString(id) 方法时，实际上是调用了 append 的方法，将字符串的每个字节都存储到了字节切片 buf 中。如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-5.jpg"></p><p>上图中，第一次分配的内存空间是 8 个字节，这跟 Go 的内存管理有关系，网上有很多相关文章，这里不再详细讨论。</p><p>如果我们能提前知道要拼接的字符串的长度，我们还可以提前使用Builder 的 Grow 方法来预分配内存，这样在整个字符串拼接过程中只需要分配一次内存就好了，极大的提高了字符串拼接的性能。如下图所示及代码：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-6.jpg"></p><p>示例代码：</p><pre class="line-numbers language-none"><code class="language-none">func concat(ids []string) string {    total := 0    for i := 0; i &lt; len(ids); i++ {         total += len(ids[i])    }    sb := strings.Builder{}    sb.Grow(total)     for _, id := range ids {        _, _ = sb.WriteString(id)    }    return sb.String()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>strings.Builder 的使用场景一般是在循环中对字符串进行拼接</strong>，如果只是拼接两个或少数几个字符串的话，推荐使用 “+”操作符，例如: s := s1 + s2 + s3，该操作并非每个 + 操作符都计算一次长度，而是会首先<strong>计算三个字符串的总长度</strong>，然后分配对应的内存，再将三个字符串都拷贝到新申请的内存中去。</p><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><p><strong>05 无用字符串的转换</strong></p><p>我们在实际项目中往往会遇到这种场景：是选择字节切片还是字符串的场景。而大多数程序员会倾向于选择字符串。但是，很多 IO 的操作实际上是使用字节切片的。其实，bytes 包中也有很多和 strings 包中相同操作的函数。</p><p>我们看这样一个例子：实现一个 getBytes 函数，该函数接收一个 io.Reader 参数作为读取的数据源，然后调用 sanitize 函数，该函数的作用是去除字符串内容两端的空白字符。我们看下第一个实现：</p><pre class="line-numbers language-none"><code class="language-none">func getBytes(reader io.Reader) ([]byte, error) { b, err := io.ReadAll(reader) if err != nil { return nil, err } // Call sanitize return []byte(sanitize(string(b))), nil}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 sanitize 接收一个字符串类型的参数的实现：</p><pre class="line-numbers language-none"><code class="language-none">func sanitize(s string) string { return strings.TrimSpace(s)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这其实是将<strong>字节切片先转换成了字符串，然后又将字符串转换成字节切片</strong>返回了。其实，在 bytes 包中有同样的去除空格的函数<strong>bytes.TrimSpace</strong>，使用该函数就避免了对字节切片到字符串多余的转换。</p><pre class="line-numbers language-none"><code class="language-none">func sanitize(s []byte) []byte {    return bytes.TrimSpace(s)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><p><strong>06 子字符串操作及内存泄露</strong></p><p>字符串的切分也会跟切片的切分一样，可能会造成内存泄露。下面我们看一个例子：有一个 handleLog 的函数，接收一个 string 类型的参数 log，假设 log 的前 4 个字节存储的是 log 的 message 类型值，我们需要从 log 中提取出 message 类型，并存储到内存中。下面是相关代码：</p><pre class="line-numbers language-none"><code class="language-none">func (s store) handleLog(log string) error {    if len(log) &lt; 4 {        return errors.New("log is not correctly formatted")    }    message := log[:4]    s.store(message)    // Do something}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用 log[:4] 的方式提取出了 message，那么该实现有什么问题吗？我们假设参数 log 是一个包含成千上万个字符的字符串。当我们使用 log[:4] 操作时，实际上是返回了一个字节切片，该切片的长度是 4，而容量则是 log 字符串的整体长度。那么实际上我们存储的 message 不是包含 4 个字节的空间，而是整个 log 字符串长度的空间。所以就有可能会造成内存泄露。如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/zfcdc1-7.jpg"></p><p>那怎么避免呢？使用拷贝。将 uuid 提取后拷贝到一个字节切片中，这时该字节切片的长度和容量都是 36。如下：</p><pre class="line-numbers language-none"><code class="language-none">func (s store) handleLog(log string) error { if len(log) &lt; 36 { return errors.New("log is not correctly formatted") } uuid := string([]byte(log[:36]))  s.store(uuid) // Do something}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>07 小结</strong> </p><p>字符串是 Go 语言的一种基本类型，在 Go 语言中有自己的特性。字符串本质上是一个具有长度和指向底层数组的指针的结构体。在 Go 中，字符串是以 utf-8 编码的字节序列将每个字符的 unicode 编码存储在指针指向的数组中的，因此字符串是不可被修改的。在实际项目中，我们尤其要注意字符串和字节切片之间的转换以及在字符串拼接时的性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utf-8 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间的资源共享</title>
      <link href="/2021/11/27/xian-cheng-gong-xiang-liao-shi-me/"/>
      <url>/2021/11/27/xian-cheng-gong-xiang-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<p>进程和线程这两个话题是程序员绕不开的，操作系统提供的这两个抽象概念实在是太重要了。</p><p>关于进程和线程有一个<strong>极其经典</strong>的问题，那就是进程和线程的区别是什么？相信很多同学对答案似懂非懂。</p><p><strong>记住了不一定真懂</strong></p><p>关于这个问题有的同学可能已经“背得”滚瓜烂熟了：“进程是操作系统分配资源的单位，线程是调度的基本单位，<strong>线程之间共享进程资源</strong>”。</p><p>可是你真的理解了上面最后一句话吗？<strong>到底线程之间共享了哪些进程资源，共享资源意味着什么？共享资源这种机制是如何实现的？</strong>对此如果你没有答案的话，那么这意味着<strong>你几乎很难写出能正确工作的多线程程序</strong>，同时也意味着这篇文章就是为你准备的。</p><p><strong>逆向思考</strong></p><p>查理芒格经常说这样一句话：“反过来想，总是反过来想”，如果你对线程之间共享了哪些进程资源这个问题想不清楚的话那么也可以反过来思考，那就是<strong>有哪些资源是线程私有的</strong>。</p><p><strong>线程私有资源</strong></p><p>线程运行的本质其实就是函数的执行，函数的执行总会有一个源头，这个源头就是所谓的入口函数，CPU从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程。</p><p>既然线程运行的本质就是函数的执行，那么函数执行都有哪些信息呢？</p><p>函数运行时的信息保存在栈帧中，栈帧中保存了函数的返回值、调用其它函数的参数、该函数使用的局部变量以及该函数使用的寄存器信息，如图所示，假设函数A调用函数B：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-0.jpg"></p><p>此外，CPU执行指令的信息保存在一个叫做程序计数器的寄存器中，通过这个寄存器我们就知道接下来要执行哪一条指令。由于操作系统随时可以暂停线程的运行，因此我们保存以及恢复程序计数器中的值就能知道线程是从哪里暂停的以及该从哪里继续运行了。</p><p>由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-1.jpg"></p><p>同时函数运行时需要额外的寄存器来保存一些信息，像部分局部变量之类，这些寄存器也是线程私有的，<strong>一个线程不可能访问到另一个线程的这类寄存器信息</strong>。</p><p>从上面的讨论中我们知道，到目前为止，所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的。</p><p>以上这些信息有一个统一的名字，就是<strong>线程上下文</strong>，thread context。</p><p>我们也说过操作系统调度线程需要随时中断线程的运行并且需要线程被暂停后可以继续运行，操作系统之所以能实现这一点，依靠的就是线程上下文信息。</p><p>现在你应该知道哪些是线程私有的了吧。</p><p>除此之外，剩下的都是线程间共享资源。</p><p>那么剩下的还有什么呢？还有图中的这些。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-2.jpg"></p><p>这其实就是进程地址空间的样子，也就是说线程共享进程地址空间中除线程上下文信息中的所有内容，意思就是说线程可以<strong>直接读取</strong>这些内容。</p><p>接下来我们分别来看一下这些区域。</p><p><strong>代码区</strong></p><p>进程地址空间中的代码区，这里保存的是什么呢？从名字中有的同学可能已经猜到了，没错，这里保存的就是我们写的代码，<strong>更准确的是编译后的可执行机器指令</strong>。</p><p>那么这些机器指令又是从哪里来的呢？答案是从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-3.jpg"></p><p>线程之间共享代码区，<strong>这就意味着程序中的任何一个函数都可以放到线程中去执行，不存在某个函数只能被特定线程执行的情况</strong>。</p><p> <strong>数据区</strong></p><p>进程地址空间中的数据区，这里存放的就是所谓的全局变量。</p><p>什么是全局变量？所谓全局变量就是那些你定义在函数之外的变量，在C语言中就像这样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span> <span class="token comment">// 全局变量</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中字符c就是全局变量，存放在进程地址空间中的数据区。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-4.jpg"></p><p>在程序员运行期间，也就是run time，<strong>数据区中的全局变量有且仅有一个实例，所有的线程都可以访问到该全局变量</strong>。</p><p>值得注意的是，在C语言中还有一类特殊的“全局变量”，那就是用static关键词修饰过的变量，就像这样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意到，<strong>虽然变量a定义在函数内部，但变量a依然具有全局变量的特性</strong>，也就是说变量a放在了进程地址空间的数据区域，<strong>即使函数执行完后该变量依然存在</strong>，而普通的局部变量随着函数调用结束和函数栈帧一起被回收掉了，但这里的变量a不会被回收，因为其被放到了数据区。</p><p>这样的变量对每个线程来说也是可见的，也就是说每个线程都可以访问到该变量。</p><p><strong>堆区</strong></p><p>堆区是程序员比较熟悉的，我们在C/C++中用malloc或者new出来的数据就存放在这个区域，很显然，<strong>只要知道变量的地址，也就是指针，任何一个线程都可以访问指针指向的数据</strong>，因此堆区也是线程共享的属于进程的资源。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-5.jpg"></p><p><strong>栈区</strong></p><p>唉，等等！刚不是说栈区是线程私有资源吗，怎么这会儿又说起栈区了？</p><p>确实，从线程这个抽象的概念上来说，栈区是线程私有的，然而从实际的实现上看，<strong>栈区属于线程私有这一规则并没有严格遵守</strong>，这句话是什么意思？</p><p>通常来说，注意这里的用词是<strong>通常</strong>，通常来说栈区是线程私有，既然有通常就有不通常的时候。</p><p>不通常是因为不像进程地址空间之间的严格隔离，线程的栈区没有严格的隔离机制来保护，因此如果一个线程能拿到来自另一个线程栈帧上的指针，<strong>那么该线程就可以改变另一个线程的栈区</strong>，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-6.jpg"></p><p>这从某种程度上给了程序员极大的便利，但同时，这也会导致极其难以排查到的bug。</p><p>试想一下你的程序运行的好好的，结果某个时刻突然出问题，定位到出问题代码行后根本就排查不到原因，你当然是排查不到问题原因的，因为你的程序本来就没有任何问题，是别人的问题导致你的函数栈帧数据被写坏从而产生bug，这样的问题通常很难排查到原因，需要对整体的项目代码非常熟悉，常用的一些debug工具这时可能已经没有多大作用了。</p><p>说了这么多，那么同学可能会问，一个线程是怎样修改本属于其它线程的数据呢？</p><p>接下来我们用一个代码示例讲解一下。</p><p><strong>修改线程私有数据</strong></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>不要担心，以下代码足够简单：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> var<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>var<span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是什么意思呢？</p><p>首先我们在主线程的栈区定义了一个局部变量，也就是 int a= 1这行代码，现在我们已经知道了，局部变量a属于主线程私有数据，但是，接下来我们创建了另外一个线程。</p><p>在新创建的这个线程中，我们将变量a的地址以参数的形式传给了新创建的线程，然后我来看一下thread函数。</p><p>在新创建的线程中，我们获取到了变量a的指针，然后将其修改为了2，也就是这行代码，我们在新创建的线程中修改了本属于主线程的私有数据。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-7.jpg"></p><p>现在你应该看明白了吧，尽管栈区是线程的私有数据，但由于栈区没有添加任何保护机制，一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区。</p><p>就像我们上文说得到的，这给程序员带来了极大便利的同时也带来了无尽的麻烦，试想上面这段代码，如果确实是项目需要那么这样写代码无可厚非，但如果上述新创建线程是因bug修改了属于其它线程的私有数据的话，那么产生问题就很难定位了，<strong>因为bug可能距离问题暴露的这行代码已经很远了</strong>，这样的问题通常难以排查。</p><p><strong>动态链接库</strong></p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p>进程地址空间中除了以上讨论的这些实际上还有其它内容，还有什么呢？</p><p>这就要从可执行程序说起了。</p><p>什么是可执行程序呢？在Windows中就是我们熟悉的exe文件，在Linux世界中就是ELF文件，这些可以被操作系统直接运行的程序就是我们所说的可执行程序。</p><p>那么可执行程序是怎么来的呢？</p><p>有的同学可能会说，废话，不就是编译器生成的吗？</p><p>实际上这个答案只答对了一半。</p><p>假设我们的项目比较简单只有几个源码文件，编译器是怎么把这几个源代码文件转换为最终的一个可执行程序呢？</p><p>原来，编译器在将可执行程序翻译成机器指令后，接下来还有一个重要的步骤，这就是链接，链接完成后生成的才是可执行程序。</p><p>完成链接这一过程的就是链接器。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-8.jpg"></p><p>其中链接器可以有两种链接方式，这就是<strong>静态链接</strong>和<strong>动态链接</strong>。</p><p>静态链接的意思是说把所有的机器指令一股脑全部打包到可执行程序中，动态链接的意思是我们不把动态链接的部分打包到可执行程序，而是在可执行程序运行起来后去内存中找动态链接的那部分代码，这就是所谓的静态链接和动态链接。</p><p>动态链接一个显而易见的好处就是可执行程序的大小会很小，就像我们在Windows下看一个exe文件可能很小，<strong>那么该exe很可能是动态链接的方式生成的</strong>。</p><p>而动态链接的部分生成的库就是我们熟悉的动态链接库，在Windows下是以DLL结尾的文件，在Linux下是以so结尾的文件。</p><p>说了这么多，这和线程共享资源有什么关系呢？</p><p>原来如果一个程序是动态链接生成的，<strong>那么其地址空间中有一部分包含的就是动态链接库</strong>，否则程序就运行不起来了，这一部分的地址空间也是被所有线程所共享的。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-9.jpg"></p><p>也就是说进程中的所有线程都可以使用动态链接库中的代码。</p><p><strong>文件</strong></p><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><p>最后，如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-10.jpg"></p><p> <strong>One More Thing：TLS</strong></p><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><p>本文就这些了吗？</p><p>关于线程私有数据还有一项技术，那就是线程局部存储，Thread Local Storage，TLS。</p><p>这是什么意思呢？</p><p>其实从名字上也可以看出，所谓线程局部存储，是指存放在该区域中的变量有两个含义：</p><ul><li>存放在该区域中的变量是全局变量，所有线程都可以访问</li><li>虽然看上去所有线程访问的都是同一个变量，但该全局变量独属于一个线程，一个线程对此变量的修改对其他线程不可见。</li></ul><p>说了这么多还是没懂有没有？没关系，接下来看完这两段代码还不懂你来打我。</p><p>我们先来看第一段代码，不用担心，这段代码非常非常的简单：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> var<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>var<span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么样，这段代码足够简单吧，上述代码是用C++11写的，我来讲解下这段代码是什么意思。</p><ul><li>首先我们创建了一个全局变量a，初始值为1</li><li>其次我们创建了两个线程，每个线程对变量a加1</li><li>线程的join函数表示该线程运行完毕后才继续运行接下来的代码</li></ul><p>那么这段代码的运行起来会打印什么呢？</p><p>全局变量a的初始值为1，第一个线程加1后a变为2，因此会打印2；第二个线程再次加1后a变为3，因此会打印3，让我们来看一下运行结果：</p><pre class="line-numbers language-none"><code class="language-none">23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看来我们分析的没错，全局变量在两个线程分别加1后最终变为3。</p><p>接下来我们对变量a的定义稍作修改，其它代码不做改动：</p><pre class="line-numbers language-none"><code class="language-none">__thread int a = 1; // 线程局部存储<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们看到全局变量a前面加了一个__thread关键词用来修饰，也就是说我们告诉编译器把变量a放在线程局部存储中，那这会对程序带来哪些改变呢？</p><p>简单运行一下就知道了：</p><pre class="line-numbers language-none"><code class="language-none">22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>和你想的一样吗？有的同学可能会大吃一惊，为什么我们明明对变量a加了两次，但第二次运行为什么还是打印2而不是3呢？</p><p>想一想这是为什么。</p><p>原来，这就是线程局部存储的作用所在，线程t1对变量a的修改不会影响到线程t2，线程t1在将变量a加到1后变为2，但对于线程t2来说此时变量a依然是1，因此加1后依然是2。</p><p>因此，<strong>线程局部存储可以让你使用一个独属于线程的全局变量</strong>。也就是说，虽然该变量可以被所有线程访问，但该变量在每个线程中都有一个副本，一个线程对改变量的修改不会影响到其它线程。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/gcgx1-12.jpg"></p><p><strong>总结</strong></p><p>怎么样，没想到教科书上一句简单的“线程共享进程资源”背后竟然会有这么多的知识点吧，<strong>教科书上的知识看似容易，但，并不简单</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 共享资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程切换的区别</title>
      <link href="/2021/11/20/jin-cheng-xian-cheng-qie-huan-qu-bie/"/>
      <url>/2021/11/20/jin-cheng-xian-cheng-qie-huan-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>注意这个题目问的是进程<strong>切换</strong>与线程<strong>切换</strong>的区别，不是进程与线程的区别。当然这里的<strong>线程指的是同一个进程中的线程</strong>。</p><p>这个问题能很好的考察面试者对进程和线程的理解深度，有比较高的区分度。</p><p>要想正确回答这个问题，面试者需要理解虚拟内存。</p><h5 id="虚拟内存解放生产力"><a href="#虚拟内存解放生产力" class="headerlink" title="虚拟内存解放生产力"></a>虚拟内存解放生产力</h5><p>对于程序员来说，我们在编程时实际上是不怎么操心内存问题的，对于使用Java、Python、JavaScript等动态类型语言的程序员来说更是如此，自动内存回收机制的引入使得使用这类语言的程序员几乎完全不用关心内存问题；即使对于编译型语言C/C++来说，程序员需要关心的也仅仅是内存的申请和释放。</p><p>总的来说，作为程序员(无论使用什么类型的语言)我们根本就不关心数据以及程序被放在了<strong>物理内存的哪个位置上</strong>(设计实现操作系统的程序员除外)，我们可以简单的认为我们的程序<strong>独占内存</strong>，比如在32位系统下我们的进程占用的内存空间为4G；并且我们可以申请超过物理内存大小的空间，比如在只有256MB的系统上程序员可以申请1G大小的内存空间，这种假设极大的解放了程序员的生产力。</p><p>而这种假设实现的背后功臣就是虚拟内存。</p><h5 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h5><p>虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道<strong>最终进程的数据及代码必然要放到物理内存上</strong>，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的地址空间映射，也就是虚拟内存地址与物理内存地址的映射关系，那么操作系统是如何记住这种映射关系的呢，答案就是页表，页表中记录了虚拟内存地址到物理内存地址的映射关系。有了页表就可以将虚拟地址转换为物理内存地址了，这种机制就是虚拟内存。</p><p>每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。</p><p>现在我们就可以来回答这个面试题了。</p><h5 id="进程切换与线程切换的区别"><a href="#进程切换与线程切换的区别" class="headerlink" title="进程切换与线程切换的区别"></a>进程切换与线程切换的区别</h5><p>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p><p>举一个不太恰当的例子，线程切换就好比你从主卧走到次卧，反正主卧和次卧都在同一个房子中(虚拟地址空间)，因此你无需换鞋子、换衣服等等。但是进程切换就不一样了，进程切换就好比从你家到别人家，这是两个不同的房子(不同的虚拟地址空间)，出发时要换好衣服、鞋子等等，到别人家后还要再换鞋子等等。</p><p>因此我们可以形象的认为线程是处在同一个屋檐下的，这里的屋檐就是虚拟地址空间，因此线程间切换无需虚拟地址空间的切换；而进程则不同，两个不同进程位于不同的屋檐下，即进程位于不同的虚拟地址空间，因此进程切换涉及到虚拟地址空间的切换，这也是为什么进程切换要比线程切换慢的原因。</p><p>有的同学可能还是不太明白，为什么虚拟地址空间切换会比较耗时呢？</p><h5 id="为什么虚拟地址切换很慢"><a href="#为什么虚拟地址切换很慢" class="headerlink" title="为什么虚拟地址切换很慢"></a>为什么虚拟地址切换很慢</h5><p>现在我们已经知道了进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 tcp rst 标志位</title>
      <link href="/2021/11/14/tcp-rst/"/>
      <url>/2021/11/14/tcp-rst/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是RST"><a href="#什么是RST" class="headerlink" title="什么是RST"></a>什么是RST</h3><p>我们都知道TCP正常情况下断开连接是用四次挥手，那是<strong>正常时候</strong>的优雅做法。</p><p>但<strong>异常情况</strong>下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。</p><p><strong>RST</strong> 就是用于这种情况，一般用来<strong>异常地</strong>关闭一个连接。它是一个TCP包头中的<strong>标志位</strong>。</p><p><strong>正常情况下</strong>，不管是<strong>发出</strong>，还是<strong>收到</strong>置了这个标志位的数据包，相应的内存、端口等连接资源都会被释放。从效果上来看就是TCP连接被关闭了。</p><p>而接收到 RST的一方，一般会看到一个 <code>connection reset</code> 或  <code>connection refused</code> 的报错。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-1.jpg" alt="TCP报头RST位"></p><h3 id="怎么知道收到RST了？"><a href="#怎么知道收到RST了？" class="headerlink" title="怎么知道收到RST了？"></a>怎么知道收到RST了？</h3><p>我们知道<strong>内核</strong>跟<strong>应用层</strong>是分开的两层，网络通信功能在内核，我们的客户端或服务端属于应用层。应用层<strong>只能</strong>通过 <code>send/recv</code> 与内核交互，才能感知到内核是不是收到了<code>RST</code>。</p><p>当本端收到远端发来的<code>RST</code>后，<strong>内核</strong>已经认为此链接已经关闭。</p><p>此时如果本端<strong>应用层</strong>尝试去执行 <strong>读数据</strong>操作，比如<code>recv</code>，应用层就会收到 <strong>Connection reset by peer</strong> 的报错，意思是<strong>远端已经关闭连接</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/rst2.gif" alt="ResetByPeer"></p><p>如果本端<strong>应用层</strong>尝试去执行<strong>写数据</strong>操作，比如<code>send</code>，那么应用层就会收到 <strong>Broken pipe</strong> 的报错，意思是发送通道已经坏了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/rst3.gif" alt="BrokenPipe"></p><p>这两个是开发过程中很经常遇到的报错，感觉大家可以<strong>把这篇文章放进收藏夹吃灰</strong>了，等遇到这个问题了，再打开来擦擦灰，说不定对你会有帮助。</p><h3 id="出现RST的场景有哪些"><a href="#出现RST的场景有哪些" class="headerlink" title="出现RST的场景有哪些"></a>出现RST的场景有哪些</h3><p><strong>RST</strong>一般出现于异常情况，归类为 <strong>对端的端口不可用</strong> 和 <strong>socket提前关闭</strong>。</p><h4 id="端口不可用"><a href="#端口不可用" class="headerlink" title="端口不可用"></a>端口不可用</h4><p>端口不可用分为两种情况。要么是这个端口从来就没有”可用”过，比如根本就没监听<strong>（listen）</strong>过；要么就是曾经”可用”，但现在”不可用”了，比如服务<strong>突然崩</strong>了。</p><h5 id="端口未监听"><a href="#端口未监听" class="headerlink" title="端口未监听"></a>端口未监听</h5><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-4.jpg" alt="TCP连接未监听的端口"></p><p>服务端<code>listen</code> 方法会创建一个<code>sock</code>放入到全局的<code>哈希表</code>中。</p><p>此时客户端发起一个<code>connect</code>请求到服务端。服务端在收到数据包之后，第一时间会根据IP和端口从哈希表里去获取<code>sock</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-5.jpg" alt="全局hash表"></p><p>如果服务端执行过<code>listen</code>，就能从<code>全局哈希表</code>里拿到<code>sock</code>。</p><p>但如果服务端没有执行过<code>listen</code>，那<code>哈希表</code>里也就不会有对应的<code>sock</code>，结果当然是拿不到。此时，<strong>正常情况下</strong>服务端会发<code>RST</code>给客户端。</p><h6 id="端口未监听就一定会发RST吗？"><a href="#端口未监听就一定会发RST吗？" class="headerlink" title="端口未监听就一定会发RST吗？"></a>端口未监听就一定会发RST吗？</h6><p><strong>不一定</strong>。上面提到，发RST的前提是<strong>正常情况下</strong>，我们看下源码。</p><pre class="line-numbers language-none"><code class="language-none">// net/ipv4/tcp_ipv4.c  // 代码经过删减int tcp_v4_rcv(struct sk_buff *skb){    // 根据ip、端口等信息 获取sock。    sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);    if (!sk)        goto no_tcp_socket;no_tcp_socket:    // 检查数据包有没有出错    if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {        // 错误记录    } else {        // 发送RST        tcp_v4_send_reset(NULL, skb);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核在收到数据后会从物理层、数据链路层、网络层、传输层、应用层，一层一层往上传递。到传输层的时候，根据当前数据包的协议是<strong>TCP还是UDP</strong>走不一样的函数方法。可以简单认为，<strong>TCP</strong>数据包都会走到 <code>tcp_v4_rcv()</code>。这个方法会从<code>全局哈希表</code>里获取 <code>sock</code>，如果此时服务端没有<code>listen()</code>过 , 那肯定获取不了<code>sock</code>，会跳转到<code>no_tcp_socket</code>的逻辑。</p><p>注意这里会先走一个 <code>tcp_checksum_complete()</code>，目的是看看数据包的**校验和(Checksum)**是否合法。</p><blockquote><p><strong>校验和</strong>可以验证数据从端到端的传输中是否出现异常。由发送端计算，然后由接收端验证。计算范围覆盖数据包里的TCP首部和TCP数据。</p></blockquote><p>如果在发送端到接收端传输过程中，数据发生<strong>任何改动</strong>，比如被第三方篡改，那么接收方能检测到校验和有差错，此时TCP段会被直接丢弃。如果校验和没问题，那才会发RST。</p><p>所以，<strong>只有在数据包没问题的情况下，比如校验和没问题，才会发RST包给对端。</strong></p><h6 id="为什么数据包异常的情况下，不发RST？"><a href="#为什么数据包异常的情况下，不发RST？" class="headerlink" title="为什么数据包异常的情况下，不发RST？"></a>为什么数据包异常的情况下，不发RST？</h6><p>一个数据包连校验都不能通过，那这个包，<strong>多半有问题</strong>。</p><p>有可能是在发送的过程中被篡改了，又或者，可能只是一个<strong>胡乱伪造</strong>的数据包。</p><p><strong>五层网络，不管是哪一层</strong>，只要遇到了这种数据，<strong>推荐的做法都是默默扔掉</strong>，<strong>而不是</strong>去回复一个消息告诉对方数据有问题。</p><p>如果对方用的是TCP，是可靠传输协议，发现很久没有<code>ACK</code>响应，自己就会重传。</p><p>如果对方用的是UDP，说明发送端已经接受了“不可靠会丢包”的事实，那丢了就丢了。</p><p>因此，数据包异常的情况下，默默扔掉，不发<code>RST</code>，非常合理。</p><p>还是不能理解？那我<strong>再举个例子</strong>。</p><p>正常人喷你，他说话<strong>条理清晰，主谓宾分明</strong>。此时你喷回去，那你是个充满热情，正直，富有判断力的好人。</p><p>而此时一个憨憨也想喷你，但他<strong>思维混乱，连话都说不清楚，一直阿巴阿巴</strong>的，你虽然听不懂，但<strong>大受震撼</strong>，此时你会？</p><ul><li>A：跟他激情互喷</li><li>B：不跟他一般见识，就当没听过</li></ul><p>一般来说<strong>最优选择是B</strong>，毕竟你理他，他反而来劲。</p><p>这下，应该就懂了。</p><h5 id="程序启动了但是崩了"><a href="#程序启动了但是崩了" class="headerlink" title="程序启动了但是崩了"></a>程序启动了但是崩了</h5><p>端口不可用的场景里，除了端口未监听以外，还有可能是从前监听了，但服务端机器上做监听操作的<strong>应用程序突然崩了</strong>，此时客户端还像往常一样正常发送消息，服务器内核协议栈收到消息后，则会<strong>回一个RST</strong>。在开发过程中，<strong>这种情况是最常见的</strong>。</p><p>比如你的服务端应用程序里，弄了个<strong>空指针</strong>，或者<strong>数组越界</strong>啥的，程序立马就崩了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-8.jpg" alt="TCP监听了但崩了"></p><p>这种情况跟<strong>端口未监听</strong>本质上类似，在服务端的应用程序<strong>崩溃后</strong>，原来监听的端口资源就被释放了，从效果上来看，类似于处于<code>CLOSED</code>状态。</p><p>此时服务端又收到了客户端发来的消息，内核协议栈会根据<strong>IP端口</strong>，从全局哈希表里查找<code>sock</code>，结果当然是拿不到对应的<code>sock</code>数据，于是走了跟上面**”端口未监听”<strong>时一样的逻辑，回了个<code>RST</code>。客户端在收到RST后也</strong>释放了sock资源<strong>，从效果上来看，就是</strong>连接断了**。</p><h6 id="RST和502的关系"><a href="#RST和502的关系" class="headerlink" title="RST和502的关系"></a>RST和502的关系</h6><p>上面这张图，服务端程序崩溃后，如果客户端再有数据发送，会出现<code>RST</code>。但如果在客户端和服务端中间再加一个<code>nginx</code>，就像下图一样。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-9.jpg" alt="RST与502"></p><p><code>nginx</code>会作为客户端和服务端之间的”中间人角色”，负责<strong>转发</strong>请求和响应结果。但当服务端程序<strong>崩溃</strong>，比如出现<strong>野指针或者OOM</strong>的问题，那转发到服务器的请求，必然得不到响应，后端服务端还会返回一个<code>RST</code>给<code>nginx</code>。<code>nginx</code>在收到这个<code>RST</code>后会断开与服务端的连接，同时返回客户端一个<code>502</code>错误码。</p><p>所以，出现502问题，一般情况下都是因为后端程序崩了，基于这一点假设，去看看监控是不是发生了OOM或者日志是否有空指针等报错信息。</p><h4 id="socket提前关闭"><a href="#socket提前关闭" class="headerlink" title="socket提前关闭"></a>socket提前关闭</h4><p>这种情况分为<strong>本端</strong>提前关闭，和<strong>远端</strong>提前关闭。</p><h5 id="本端提前关闭"><a href="#本端提前关闭" class="headerlink" title="本端提前关闭"></a>本端提前关闭</h5><p>如果本端<code>socket</code>接收缓冲区<strong>还有数据未读</strong>，此时<strong>提前<code>close()</code> socket</strong>。那么本端会先把接收缓冲区的数据清空，然后给远端发一个RST。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/rst10.gif" alt="recvbuf非空"></p><h5 id="远端提前关闭"><a href="#远端提前关闭" class="headerlink" title="远端提前关闭"></a>远端提前关闭</h5><p>远端已经<code>close()</code>了<code>socket</code>，此时本端还尝试发数据给远端。那么远端就会回一个RST。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-11.jpg" alt="close触发TCP四次挥手"></p><p>大家知道，TCP是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>客户端执行<code>close()</code>， 正常情况下，会发出<strong>第一次</strong>挥手FIN，然后服务端回<strong>第二次</strong>挥手ACK。如果在<strong>第二次和第三次挥手之间</strong>，如果服务方还尝试传数据给客户端，那么客户端不仅不收这个消息，还会发一个RST消息到服务端。直接结束掉这次连接。</p><h3 id="对方没收到RST，会怎么样？"><a href="#对方没收到RST，会怎么样？" class="headerlink" title="对方没收到RST，会怎么样？"></a>对方没收到RST，会怎么样？</h3><p>我们知道TCP是可靠传输，意味着本端发一个数据，远端在收到这个数据后就会回一个<code>ACK</code>，意思是”我收到这个包了”。</p><p><strong>而RST，不需要ACK确认包</strong>。</p><p>因为<code>RST</code>本来就是设计来处理异常情况的，既然都已经在异常情况下了，还指望对方能正常回你一个<code>ACK</code>吗？<strong>可以幻想，不要妄想。</strong></p><p>但<strong>问题又来了</strong>，网络环境这么复杂，丢包也是分分钟的事情，既然RST包不需要ACK来确认，那万一对方就是没收到RST，会怎么样？</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-12.jpg" alt="RST丢失"></p><p>RST丢了，问题不大。比方说上图服务端，发了RST之后，服务端就认为连接不可用了。</p><p>如果客户端之前<strong>发送了数据</strong>，一直没等到这个数据的确认ACK，就会重发，重发的时候，自然就会触发一个新的RST包。</p><p>而如果客户端之前<strong>没有发数据</strong>，但服务端的RST丢了，TCP有个keepalive机制，会定期发送探活包，这种数据包到了服务端，也会重新触发一个RST。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-13.jpg" alt="RST丢失后keepalive"></p><h3 id="收到RST就一定会断开连接吗"><a href="#收到RST就一定会断开连接吗" class="headerlink" title="收到RST就一定会断开连接吗?"></a>收到RST就一定会断开连接吗?</h3><p>先说结论，<strong>不一定会断开</strong>。我们看下源码。</p><pre class="line-numbers language-none"><code class="language-none">// net/ipv4/tcp_input.cstatic bool tcp_validate_incoming(){    // 获取sock    struct tcp_sock *tp = tcp_sk(sk);    // step 1：先判断seq是否合法（是否在合法接收窗口范围内）    if (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) {        goto discard;    }    // step 2：执行收到 RST 后该干的事情    if (th-&gt;rst) {        if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt)            tcp_reset(sk);        else            tcp_send_challenge_ack(sk);        goto discard;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>收到RST包，第一步会通过<code>tcp_sequence</code>先看下这个seq是否合法，其实主要是看下这个seq是否在合法<strong>接收窗口</strong>范围内。<strong>如果不在范围内，这个RST包就会被丢弃。</strong></p><p>至于接收窗口是个啥，我们先看下面这个图。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-14.jpg" alt="接收窗口"></p><p>这里<strong>黄色的部分</strong>，就是指接收窗口，只要RST包的seq不在这个窗口范围内，那就会被丢弃。</p><h4 id="为什么要校验是否在窗口范围内"><a href="#为什么要校验是否在窗口范围内" class="headerlink" title="为什么要校验是否在窗口范围内"></a>为什么要校验是否在窗口范围内</h4><p>正常情况下客户端服务端双方可以通过RST来断开连接。假设不做seq校验，如果这时候有不怀好意的第三方介入，构造了一个RST包，且在TCP和IP等报头都填上客户端的信息，发到服务端，那么服务端就会断开这个连接。同理也可以伪造服务端的包发给客户端。这就叫<strong>RST攻击</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-15.jpg" alt="RST攻击"></p><p>受到RST攻击时，从现象上看，客户端老感觉服务端崩了，这非常影响用户体验。</p><p>如果这是个游戏，我相信多崩几次，第二天大家就不来玩了。</p><p>实际消息发送过程中，接收窗口是不断移动的，seq也是在飞快的变动中，此时第三方是<strong>比较难</strong>构造出合法seq的RST包的，那么通过这个seq校验，就可以拦下了很多不合法的消息。</p><h4 id="加了窗口校验就不能用RST攻击了吗"><a href="#加了窗口校验就不能用RST攻击了吗" class="headerlink" title="加了窗口校验就不能用RST攻击了吗"></a>加了窗口校验就不能用RST攻击了吗</h4><p><strong>不是，只是增加了攻击的成本。</strong>但如果想搞，还是可搞的。</p><p>以下是<strong>面向监狱编程</strong>的环节。</p><p>希望大家只<strong>了解原理</strong>就好了，<strong>不建议使用</strong>。</p><p>相信大家都不喜欢穿着蓝白条纹的衣服，拍<strong>纯狱风</strong>的照片。</p><p>从上面可以知道，不是每一个RST包都会导致连接重置的，要求是这个RST包的seq要在窗口范围内，所以，问题就变成了，<strong>我们怎么样才能构造出合法的seq</strong>。</p><h5 id="盲猜seq"><a href="#盲猜seq" class="headerlink" title="盲猜seq"></a>盲猜seq</h5><p>窗口数值seq本质上只是个uint32类型。</p><pre class="line-numbers language-none"><code class="language-none">struct tcp_skb_cb {    __u32       seq;        /* Starting sequence number */}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在这个范围内疯狂猜测seq数值，并构造对应的包，发到目的机器，虽然概率低，但是总是能被试出来，从而实现<strong>RST攻击</strong>。这种乱棍打死老师傅的方式，就是所谓的<strong>合法窗口盲打（blind in-window attacks）</strong>。</p><p>觉得这种方式比较<strong>笨</strong>？那有没有聪明点的方式，还真有，但是在这之前需要先看下面的这个问题。</p><h5 id="已连接状态下收到第一次握手包会怎么样？"><a href="#已连接状态下收到第一次握手包会怎么样？" class="headerlink" title="已连接状态下收到第一次握手包会怎么样？"></a>已连接状态下收到第一次握手包会怎么样？</h5><p>我们需要了解一个问题，比如服务端在已连接（<code>ESTABLISHED</code>）状态下，如果收到客户端发来的第一次握手包（<code>SYN</code>），会怎么样？</p><p>以前我以为<strong>服务单会认为客户端憨憨了，直接RST连接。</strong></p><p><strong>但实际，并不是</strong>。</p><pre class="line-numbers language-none"><code class="language-none">static bool tcp_validate_incoming(){    struct tcp_sock *tp = tcp_sk(sk);    /* 判断seq是否在合法窗口内 */    if (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) {        if (!th-&gt;rst) {            // 收到一个不在合法窗口内的SYN包            if (th-&gt;syn)                goto syn_challenge;        }    }    /*      * RFC 5691 4.2 : 发送 challenge ack     */    if (th-&gt;syn) {syn_challenge:        tcp_send_challenge_ack(sk);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当客户端发出一个不在合法窗口内的SYN包的时候，服务端会发一个带有正确的seq数据ACK包出来，这个ACK包叫 <code>challenge ack</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-16.jpg" alt="challenge ack抓包"></p><p>上图是抓包的结果，用<code>scapy</code>随便伪造一个<code>seq=5</code>的包发到服务端（<code>端口9090</code>），服务端回复一个带有正确seq值的<code>challenge ack</code>包给客户端（<code>端口8888</code>）。</p><h5 id="利用challenge-ack获取seq"><a href="#利用challenge-ack获取seq" class="headerlink" title="利用challenge ack获取seq"></a>利用challenge ack获取seq</h5><p>上面提到的<strong>这个challenge ack ，仿佛为盲猜seq的老哥们打开了一个新世界。</strong></p><p>在获得这个<code>challenge ack</code>后，攻击程序就可以以ack值为基础，在一定范围内设置seq，这样造成RST攻击的几率就大大增加了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/tcprst-17.jpg" alt="利用ChallengeACK的RST攻击"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>RST其实是TCP包头里的一个标志位，目的是为了在<strong>异常情况</strong>下关闭连接。</li><li>内核收到RST后，应用层只能通过调用读/写操作来感知，此时会对应获得 <strong>Connection reset by peer</strong> 和<strong>Broken pipe</strong> 报错。</li><li>发出RST后不需要得到对方的ACK确认包，因此RST丢失后对方不能立刻感知，但是通过下一次<strong>重传</strong>数据或keepalive<strong>心跳包</strong>可以导致RST重传。</li><li><strong>收到RST包，不一定会断开连接，seq不在合法窗口范围内的数据包会被默默丢弃。</strong>通过构造合法窗口范围内seq，可以造成RST攻击，<strong>这一点大家了解就好，千万别学！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 协议 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异地多活 架构设计</title>
      <link href="/2021/11/09/yi-di-duo-huo/"/>
      <url>/2021/11/09/yi-di-duo-huo/</url>
      
        <content type="html"><![CDATA[<h1 id="搞懂异地多活，看这篇就够了"><a href="#搞懂异地多活，看这篇就够了" class="headerlink" title="搞懂异地多活，看这篇就够了"></a>搞懂异地多活，看这篇就够了</h1><p><strong>异地多活到底是什么？为什么需要异地多活？它到底解决了什么问题？究竟是怎么解决的？</strong></p><p>这些疑问，想必是每个程序看到异地多活这个名词时，都想要搞明白的问题。</p><p><strong>这篇文章干货很多，希望你可以耐心读完。</strong></p><h1 id="01-系统可用性"><a href="#01-系统可用性" class="headerlink" title="01 系统可用性"></a>01 系统可用性</h1><p>要想理解异地多活，我们需要从架构设计的原则说起。</p><p>现如今，我们开发一个软件系统，对其要求越来越高，如果你了解一些「架构设计」的要求，就知道一个好的软件架构应该遵循以下 3 个原则：</p><ol><li>高性能</li><li>高可用</li><li>易扩展</li></ol><p>其中，高性能意味着系统拥有更大流量的处理能力，更低的响应延迟。例如 1 秒可处理 10W 并发请求，接口响应时间 5 ms 等等。</p><p>易扩展表示系统在迭代新功能时，能以最小的代价去扩展，系统遇到流量压力时，可以在不改动代码的前提下，去扩容系统。</p><p>而「高可用」这个概念，看起来很抽象，怎么理解它呢？通常用 2 个指标来衡量：</p><ul><li><strong>平均故障间隔 MTBF</strong>（Mean Time Between Failure）：表示两次故障的间隔时间，也就是系统「正常运行」的平均时间，这个时间越长，说明系统稳定性越高</li><li><strong>故障恢复时间 MTTR</strong>（Mean Time To Repair）：表示系统发生故障后「恢复的时间」，这个值越小，故障对用户的影响越小</li></ul><p>可用性与这两者的关系：</p><blockquote><p>可用性（Availability）= MTBF / (MTBF + MTTR) * 100%</p></blockquote><p>这个公式得出的结果是一个「比例」，通常我们会用「N 个 9」来描述一个系统的可用性。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-1.jpg"></p><p>从这张图你可以看到，要想达到 4 个 9 以上的可用性，平均每天故障时间必须控制在 10 秒以内。</p><p>也就是说，只有故障的时间「越短」，整个系统的可用性才会越高，每提升 1 个 9，都会对系统提出更高的要求。</p><p>我们都知道，系统发生故障其实是不可避免的，尤其是规模越大的系统，发生问题的概率也越大。这些故障一般体现在 3 个方面：</p><ol><li><strong>硬件故障</strong>：CPU、内存、磁盘、网卡、交换机、路由器</li><li><strong>软件问题</strong>：代码 Bug、版本迭代</li><li><strong>不可抗力</strong>：地震、水灾、火灾、战争</li></ol><p>这些风险随时都有可能发生。所以，在面对故障时，我们的系统能否以「<strong>最快</strong>」的速度恢复，就成为了可用性的关键。</p><p>可如何做到快速恢复呢？</p><p>这篇文章要讲的「异地多活」架构，就是为了解决这个问题，而提出的高效解决方案。</p><p>下面，我会从一个最简单的系统出发，带你一步步演化出一个支持「异地多活」的系统架构。</p><p>在这个过程中，你会看到一个系统会遇到哪些可用性问题，以及为什么架构要这样演进，从而理解异地多活架构的意义。</p><h1 id="02-单机架构"><a href="#02-单机架构" class="headerlink" title="02 单机架构"></a>02 单机架构</h1><p>我们从最简单的开始讲起。</p><p>假设你的业务处于起步阶段，体量非常小，那你的架构是这样的：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-2.jpg"></p><p>这个架构模型非常简单，客户端请求进来，业务应用读写数据库，返回结果，非常好理解。</p><p>但需要注意的是，这里的数据库是「单机」部署的，所以它有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，那这意味着所有数据就全部「丢失」了，这个损失是巨大的。</p><p>如何避免这个问题呢？我们很容易想到一个方案：<strong>备份</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-3.jpg"></p><p>你可以对数据做备份，把数据库文件「定期」cp 到另一台机器上，这样，即使原机器丢失数据，你依旧可以通过备份把数据「恢复」回来，以此保证数据安全。</p><p>这个方案实施起来虽然比较简单，但存在 2 个问题：</p><ol><li><strong>恢复需要时间</strong>：业务需先停机，再恢复数据，停机时间取决于恢复的速度，恢复期间服务「不可用」</li><li><strong>数据不完整</strong>：因为是定期备份，数据肯定不是「最新」的，数据完整程度取决于备份的周期</li></ol><p>很明显，你的数据库越大，意味故障恢复时间越久。那按照前面我们提到的「高可用」标准，这个方案可能连 1 个 9 都达不到，远远无法满足我们对可用性的要求。</p><p>那有什么更好的方案，既可以快速恢复业务？还能尽可能保证数据完整性呢？</p><p>这时你可以采用这个方案：<strong>主从副本</strong>。</p><h1 id="03-主从副本"><a href="#03-主从副本" class="headerlink" title="03 主从副本"></a>03 主从副本</h1><p>你可以在另一台机器上，再部署一个数据库实例，让这个新实例成为原实例的「副本」，让两者保持「实时同步」，就像这样：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-4.jpg"></p><p>我们一般把原实例叫作主库（master），新实例叫作从库（slave）。这个方案的优点在于：</p><ul><li><strong>数据完整性高</strong>：主从副本实时同步，数据「差异」很小</li><li><strong>抗故障能力提升</strong>：主库有任何异常，从库可随时「切换」为主库，继续提供服务</li><li><strong>读性能提升</strong>：业务应用可直接读从库，分担主库「压力」读压力</li></ul><p>这个方案不错，不仅大大提高了数据库的可用性，还提升了系统的读性能。</p><p>同样的思路，你的「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可，非常简单。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-5.jpg"></p><p>因为业务应用部署了多个，所以你现在还需要部署一个「接入层」，来做请求的「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-6.jpg"></p><p>从这个方案你可以看出，提升可用性的关键思路就是：<strong>冗余</strong>。</p><p>没错，担心一个实例故障，那就部署多个实例，担心一个机器宕机，那就部署多台机器。</p><p>到这里，你的架构基本已演变成主流方案了，之后开发新的业务应用，都可以按照这种模式去部署。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-7.jpg"></p><p>但这种方案还有什么风险吗？</p><h1 id="04-风险不可控"><a href="#04-风险不可控" class="headerlink" title="04 风险不可控"></a>04 风险不可控</h1><p>现在让我们把视角下放，把焦点放到具体的「部署细节」上来。</p><p>按照前面的分析，为了避免单点故障，你的应用虽然部署了多台机器，但这些机器的分布情况，我们并没有去深究。</p><p>而一个机房有很多服务器，这些服务器通常会分布在一个个「机柜」上，如果你使用的这些机器，刚好在一个机柜，还是存在风险。</p><p>如果恰好连接这个机柜的交换机 / 路由器发生故障，那么你的应用依旧有「不可用」的风险。</p><blockquote><p>虽然交换机 / 路由器也做了路线冗余，但不能保证一定不出问题。</p></blockquote><p>部署在一个机柜有风险，那把这些机器打散，分散到不同机柜上，是不是就没问题了？</p><p>这样确实会大大降低出问题的概率。但我们依旧不能掉以轻心，因为无论怎么分散，它们总归还是在一个相同的环境下：<strong>机房</strong>。</p><p>那继续追问，机房会不会发生故障呢？</p><p>一般来讲，建设一个机房的要求其实是很高的，地理位置、温湿度控制、备用电源等等，机房厂商会在各方面做好防护。但即使这样，我们每隔一段时间还会看到这样的新闻：</p><ul><li>2015 年 5 月 27 日，杭州市某地光纤被挖断，近 3 亿用户长达 5 小时无法访问支付宝</li><li>2021 年 7 月 13 日，B 站部分服务器机房发生故障，造成整站持续 3 个小时无法访问</li><li>2021 年 10 月 9 日，富途证券服务器机房发生电力闪断故障，造成用户 2 个小时无法登陆、交易</li><li>…</li></ul><p>可见，即使机房级别的防护已经做得足够好，但只要有「概率」出问题，那现实情况就有可能发生。虽然概率很小，但一旦真的发生，影响之大可见一斑。</p><p>看到这里你可能会想，机房出现问题的概率也太小了吧，工作了这么多年，也没让我碰上一次，有必要考虑得这么复杂吗？</p><p>但你有没有思考这样一个问题：<strong>不同体量的系统，它们各自关注的重点是什么？</strong></p><p>体量很小的系统，它会重点关注「用户」规模、增长，这个阶段获取用户是一切。等用户体量上来了，这个阶段会重点关注「性能」，优化接口响应时间、页面打开速度等等，这个阶段更多是关注用户体验。</p><p>等体量再大到一定规模后你会发现，「可用性」就变得尤为重要。像微信、支付宝这种全民级的应用，如果机房发生一次故障，那整个影响范围可以说是非常巨大的。</p><p>所以，再小概率的风险，我们在提高系统可用性时，也不能忽视。</p><p>分析了风险，再说回我们的架构。那到底该怎么应对机房级别的故障呢？</p><p>没错，还是<strong>冗余</strong>。</p><h1 id="05-同城灾备"><a href="#05-同城灾备" class="headerlink" title="05 同城灾备"></a>05 同城灾备</h1><p>想要抵御「机房」级别的风险，那应对方案就不能局限在一个机房内了。</p><p>现在，你需要做机房级别的冗余方案，也就是说，你需要再搭建一个机房，来部署你的服务。</p><p>简单起见，你可以在「同一个城市」再搭建一个机房，原机房我们叫作 A 机房，新机房叫 B 机房，这两个机房的网络用一条「专线」连通。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-8.jpg"></p><p>有了新机房，怎么把它用起来呢？这里还是要优先考虑「数据」风险。</p><p>为了避免 A 机房故障导致数据丢失，所以我们需要把数据在 B 机房也存一份。最简单的方案还是和前面提到的一样：<strong>备份</strong>。</p><p>A 机房的数据，定时在 B 机房做备份（拷贝数据文件），这样即使整个 A 机房遭到严重的损坏，B 机房的数据不会丢，通过备份可以把数据「恢复」回来，重启服务。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-9.jpg"></p><p>这种方案，我们称之为「<strong>冷备</strong>」。为什么叫冷备呢？因为 B 机房只做备份，不提供实时服务，它是冷的，只会在 A 机房故障时才会启用。</p><p>但备份的问题依旧和之前描述的一样：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证。</p><p>所以，我们还是需要用「主从副本」的方式，在 B 机房部署 A 机房的数据副本，架构就变成了这样：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-10.jpg"></p><p>这样，就算整个 A 机房挂掉，我们在 B 机房也有比较「完整」的数据。</p><p>数据是保住了，但这时你需要考虑另外一个问题：<strong>如果 A 机房真挂掉了，要想保证服务不中断，你还需要在 B 机房「紧急」做这些事情</strong>：</p><ol><li>B 机房所有从库提升为主库</li><li>在 B 机房部署应用，启动服务</li><li>部署接入层，配置转发规则</li><li>DNS 指向 B 机房，接入流量，业务恢复</li></ol><p>看到了么？A 机房故障后，B 机房需要做这么多工作，你的业务才能完全「恢复」过来。</p><p>你看，整个过程需要人为介入，且需花费大量时间来操作，恢复之前整个服务还是不可用的，这个方案还是不太爽，如果能做到故障后立即「切换」，那就好了。</p><p>因此，要想缩短业务恢复的时间，你必须把这些工作在 B 机房「<strong>提前</strong>」做好，也就是说，你需要在 B 机房提前部署好接入层、业务应用，等待随时切换。架构就变成了这样：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-11.jpg"></p><p>这样的话，A 机房整个挂掉，我们只需要做 2 件事即可：</p><ol><li>B 机房所有从库提升为主库</li><li>DNS 指向 B 机房，接入流量，业务恢复</li></ol><p>这样一来，恢复速度快了很多。</p><p>到这里你会发现，B 机房从最开始的「空空如也」，演变到现在，几乎是「<strong>镜像</strong>」了一份 A 机房的所有东西，从最上层的接入层，到中间的业务应用，到最下层的存储。</p><p>两个机房唯一的区别是，<strong>A 机房的存储都是主库，而 B 机房都是从库</strong>。</p><p>这种方案，我们把它叫做「<strong>热备</strong>」。</p><p>热的意思是指，B 机房处于「待命」状态，A 故障后 B 可以随时「接管」流量，继续提供服务。热备相比于冷备最大的优点是：<strong>随时可切换</strong>。</p><p>无论是冷备还是热备，因为它们都处于「备用」状态，所以我们把这两个方案统称为：<strong>同城灾备</strong>。</p><p>同城灾备的最大优势在于，我们再也不用担心「机房」级别的故障了，一个机房发生风险，我们只需把流量切换到另一个机房即可，可用性再次提高，是不是很爽？（后面还有更爽的）</p><h1 id="06-同城双活"><a href="#06-同城双活" class="headerlink" title="06 同城双活"></a>06 同城双活</h1><p>我们继续来看这个架构。</p><p>虽然我们有了应对机房故障的解决方案，但这里有个问题是我们不能忽视的：<strong>A 机房挂掉，全部流量切到 B 机房，B 机房能否真的如我们所愿，正常提供服务？</strong></p><p>这是个值得思考的问题。</p><p>这就好比有两支军队 A 和 B，A 军队历经沙场，作战经验丰富，而 B 军队只是后备军，除了有军人的基本素养之外，并没有实战经验，战斗经验基本为 0。</p><p>如果 A 军队丧失战斗能力，需要 B 军队立即顶上时，作为指挥官的你，肯定也会担心 B 军队能否真的担此重任吧？</p><p>我们的架构也是如此，此时的 B 机房虽然是随时「待命」状态，但 A 机房真的发生故障，我们要把全部流量切到 B 机房，其实是不敢百分百保证它可以「如期」工作的。</p><p>你想，我们在一个机房内部署服务，还总是发生各种各样的问题，例如：发布应用的版本不一致、系统资源不足、操作系统参数不一样等等。现在多部署一个机房，这些问题只会增多，不会减少。</p><p>另外，从「成本」的角度来看，我们新部署一个机房，需要购买服务器、内存、硬盘、带宽资源，花费成本也是非常高昂的，只让它当一个后备军，未免也太「大材小用」了！</p><p>因此，我们需要让 B 机房也接入流量，实时提供服务，这样做的好处，<strong>一是可以实时训练这支后备军，让它达到与 A 机房相同的作战水平，随时可切换，二是 B 机房接入流量后，可以分担 A 机房的流量压力</strong>。这才是把 B 机房资源优势，发挥最大化的最好方案！</p><p>那怎么让 B 机房也接入流量呢？很简单，就是把 B 机房的接入层 IP 地址，加入到 DNS 中，这样，B 机房从上层就可以有流量进来了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-12.jpg"></p><p>但这里有一个问题：别忘了，B 机房的存储，现在可都是 A 机房的「从库」，从库默认可都是「不可写」的，B 机房的写请求打到本机房存储上，肯定会报错，这还是不符合我们预期。怎么办？</p><p>这时，你就需要在「业务应用」层做改造了。</p><p>你的业务应用在操作数据库时，需要区分「<strong>读写分离</strong>」（一般用中间件实现），即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-13.jpg"></p><p>这会涉及到你用的所有存储，例如项目中用到了 MySQL、Redis、MongoDB 等等，操作这些数据库，都需要区分读写请求，所以这块需要一定的业务「改造」成本。</p><p>因为 A 机房的存储都是主库，所以我们把 A 机房叫做「<strong>主机房</strong>」，B 机房叫「<strong>从机房</strong>」。</p><p>两个机房部署在「同城」，物理距离比较近，而且两个机房用「专线」网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。</p><p>业务改造完成后，B 机房可以慢慢接入流量，从 10%、30%、50% 逐渐覆盖到 100%，你可以持续观察 B 机房的业务是否存在问题，有问题及时修复，逐渐让 B 机房的工作能力，达到和 A 机房相同水平。</p><p>现在，因为 B 机房实时接入了流量，此时如果 A 机房挂了，那我们就可以「大胆」地把 A 的流量，全部切换到 B 机房，完成快速切换！</p><p>到这里你可以看到，我们部署的 B 机房，在物理上虽然与 A 有一定距离，但整个系统从「逻辑」上来看，我们是把这两个机房看做一个「整体」来规划的，也就是说，相当于把 2 个机房当作 1 个机房来用。</p><p>这种架构方案，比前面的同城灾备更「进了一步」，B 机房实时接入了流量，还能应对随时的故障切换，这种方案我们把它叫做「<strong>同城双活</strong>」。</p><p>因为两个机房都能处理业务请求，这对我们系统的内部维护、改造、升级提供了更多的可实施空间（流量随时切换），现在，整个系统的弹性也变大了，是不是更爽了？</p><p>那这种架构有什么问题呢？</p><h1 id="07-两地三中心"><a href="#07-两地三中心" class="headerlink" title="07 两地三中心"></a>07 两地三中心</h1><p>还是回到风险上来说。</p><p>虽然我们把 2 个机房当做一个整体来规划，但这 2 个机房在物理层面上，还是处于「一个城市」内，如果是整个城市发生自然灾害，例如地震、水灾（河南水灾刚过去不久），那 2 个机房依旧存在「全局覆没」的风险。</p><p>真是防不胜防啊？怎么办？没办法，继续冗余。</p><p>但这次冗余机房，就不能部署在同一个城市了，你需要把它放到距离更远的地方，部署在「异地」。</p><blockquote><p>通常建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。</p></blockquote><p>假设之前的 A、B 机房在北京，那这次新部署的 C 机房可以放在上海。</p><p>按照前面的思路，把 C 机房用起来，最简单粗暴的方案还就是做「冷备」，即定时把 A、B 机房的数据，在 C 机房做备份，防止数据丢失。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-14.jpg"></p><p>这种方案，就是我们经常听到的「<strong>两地三中心</strong>」。</p><p><strong>两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备。</strong></p><p>这种架构方案，通常用在银行、金融、政企相关的项目中。它的问题还是前面所说的，启用灾备机房需要时间，而且启用后的服务，不确定能否如期工作。</p><p>所以，要想真正的抵御城市级别的故障，越来越多的互联网公司，开始实施「<strong>异地双活</strong>」。</p><h1 id="08-伪异地双活"><a href="#08-伪异地双活" class="headerlink" title="08 伪异地双活"></a>08 伪异地双活</h1><p>这里，我们还是分析 2 个机房的架构情况。我们不再把 A、B 机房部署在同一个城市，而是分开部署，例如 A 机房放在北京，B 机房放在上海。</p><p>前面我们讲了同城双活，那异地双活是不是直接「照搬」同城双活的模式去部署就可以了呢？</p><p>事情没你想的那么简单。</p><p>如果还是按照同城双活的架构来部署，那异地双活的架构就是这样的：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-15.jpg"></p><p>注意看，两个机房的网络是通过「<strong>跨城专线</strong>」连通的。</p><p>此时两个机房都接入流量，那上海机房的请求，可能要去读写北京机房的存储，这里存在一个很大的问题：<strong>网络延迟</strong>。</p><p>因为两个机房距离较远，受到物理距离的限制，现在，两地之间的网络延迟就变成了「<strong>不可忽视</strong>」的因素了。</p><p>北京到上海的距离大约 1300 公里，即使架设一条高速的「网络专线」，光纤以光速传输，一个来回也需要近 10ms 的延迟。</p><p>况且，网络线路之间还会经历各种路由器、交换机等网络设备，实际延迟可能会达到 30ms ~ 100ms，如果网络发生抖动，延迟甚至会达到 1 秒。</p><blockquote><p>不止是延迟，远距离的网络专线质量，是远远达不到机房内网络质量的，专线网络经常会发生延迟、丢包、甚至中断的情况。总之，不能过度信任和依赖「跨城专线」。</p></blockquote><p>你可能会问，这点延迟对业务影响很大吗？影响非常大！</p><p>试想，一个客户端请求打到上海机房，上海机房要去读写北京机房的存储，一次跨机房访问延迟就达到了 30ms，这大致是机房内网网络（0.5 ms）访问速度的 60 倍（30ms / 0.5ms），一次请求慢 60 倍，来回往返就要慢 100 倍以上。</p><p>而我们在 App 打开一个页面，可能会访问后端几十个 API，每次都跨机房访问，整个页面的响应延迟有可能就达到了<strong>秒级</strong>，这个性能简直惨不忍睹，难以接受。</p><p>看到了么，虽然我们只是简单的把机房部署在了「异地」，但「同城双活」的架构模型，在这里就不适用了，还是按照这种方式部署，这是「伪异地双活」！</p><p>那如何做到真正的异地双活呢？</p><h1 id="09-真正的异地双活"><a href="#09-真正的异地双活" class="headerlink" title="09 真正的异地双活"></a>09 真正的异地双活</h1><p>既然「跨机房」调用延迟是不容忽视的因素，那我们只能尽量避免跨机房「调用」，规避这个延迟问题。</p><p>也就是说，上海机房的应用，不能再「跨机房」去读写北京机房的存储，只允许读写上海本地的存储，实现「就近访问」，这样才能避免延迟问题。</p><p>还是之前提到的问题：上海机房存储都是从库，不允许写入啊，除非我们只允许上海机房接入「读流量」，不接收「写流量」，否则无法满足不再跨机房的要求。</p><p>很显然，只让上海机房接收读流量的方案不现实，因为很少有项目是只有读流量，没有写流量的。所以这种方案还是不行，这怎么办？</p><p>此时，你就必须在「<strong>存储层</strong>」做改造了。</p><p>要想上海机房读写本机房的存储，那上海机房的存储不能再是北京机房的从库，而是也要变为「主库」。</p><p>你没看错，两个机房的存储必须都是「<strong>主库</strong>」，而且两个机房的数据还要「<strong>互相同步</strong>」数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。</p><p>因为只有两个机房都拥有「全量数据」，才能支持任意切换机房，持续提供服务。</p><p>怎么实现这种「双主」架构呢？它们之间如何互相同步数据？</p><p>如果你对 MySQL 有所了解，MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「<strong>数据同步中间件</strong>」来实现双向同步的功能。</p><p>此外，除了数据库这种有状态的软件之外，你的项目通常还会使用到消息队列，例如 RabbitMQ、Kafka，这些也是有状态的服务，所以它们也需要开发双向同步的中间件，支持任意机房写入数据，同步至另一个机房。</p><p>看到了么，这一下子复杂度就上来了，单单针对每个数据库、队列开发同步中间件，就需要投入很大精力了。</p><blockquote><p>业界也开源出了很多数据同步中间件，例如阿里的 Canal、RedisShake、MongoShake，可分别在两个机房同步 MySQL、Redis、MongoDB 数据。</p><p>很多有能力的公司，也会采用自研同步中间件的方式来做，例如饿了么、携程、美团都开发了自己的同步中间件。</p><p>我也有幸参与设计开发了 MySQL、Redis/Codis、MongoDB 的同步中间件，有时间写一篇文章详细聊聊实现细节，欢迎持续关注。:)</p></blockquote><p>现在，整个架构就变成了这样：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-16.jpg"></p><p>注意看，两个机房的存储层都互相同步数据的。有了数据同步中间件，就可以达到这样的效果：</p><ul><li>北京机房写入 X = 1</li><li>上海机房写入 Y = 2</li><li>数据通过中间件双向同步</li><li>北京、上海机房都有 X = 1、Y = 2 的数据</li></ul><p>这里我们用中间件双向同步数据，就不用再担心专线问题，专线出问题，我们的中间件可以自动重试，直到成功，达到数据最终一致。</p><p>但这里还会遇到一个问题，两个机房都可以写，操作的不是同一条数据那还好，如果修改的是同一条的数据，发生冲突怎么办？</p><ul><li>用户短时间内发了 2 个修改请求，都是修改同一条数据</li><li>一个请求落在北京机房，修改 X = 1（还未同步到上海机房）</li><li>另一个请求落在上海机房，修改 X = 2（还未同步到北京机房）</li><li>两个机房以哪个为准？</li></ul><p>也就是说，在很短的时间内，同一个用户修改同一条数据，两个机房无法确认谁先谁后，数据发生「冲突」。</p><p>这是一个很严重的问题，系统发生故障并不可怕，可怕的是数据发生「错误」，因为修正数据的成本太高了。我们一定要避免这种情况的发生。解决这个问题，有 2 个方案。</p><p><strong>第一个方案</strong>，数据同步中间件要有自动「合并」数据、解决「冲突」的能力。</p><p>这个方案实现起来比较复杂，要想合并数据，就必须要区分出「先后」顺序。我们很容易想到的方案，就是以「时间」为标尺，以「后到达」的请求为准。</p><p>但这种方案需要两个机房的「时钟」严格保持一致才行，否则很容易出现问题。例如：</p><ul><li>第 1 个请求落到北京机房，北京机房时钟是 10:01，修改 X = 1</li><li>第 2 个请求落到上海机房，上海机房时钟是 10:00，修改 X = 2</li></ul><p>因为北京机房的时间「更晚」，那最终结果就会是 X = 1。但这里其实应该以第 2 个请求为准，X = 2 才对。</p><p>可见，完全「依赖」时钟的冲突解决方案，不太严谨。</p><p>所以，通常会采用<strong>第二种方案</strong>，从「<strong>源头</strong>」就避免数据冲突的发生。</p><h1 id="10-如何实施异地双活"><a href="#10-如何实施异地双活" class="headerlink" title="10 如何实施异地双活"></a>10 如何实施异地双活</h1><p>既然自动合并数据的方案实现成本高，那我们就要想，能否从源头就「避免」数据冲突呢？</p><p>这个思路非常棒！</p><p>从源头避免数据冲突的思路是：<strong>在最上层接入流量时，就不要让冲突的情况发生。</strong></p><p>具体来讲就是，要在最上层就把用户「区分」开，部分用户请求固定打到北京机房，其它用户请求固定打到上海 机房，进入某个机房的用户请求，之后的所有业务操作，都在这一个机房内完成，从根源上避免「跨机房」。</p><p>所以这时，你需要在接入层之上，再部署一个「路由层」（通常部署在云服务器上），自己可以配置路由规则，把用户「分流」到不同的机房内。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-17.jpg"></p><p>但这个路由规则，具体怎么定呢？有很多种实现方式，最常见的我总结了 3 类：</p><ol><li>按业务类型分片</li><li>直接哈希分片</li><li>按地理位置分片</li></ol><p><strong>1、按业务类型分片</strong></p><p>这种方案是指，按应用的「业务类型」来划分。</p><p>举例：假设我们一共有 4 个应用，北京和上海机房都部署这些应用。但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。</p><p>这样一来，应用 1、2 的所有业务请求，只读写北京机房存储，应用 3、4 的所有请求，只会读写上海机房存储。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-18.jpg"></p><p>这样按业务类型分片，也可以避免同一个用户修改同一条数据。</p><blockquote><p>这里按业务类型在不同机房接入流量，还需要考虑多个应用之间的依赖关系，要尽可能的把完成「相关」业务的应用部署在同一个机房，避免跨机房调用。</p><p>例如，订单、支付服务有依赖关系，会产生互相调用，那这 2 个服务在 A 机房接入流量。社区、发帖服务有依赖关系，那这 2 个服务在 B 机房接入流量。</p></blockquote><p><strong>2、直接哈希分片</strong></p><p>这种方案就是，最上层的路由层，会根据用户 ID 计算「哈希」取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。</p><p>举例：一共 200 个用户，根据用户 ID 计算哈希值，然后根据路由规则，把用户 1 - 100 路由到北京机房，101 - 200 用户路由到上海机房，这样，就避免了同一个用户修改同一条数据的情况发生。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-19.jpg"></p><p><strong>3、按地理位置分片</strong></p><p>这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。</p><p>拿外卖服务举例，你要点外卖肯定是「就近」点餐，整个业务范围相关的有商家、用户、骑手，它们都是在相同的地理位置内的。</p><p>针对这种特征，就可以在最上层，按用户的「地理位置」来做分片，分散到不同的机房。</p><p>举例：北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-20.jpg"></p><blockquote><p>提醒：这 3 种常见的分片规则，第一次看不太好理解，建议配合图多理解几遍。搞懂这 3 个分片规则，你才能真正明白怎么做异地多活。</p></blockquote><p>总之，分片的核心思路在于，<strong>让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问。</strong></p><p>阿里在实施这种方案时，给它起了个名字，叫做「<strong>单元化</strong>」。</p><blockquote><p>当然，最上层的路由层把用户分片后，理论来说同一个用户只会落在同一个机房内，但不排除程序 Bug 导致用户会在两个机房「漂移」。</p><p>安全起见，每个机房在写存储时，还需要有一套机制，能够检测「数据归属」，应用层操作存储时，需要通过中间件来做「兜底」，避免不该写本机房的情况发生。（篇幅限制，这里不展开讲，理解思路即可）</p></blockquote><p>现在，两个机房就可以都接收「读写」流量（做好分片的请求），底层存储保持「双向」同步，两个机房都拥有全量数据，当任意机房故障时，另一个机房就可以「接管」全部流量，实现快速切换，简直不要太爽。</p><p>不仅如此，因为机房部署在异地，我们还可以更细化地「优化」路由规则，让用户访问就近的机房，这样整个系统的性能也会大大提升。</p><blockquote><p>这里还有一种情况，是无法做数据分片的：<strong>全局数据</strong>。例如系统配置、商品库存这类需要强一致的数据，这类服务依旧只能采用写主机房，读从机房的方案，不做双活。</p><p>双活的重点，是要优先保证「核心」业务先实现双活，并不是「全部」业务实现双活。</p></blockquote><p>至此，我们才算实现了真正的「<strong>异地双活</strong>」！</p><blockquote><p>到这里你可以看出，完成这样一套架构，需要投入的成本是巨大的。</p><p>路由规则、路由转发、数据同步中间件、数据校验兜底策略，不仅需要开发强大的中间件，同时还要业务配合改造（业务边界划分、依赖拆分）等一些列工作，没有足够的人力物力，这套架构很难实施。</p></blockquote><h1 id="11-异地多活"><a href="#11-异地多活" class="headerlink" title="11 异地多活"></a>11 异地多活</h1><p>理解了异地双活，那「异地多活」顾名思义，就是在异地双活的基础上，部署多个机房即可。架构变成了这样：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-21.jpg"></p><p>这些服务按照「单元化」的部署方式，可以让每个机房部署在任意地区，随时扩展新机房，你只需要在最上层定义好分片规则就好了。</p><p>但这里还有一个小问题，随着扩展的机房越来越多，当一个机房写入数据后，需要同步的机房也越来越多，这个实现复杂度会比较高。</p><p>所以业界又把这一架构又做了进一步优化，把「网状」架构升级为「星状」：</p><p><img src="https://image.fyxemmmm.cn/blog/images/dir1/yddh-22.jpg"></p><p>这种方案必须设立一个「中心机房」，任意机房写入数据后，都只同步到中心机房，再由中心机房同步至其它机房。</p><p>这样做的好处是，一个机房写入数据，只需要同步数据到中心机房即可，不需要再关心一共部署了多少个机房，实现复杂度大大「简化」。</p><p>但与此同时，这个中心机房的「稳定性」要求会比较高。不过也还好，即使中心机房发生故障，我们也可以把任意一个机房，提升为中心机房，继续按照之前的架构提供服务。</p><p>至此，我们的系统彻底实现了「<strong>异地多活</strong>」！</p><p>多活的优势在于，<strong>可以任意扩展机房「就近」部署。任意机房发生故障，可以完成快速「切换」</strong>，大大提高了系统的可用性。</p><p>同时，我们也再也不用担心系统规模的增长，因为这套架构具有极强的「<strong>扩展能力</strong>」。</p><p>怎么样？我们从一个最简单的应用，一路优化下来，到最终的架构方案，有没有帮你彻底理解异地多活呢？</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，总结一下这篇文章的重点。</p><p>1、一个好的软件架构，应该遵循高性能、高可用、易扩展 3 大原则，其中「高可用」在系统规模变得越来越大时，变得尤为重要</p><p>2、系统发生故障并不可怕，能以「最快」的速度恢复，才是高可用追求的目标，异地多活是实现高可用的有效手段</p><p>3、提升高可用的核心是「冗余」，备份、主从副本、同城灾备、同城双活、两地三中心、异地双活，异地多活都是在做冗余</p><p>4、同城灾备分为「冷备」和「热备」，冷备只备份数据，不提供服务，热备实时同步数据，并做好随时切换的准备</p><p>5、同城双活比灾备的优势在于，两个机房都可以接入「读写」流量，提高可用性的同时，还提升了系统性能。虽然物理上是两个机房，但「逻辑」上还是当做一个机房来用</p><p>6、两地三中心是在同城双活的基础上，额外部署一个异地机房做「灾备」，用来抵御「城市」级别的灾害，但启用灾备机房需要时间</p><p>7、异地双活才是抵御「城市」级别灾害的更好方案，两个机房同时提供服务，故障随时可切换，可用性高。但实现也最复杂，理解了异地双活，才能彻底理解异地多活</p><p>8、异地多活是在异地双活的基础上，任意扩展多个机房，不仅又提高了可用性，还能应对更大规模的流量的压力，扩展性最强，是实现高可用的最终方案</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 异地多活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 性能优化</title>
      <link href="/2021/11/01/redis-xing-neng-wen-ti-fen-xi/"/>
      <url>/2021/11/01/redis-xing-neng-wen-ti-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis慢的原因-amp-redis性能优化"><a href="#Redis慢的原因-amp-redis性能优化" class="headerlink" title="Redis慢的原因 &amp; redis性能优化"></a>Redis慢的原因 &amp; redis性能优化</h1><p>Redis 作为优秀的内存数据库，其拥有非常高的性能，单个实例的 OPS 能够达到 10W 左右。但也正因此如此，当我们在使用 Redis 时，如果发现操作延迟变大的情况，就会与我们的预期不符。</p><p>你也许或多或少地，也遇到过以下这些场景：</p><ul><li>在 Redis 上执行同样的命令，为什么有时响应很快，有时却很慢？</li><li>为什么 Redis 执行 SET、DEL 命令耗时也很久？</li><li>为什么我的 Redis 突然慢了一波，之后又恢复正常了？</li><li>为什么我的 Redis 稳定运行了很久，突然从某个时间点开始变慢了？</li><li>…</li></ul><p>如果你并不清楚 Redis 内部的实现原理，那么在排查这种延迟问题时就会一头雾水。</p><p>那我们就一起探究一下具体的细节吧！</p><h1 id="Redis真的变慢了吗？"><a href="#Redis真的变慢了吗？" class="headerlink" title="Redis真的变慢了吗？"></a>Redis真的变慢了吗？</h1><p>首先，在开始之前，你需要弄清楚 Redis 是否真的变慢了？</p><p>如果你发现你的业务服务 API 响应延迟变长，首先你需要先排查服务内部，究竟是哪个环节拖慢了整个服务。</p><p>比较高效的做法是，在服务内部集成<strong>链路追踪</strong>，也就是在服务访问外部依赖的出入口，记录下每次请求外部依赖的响应延时。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-1.jpg"></p><p>如果你发现确实是操作 Redis 的这条链路耗时变长了，那么此刻你需要把焦点关注在业务服务到 Redis 这条链路上。</p><p>从你的业务服务到 Redis 这条链路变慢的原因可能也有 2 个：</p><ol><li>业务服务器到 Redis 服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况</li><li>Redis 本身存在问题，需要进一步排查是什么原因导致 Redis 变慢</li></ol><p>通常来说，第一种情况发生的概率比较小，如果是服务器之间网络存在问题，那部署在这台业务服务器上的所有服务都会发生网络延迟的情况，此时你需要联系网络运维同事，让其协助解决网络问题。</p><p>我们这篇文章，重点关注的是第二种情况。</p><p>也就是从 Redis 角度来排查，是否存在导致变慢的场景，以及都有哪些因素会导致 Redis 的延迟增加，然后针对性地进行优化。</p><p>排除网络原因，如何确认你的 Redis 是否真的变慢了？</p><p>首先，你需要对 Redis 进行基准性能测试，了解你的 Redis 在生产环境服务器上的基准性能。</p><p>什么是基准性能？</p><p>简单来讲，基准性能就是指 Redis 在一台负载正常的机器上，其最大的响应延迟和平均响应延迟分别是怎样的？</p><p>为什么要测试基准性能？我参考别人提供的响应延迟，判断自己的 Redis 是否变慢不行吗？</p><p>答案是否定的。</p><p>因为 Redis 在不同的软硬件环境下，它的性能是各不相同的。</p><p>例如，我的机器配置比较低，当延迟为 2ms 时，我就认为 Redis 变慢了，但是如果你的硬件配置比较高，那么在你的运行环境下，可能延迟是 0.5ms 时就可以认为 Redis 变慢了。</p><p>所以，你只有了解了你的 Redis 在生产环境服务器上的基准性能，才能进一步评估，当其延迟达到什么程度时，才认为 Redis 确实变慢了。</p><p>具体如何做？</p><p>为了避免业务服务器到 Redis 服务器之间的网络延迟，你需要直接在 Redis 服务器上测试实例的响应延迟情况。执行以下命令，就可以测试出这个实例 60 秒内的最大响应延迟：</p><pre class="line-numbers language-none"><code class="language-none">$ redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60Max latency so far: 1 microseconds.Max latency so far: 15 microseconds.Max latency so far: 17 microseconds.Max latency so far: 18 microseconds.Max latency so far: 31 microseconds.Max latency so far: 32 microseconds.Max latency so far: 59 microseconds.Max latency so far: 72 microseconds.1428669267 total runs (avg latency: 0.0420 microseconds / 42.00 nanoseconds per run).Worst run took 1429x longer than the average latency.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果可以看到，这 60 秒内的最大响应延迟为 72 微秒（0.072毫秒）。</p><p>你还可以使用以下命令，查看一段时间内 Redis 的最小、最大、平均访问延迟：</p><pre class="line-numbers language-none"><code class="language-none">$ redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1min: 0, max: 1, avg: 0.13 (100 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.12 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.13 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.10 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.13 (98 samples) -- 1.00 seconds rangemin: 0, max: 1, avg: 0.08 (99 samples) -- 1.01 seconds range...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出结果是，每间隔 1 秒，采样 Redis 的平均操作耗时，其结果分布在 0.08 ~ 0.13 毫秒之间。</p><p>了解了基准性能测试方法，那么你就可以按照以下几步，来判断你的 Redis 是否真的变慢了：</p><ol><li>在相同配置的服务器上，测试一个正常 Redis 实例的基准性能</li><li>找到你认为可能变慢的 Redis 实例，测试这个实例的基准性能</li><li>如果你观察到，这个实例的运行延迟是正常 Redis 基准性能的 2 倍以上，即可认为这个 Redis 实例确实变慢了</li></ol><p>确认是 Redis 变慢了，那如何排查是哪里发生了问题呢？</p><p>下面跟着我的思路，我们从易到难，一步步来分析可能导致 Redis 变慢的因素。</p><h1 id="使用复杂度过高的命令"><a href="#使用复杂度过高的命令" class="headerlink" title="使用复杂度过高的命令"></a>使用复杂度过高的命令</h1><p>首先，第一步，你需要去查看一下 Redis 的慢日志（slowlog）。</p><p>Redis 提供了慢日志命令的统计功能，它记录了有哪些命令在执行时耗时比较久。</p><p>查看 Redis 慢日志之前，你需要设置慢日志的阈值。例如，设置慢日志的阈值为 5 毫秒，并且保留最近 500 条慢日志记录：</p><pre class="line-numbers language-none"><code class="language-none"># 命令执行耗时超过 5 毫秒，记录慢日志CONFIG SET slowlog-log-slower-than 5000# 只保留最近 500 条慢日志CONFIG SET slowlog-max-len 500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置完成之后，所有执行的命令如果操作耗时超过了 5 毫秒，都会被 Redis 记录下来。</p><p>此时，你可以执行以下命令，就可以查询到最近记录的慢日志：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; SLOWLOG get 51) 1) (integer) 32693       # 慢日志ID   2) (integer) 1593763337  # 执行时间戳   3) (integer) 5299        # 执行耗时(微秒)   4) 1) "LRANGE"           # 具体执行的命令和参数      2) "user_list:2000"      3) "0"      4) "-1"2) 1) (integer) 32692   2) (integer) 1593763337   3) (integer) 5044   4) 1) "GET"      2) "user_info:1000"...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过查看慢日志，我们就可以知道在什么时间点，执行了哪些命令比较耗时。</p><p>如果你的应用程序执行的 Redis 命令有以下特点，那么有可能会导致操作延迟变大：</p><ol><li>经常使用 O(N) 以上复杂度的命令，例如 SORT、SUNION、ZUNIONSTORE 聚合类命令</li><li>使用 O(N) 复杂度的命令，但 N 的值非常大</li></ol><p>第一种情况导致变慢的原因在于，Redis 在操作内存数据时，时间复杂度过高，要花费更多的 CPU 资源。</p><p>第二种情况导致变慢的原因在于，Redis 一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。</p><p>另外，我们还可以从资源使用率层面来分析，如果你的应用程序操作 Redis 的 OPS 不是很大，但 Redis 实例的 <strong>CPU 使用率却很高</strong>，那么很有可能是使用了复杂度过高的命令导致的。</p><p>除此之外，我们都知道，Redis 是单线程处理客户端请求的，如果你经常使用以上命令，那么当 Redis 处理客户端请求时，一旦前面某个命令发生耗时，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-2.jpg"></p><p>针对这种情况如何解决呢？</p><p>答案很简单，你可以使用以下方法优化你的业务：</p><ol><li>尽量不使用 O(N) 以上复杂度过高的命令，对于数据的聚合操作，放在客户端做</li><li>执行 O(N) 命令，保证 N 尽量的小（推荐 N &lt;= 300），每次获取尽量少的数据，让 Redis 可以及时处理返回</li></ol><h1 id="操作bigkey"><a href="#操作bigkey" class="headerlink" title="操作bigkey"></a>操作bigkey</h1><p>如果你查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET / DEL 这种简单命令出现在慢日志中，那么你就要怀疑你的实例否写入了 bigkey。</p><p>Redis 在写入数据时，需要为新的数据分配内存，相对应的，当从 Redis 中删除数据时，它会释放对应的内存空间。</p><p>如果一个 key 写入的 value 非常大，那么 Redis 在<strong>分配内存时就会比较耗时</strong>。同样的，当删除这个 key 时，<strong>释放内存也会比较耗时</strong>，这种类型的 key 我们一般称之为 bigkey。</p><p>此时，你需要检查你的业务代码，是否存在写入 bigkey 的情况。你需要评估写入一个 key 的数据大小，尽量避免一个 key 存入过大的数据。</p><p>如果已经写入了 bigkey，那有没有什么办法可以扫描出实例中 bigkey 的分布情况呢？</p><p>答案是可以的。</p><p>Redis 提供了扫描 bigkey 的命令，执行以下命令就可以扫描出，一个实例中 bigkey 的分布情况，输出结果是以类型维度展示的：</p><pre class="line-numbers language-none"><code class="language-none">$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01...-------- summary -------Sampled 829675 keys in the keyspace!Total key length in bytes is 10059825 (avg len 12.13)Biggest string found 'key:291880' has 10 bytesBiggest   list found 'mylist:004' has 40 itemsBiggest    set found 'myset:2386' has 38 membersBiggest   hash found 'myhash:3574' has 37 fieldsBiggest   zset found 'myzset:2704' has 42 members36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)787393 lists with 896540 items (94.90% of keys, avg size 1.14)1994 sets with 40052 members (00.24% of keys, avg size 20.09)1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)1985 zsets with 39750 members (00.24% of keys, avg size 20.03)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们可以很清晰地看到，每种数据类型所占用的最大内存 / 拥有最多元素的 key 是哪一个，以及每种数据类型在整个实例中的占比和平均大小 / 元素数量。</p><p>其实，使用这个命令的原理，就是 Redis 在内部执行了 SCAN 命令，遍历整个实例中所有的 key，然后针对 key 的类型，分别执行 STRLEN、LLEN、HLEN、SCARD、ZCARD 命令，来获取 String 类型的长度、容器类型（List、Hash、Set、ZSet）的元素个数。</p><p>这里我需要提醒你的是，当执行这个命令时，要注意 2 个问题：</p><ol><li>对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，最好控制一下扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒</li><li>扫描结果中，对于容器类型（List、Hash、Set、ZSet）的 key，只能扫描出元素最多的 key。但一个 key 的元素多，不一定表示占用内存也多，你还需要根据业务情况，进一步评估内存占用情况</li></ol><p>那针对 bigkey 导致延迟的问题，有什么好的解决方案呢？</p><p>这里有两点可以优化：</p><ol><li>业务应用尽量避免写入 bigkey</li><li>如果你使用的 Redis 是 4.0 以上版本，用 UNLINK 命令替代 DEL，此命令可以把释放 key 内存的操作，放到后台线程中去执行，从而降低对 Redis 的影响</li><li>如果你使用的 Redis 是 6.0 以上版本，可以开启 lazy-free 机制（lazyfree-lazy-user-del = yes），在执行 DEL 命令时，释放内存也会放到后台线程中执行</li></ol><p>但即便可以使用方案 2，我也不建议你在实例中存入 bigkey。</p><p>这是因为 bigkey 在很多场景下，依旧会产生性能问题。例如，bigkey 在分片集群模式下，对于数据的迁移也会有性能影响，以及我后面即将讲到的数据过期、数据淘汰、透明大页，都会受到 bigkey 的影响。</p><h1 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h1><p>如果你发现，平时在操作 Redis 时，并没有延迟很大的情况发生，但在某个时间点突然出现一波延时，其现象表现为：<strong>变慢的时间点很有规律，例如某个整点，或者每间隔多久就会发生一波延迟。</strong></p><p>如果是出现这种情况，那么你需要排查一下，业务代码中是否存在设置大量 key 集中过期的情况。</p><p>如果有大量的 key 在某个固定时间点集中过期，在这个时间点访问 Redis 时，就有可能导致延时变大。</p><p>为什么集中过期会导致 Redis 延迟变大？</p><p>这就需要我们了解 Redis 的过期策略是怎样的。</p><p>Redis 的过期数据采用被动过期 + 主动过期两种策略：</p><ol><li>被动过期：只有当访问某个 key 时，才判断这个 key 是否已过期，如果已过期，则从实例中删除</li><li>主动过期：Redis 内部维护了一个定时任务，默认每隔 100 毫秒（1秒10次）就会从全局的过期哈希表中随机取出 20 个 key，然后删除其中过期的 key，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒，才会退出循环</li></ol><p>注意，<strong>这个主动过期 key 的定时任务，是在 Redis 主线程中执行的</strong>。</p><p>也就是说如果在执行主动过期的过程中，出现了需要大量删除过期 key 的情况，那么此时应用程序在访问 Redis 时，必须要等待这个过期任务执行结束，Redis 才可以服务这个客户端请求。</p><p>此时就会出现，应用访问 Redis 延时变大。</p><p>如果此时需要过期删除的是一个 bigkey，那么这个耗时会更久。而且，<strong>这个操作延迟的命令并不会记录在慢日志中</strong>。</p><p>因为慢日志中<strong>只记录一个命令真正操作内存数据的耗时</strong>，而 Redis 主动删除过期 key 的逻辑，是在命令真正执行之前执行的。</p><p>所以，此时你会看到，慢日志中没有操作耗时的命令，但我们的应用程序却感知到了延迟变大，其实时间都花费在了删除过期 key 上，这种情况我们需要尤为注意。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-3.jpg"></p><p>那遇到这种情况，如何分析和排查？</p><p>此时，你需要检查你的业务代码，是否存在集中过期 key 的逻辑。</p><p>一般集中过期使用的是 expireat / pexpireat 命令，你需要在代码中搜索这个关键字。</p><p>排查代码后，如果确实存在集中过期 key 的逻辑存在，但这种逻辑又是业务所必须的，那此时如何优化，同时又不对 Redis 有性能影响呢？</p><p>一般有两种方案来规避这个问题：</p><ol><li>集中过期 key 增加一个随机过期时间，把集中过期的时间打散，降低 Redis 清理过期 key 的压力</li><li>如果你使用的 Redis 是 4.0 以上版本，可以开启 lazy-free 机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程</li></ol><p>第一种方案，在设置 key 的过期时间时，增加一个随机时间，伪代码可以这么写：</p><pre class="line-numbers language-none"><code class="language-none"># 在过期时间点之后的 5 分钟内随机过期掉redis.expireat(key, expire_time + random(300))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样一来，Redis 在处理过期时，不会因为集中删除过多的 key 导致压力过大，从而避免阻塞主线程。</p><p>第二种方案，Redis 4.0 以上版本，开启 lazy-free 机制：</p><pre class="line-numbers language-none"><code class="language-none"># 释放过期 key 的内存，放到后台线程执行lazyfree-lazy-expire yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，除了业务层面的优化和修改配置之外，你还可以通过运维手段及时发现这种情况。</p><p>运维层面，你需要把 Redis 的各项运行状态数据监控起来，在 Redis 上执行 INFO 命令就可以拿到这个实例所有的运行状态数据。</p><p>在这里我们需要重点关注 expired_keys 这一项，它代表整个实例到目前为止，累计删除过期 key 的数量。</p><p>你需要把这个指标监控起来，<strong>当这个指标在很短时间内出现了突增</strong>，需要及时报警出来，然后与业务应用报慢的时间点进行对比分析，确认时间是否一致，如果一致，则可以确认确实是因为集中过期 key 导致的延迟变大。</p><h1 id="实例内存达到上限"><a href="#实例内存达到上限" class="headerlink" title="实例内存达到上限"></a>实例内存达到上限</h1><p>如果你的 Redis 实例设置了内存上限 maxmemory，那么也有可能导致 Redis 变慢。</p><p>当我们把 Redis 当做纯缓存使用时，通常会给这个实例设置一个内存上限 maxmemory，然后设置一个数据淘汰策略。</p><p>而当实例的内存达到了 maxmemory 后，你可能会发现，在此之后每次写入新数据，操作延迟变大了。</p><p>这是为什么？</p><p>原因在于，当 Redis 内存达到 maxmemory 后，每次写入新的数据之前，<strong>Redis 必须先从实例中踢出一部分数据，让整个实例的内存维持在 maxmemory 之下</strong>，然后才能把新数据写进来。</p><p>这个踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于你配置的淘汰策略：</p><ul><li>allkeys-lru：不管 key 是否设置了过期，淘汰最近最少访问的 key</li><li>volatile-lru：只淘汰最近最少访问、并设置了过期时间的 key</li><li>allkeys-random：不管 key 是否设置了过期，随机淘汰 key</li><li>volatile-random：只随机淘汰设置了过期时间的 key</li><li>allkeys-ttl：不管 key 是否设置了过期，淘汰即将过期的 key</li><li>noeviction：不淘汰任何 key，实例内存达到 maxmeory 后，再写入新数据直接返回错误</li><li>allkeys-lfu：不管 key 是否设置了过期，淘汰访问频率最低的 key（4.0+版本支持）</li><li>volatile-lfu：只淘汰访问频率最低、并设置了过期时间 key（4.0+版本支持）</li></ul><p>具体使用哪种策略，我们需要根据具体的业务场景来配置。</p><p>一般最常使用的是 allkeys-lru / volatile-lru 淘汰策略，它们的处理逻辑是，每次从实例中随机取出一批 key（这个数量可配置），然后淘汰一个最少访问的 key，之后把剩下的 key 暂存到一个池子中，继续随机取一批 key，并与之前池子中的 key 比较，再淘汰一个最少访问的 key。以此往复，直到实例内存降到 maxmemory 之下。</p><p>需要注意的是，Redis 的淘汰数据的逻辑与删除过期 key 的一样，<strong>也是在命令真正执行之前执行的</strong>，也就是说它也会增加我们操作 Redis 的延迟，而且，写 OPS 越高，延迟也会越明显。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-4.jpg"></p><p>另外，如果此时你的 Redis 实例中还存储了 bigkey，那么<strong>在淘汰删除 bigkey 释放内存时，也会耗时比较久</strong>。</p><p>看到了么？bigkey 的危害到处都是，这也是前面我提醒你尽量不存储 bigkey 的原因。</p><p>针对这种情况，如何解决呢？</p><p>我给你 4 个方面的优化建议：</p><ol><li>避免存储 bigkey，降低释放内存的耗时</li><li>淘汰策略改为随机淘汰，随机淘汰比 LRU 要快很多（视业务情况调整）</li><li>拆分实例，把淘汰 key 的压力分摊到多个实例上</li><li>如果使用的是 Redis 4.0 以上版本，开启 layz-free 机制，把淘汰 key 释放内存的操作放到后台线程中执行（配置 lazyfree-lazy-eviction = yes）</li></ol><h1 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h1><p>为了保证 Redis 数据的安全性，我们可能会开启后台定时 RDB 和 AOF rewrite 功能。</p><p>但如果你发现，<strong>操作 Redis 延迟变大，都发生在 Redis 后台 RDB 和 AOF rewrite 期间</strong>，那你就需要排查，在这期间有可能导致变慢的情况。</p><p>当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。</p><p>主进程创建子进程，会调用操作系统提供的 fork 函数。</p><p>而 fork 在执行过程中，<strong>主进程需要拷贝自己的内存页表给子进程</strong>，如果这个实例很大，那么这个拷贝的过程也会比较耗时。</p><p>而且这个 fork 过程会消耗大量的 CPU 资源，在完成 fork 之前，整个 Redis 实例会被阻塞住，无法处理任何客户端请求。</p><p>如果此时你的 CPU 资源本来就很紧张，那么 fork 的耗时会更长，甚至达到秒级，这会严重影响 Redis 的性能。</p><p>那如何确认确实是因为 fork 耗时导致的 Redis 延迟变大呢？</p><p>你可以在 Redis 上执行 INFO 命令，查看 latest_fork_usec 项，单位微秒。</p><pre class="line-numbers language-none"><code class="language-none"># 上一次 fork 耗时，单位微秒latest_fork_usec:59477<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时间就是主进程在 fork 子进程期间，整个实例阻塞无法处理客户端请求的时间。</p><p>如果你发现这个耗时很久，就要警惕起来了，这意味在这期间，你的整个 Redis 实例都处于不可用的状态。</p><p>除了数据持久化会生成 RDB 之外，当主从节点第一次建立数据同步时，主节点也创建子进程生成 RDB，然后发给从节点进行一次全量同步，所以，这个过程也会对 Redis 产生性能影响。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-5.jpg"></p><p>要想避免这种情况，你可以采取以下方案进行优化：</p><ol><li>控制 Redis 实例的内存：尽量在 10G 以下，执行 fork 的耗时与实例大小有关，实例越大，耗时越久</li><li>合理配置数据持久化策略：在 slave 节点执行 RDB 备份，推荐在低峰期执行，而对于丢失数据不敏感的业务（例如把 Redis 当做纯缓存使用），可以关闭 AOF 和 AOF rewrite</li><li>Redis 实例不要部署在虚拟机上：fork 的耗时也与系统也有关，虚拟机比物理机耗时更久</li><li>降低主从库全量同步的概率：适当调大 repl-backlog-size 参数，避免主从全量同步</li></ol><h1 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h1><p>除了上面讲到的子进程 RDB 和 AOF rewrite 期间，fork 耗时导致的延时变大之外，这里还有一个方面也会导致性能问题，这就是操作系统是否开启了<strong>内存大页机制</strong>。</p><p>什么是内存大页？</p><p>我们都知道，应用程序向操作系统申请内存时，是按<strong>内存页</strong>进行申请的，而常规的内存页大小是 4KB。</p><p>Linux 内核从 2.6.38 开始，支持了<strong>内存大页机制</strong>，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。</p><p>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p><p>这对 Redis 会有什么影响呢？</p><p>当 Redis 在执行后台 RDB 和 AOF rewrite 时，采用 fork 子进程的方式来处理。但主进程 fork 子进程后，此时的<strong>主进程依旧是可以接收写请求的</strong>，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。</p><p>也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是<strong>先将这块内存数据拷贝出来，再修改这块新内存的数据</strong>，这就是所谓的「写时复制」。</p><p>写时复制你也可以理解成，谁需要发生写操作，谁就需要先拷贝，再修改。</p><p>这样做的好处是，父进程有任何写操作，并不会影响子进程的数据持久化（子进程只持久化 fork 这一瞬间整个实例中的所有数据即可，不关心新的数据变更，因为子进程只需要一份内存快照，然后持久化到磁盘上）。</p><p>但是请注意，主进程在拷贝内存数据时，这个阶段就涉及到新内存的申请，如果此时操作系统开启了内存大页，那么在此期间，客户端即便只修改 10B 的数据，<strong>Redis 在申请内存时也会以 2MB 为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到 Redis 性能。</strong></p><p>同样地，如果这个写请求操作的是一个 bigkey，那主进程在拷贝这个 bigkey 内存块时，一次申请的内存会更大，时间也会更久。可见，bigkey 在这里又一次影响到了性能。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-6.jpg"></p><p>那如何解决这个问题？</p><p>很简单，你只需要关闭内存大页机制就可以了。</p><p>首先，你需要查看 Redis 机器是否开启了内存大页：</p><pre class="line-numbers language-none"><code class="language-none">$ cat /sys/kernel/mm/transparent_hugepage/enabled[always] madvise never<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果输出选项是 always，就表示目前开启了内存大页机制，我们需要关掉它：</p><pre class="line-numbers language-none"><code class="language-none">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实，操作系统提供的内存大页机制，其优势是，可以在一定程序上降低应用程序申请内存的次数。</p><p>但是对于 Redis 这种对性能和延迟极其敏感的数据库来说，我们希望 Redis 在每次申请内存时，耗时尽量短，所以我不建议你在 Redis 机器上开启这个机制。</p><h1 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h1><p>前面我们分析了 RDB 和 AOF rewrite 对 Redis 性能的影响，主要关注点在 fork 上。</p><p>其实，关于数据持久化方面，还有影响 Redis 性能的因素，这次我们重点来看 AOF 数据持久化。</p><p>如果你的 AOF 配置不合理，还是有可能会导致性能问题。</p><p>当 Redis 开启 AOF 后，其工作原理如下：</p><ol><li>Redis 执行写命令后，把这个命令写入到 AOF 文件内存中（write 系统调用）</li><li>Redis 根据配置的 AOF 刷盘策略，把 AOF 内存数据刷到磁盘上（fsync 系统调用）</li></ol><p>为了保证 AOF 文件数据的安全性，Redis 提供了 3 种刷盘机制：</p><ol><li>appendfsync always：主线程每次执行写操作后立即刷盘，此方案会占用比较大的磁盘 IO 资源，但数据安全性最高</li><li>appendfsync no：主线程每次写操作只写内存就返回，内存数据什么时候刷到磁盘，交由操作系统决定，此方案对性能影响最小，但数据安全性也最低，Redis 宕机时丢失的数据取决于操作系统刷盘时机</li><li>appendfsync everysec：主线程每次写操作只写内存就返回，然后由后台线程每隔 1 秒执行一次刷盘操作（触发fsync系统调用），此方案对性能影响相对较小，但当 Redis 宕机时会丢失 1 秒的数据</li></ol><p>下面我们依次来分析，这几个机制对性能的影响。</p><p>如果你的 AOF 配置为 appendfsync always，那么 Redis 每处理一次写操作，都会把这个命令写入到磁盘中才返回，整个过程都是在主线程执行的，这个过程必然会加重 Redis 写负担。</p><p>原因也很简单，操作磁盘要比操作内存慢几百倍，采用这个配置会严重拖慢 Redis 的性能，因此我不建议你把 AOF 刷盘方式配置为 always。</p><p>我们接着来看 appendfsync no 配置项。</p><p>在这种配置下，Redis 每次写操作只写内存，什么时候把内存中的数据刷到磁盘，交给操作系统决定，此方案对 Redis 的性能影响最小，但当 Redis 宕机时，会丢失一部分数据，为了数据的安全性，一般我们也不采取这种配置。</p><blockquote><p>如果你的 Redis 只用作纯缓存，对于数据丢失不敏感，采用配置 appendfsync no 也是可以的。</p></blockquote><p>看到这里，我猜你肯定和大多数人的想法一样，选比较折中的方案 appendfsync everysec 就没问题了吧？</p><p>这个方案优势在于，Redis 主线程写完内存后就返回，具体的刷盘操作是放到后台线程中执行的，后台线程每隔 1 秒把内存中的数据刷到磁盘中。</p><p>这种方案既兼顾了性能，又尽可能地保证了数据安全，是不是觉得很完美？</p><p><strong>但是，这里我要给你泼一盆冷水了，采用这种方案你也要警惕一下，因为这种方案还是存在导致 Redis 延迟变大的情况发生，甚至会阻塞整个 Redis。</strong></p><p>这是为什么？我把 AOF 最耗时的刷盘操作，放到后台线程中也会影响到 Redis 主线程？</p><p>你试想这样一种情况：当 Redis 后台线程在执行 AOF 文件刷盘时，如果此时磁盘的 IO 负载很高，那这个后台线程在执行刷盘操作（fsync系统调用）时就会被阻塞住。</p><p>此时的主线程依旧会接收写请求，紧接着，主线程又需要把数据写到文件内存中（write 系统调用），<strong>但此时的后台子线程由于磁盘负载过高，导致 fsync 发生阻塞，迟迟不能返回，那主线程在执行 write 系统调用时，也会被阻塞住</strong>，直到后台线程 fsync 执行完成后，主线程执行 write 才能成功返回。</p><p>看到了么？在这个过程中，主线程依旧有阻塞的风险。</p><p><img src="https://image.fyxemmmm.cn/blog/images/redisslow-7.jpg"></p><p>所以，尽管你的 AOF 配置为 appendfsync everysec，也不能掉以轻心，要警惕磁盘压力过大导致的 Redis 有性能问题。</p><p>那什么情况下会导致磁盘 IO 负载过大？以及如何解决这个问题呢？</p><p>我总结了以下几种情况，你可以参考进行问题排查：</p><ol><li>子进程正在执行 AOF rewrite，这个过程会占用大量的磁盘 IO 资源</li><li>有其他应用程序在执行大量的写文件操作，也会占用磁盘 IO 资源</li></ol><p>对于情况1，说白了就是，Redis 的 AOF 后台子线程刷盘操作，撞上了子进程 AOF rewrite！</p><p>这怎么办？难道要关闭 AOF rewrite 才行？</p><p>幸运的是，Redis 提供了一个配置项，当子进程在 AOF rewrite 期间，可以让后台子线程不执行刷盘（不触发 fsync 系统调用）操作。</p><p>这相当于在 AOF rewrite 期间，临时把 appendfsync 设置为了 none，配置如下：</p><pre class="line-numbers language-none"><code class="language-none"># AOF rewrite 期间，AOF 后台子线程不进行刷盘操作# 相当于在这期间，临时把 appendfsync 设置为了 noneno-appendfsync-on-rewrite yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，开启这个配置项，在 AOF rewrite 期间，如果实例发生宕机，那么此时会丢失更多的数据，性能和数据安全性，你需要权衡后进行选择。</p><p>如果占用磁盘资源的是其他应用程序，那就比较简单了，你需要定位到是哪个应用程序在大量写磁盘，然后把这个应用程序迁移到其他机器上执行就好了，避免对 Redis 产生影响。</p><p>当然，如果你对 Redis 的性能和数据安全都有很高的要求，那么我建议从<strong>硬件层面</strong>来优化，更换为 SSD 磁盘，提高磁盘的 IO 能力，保证 AOF 期间有充足的磁盘资源可以使用。</p><h1 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h1><p>很多时候，我们在部署服务时，为了提高服务性能，降低应用程序在多个 CPU 核心之间的上下文切换带来的性能损耗，通常采用的方案是进程绑定 CPU 的方式提高性能。</p><p>但在部署 Redis 时，如果你需要绑定 CPU 来提高其性能，我建议你仔细斟酌后再做操作。</p><p>为什么？</p><p>因为 Redis 在绑定 CPU 时，是有很多考究的，如果你不了解 Redis 的运行原理，随意绑定 CPU 不仅不会提高性能，甚至有可能会带来相反的效果。</p><p>我们都知道，一般现代的服务器会有多个 CPU，而每个 CPU 又包含多个物理核心，每个物理核心又分为多个逻辑核心，每个物理核下的逻辑核共用 L1/L2 Cache。</p><p>而 Redis Server 除了主线程服务客户端请求之外，还会创建子进程、子线程。</p><p>其中子进程用于数据持久化，而子线程用于执行一些比较耗时操作，例如异步释放 fd、异步 AOF 刷盘、异步 lazy-free 等等。</p><p>如果你把 Redis 进程只绑定了一个 CPU 逻辑核心上，那么当 Redis 在进行数据持久化时，fork 出的子进程会继承父进程的 CPU 使用偏好。</p><p><strong>而此时的子进程会消耗大量的 CPU 资源进行数据持久化（把实例数据全部扫描出来需要耗费CPU），这就会导致子进程会与主进程发生 CPU 争抢，进而影响到主进程服务客户端请求，访问延迟变大。</strong></p><p>这就是 Redis 绑定 CPU 带来的性能问题。</p><p>那如何解决这个问题呢？</p><p>如果你确实想要绑定 CPU，可以优化的方案是，不要让 Redis 进程只绑定在一个 CPU 逻辑核上，而是绑定在多个逻辑核心上，而且，绑定的多个逻辑核心最好是同一个物理核心，这样它们还可以共用 L1/L2 Cache。</p><p>当然，即便我们把 Redis 绑定在多个逻辑核心上，也只能在一定程度上缓解主线程、子进程、后台线程在 CPU 资源上的竞争。</p><p>因为这些子进程、子线程还是会在这多个逻辑核心上进行切换，存在性能损耗。</p><p>如何再进一步优化？</p><p>可能你已经想到了，我们是否可以让主线程、子进程、后台线程，分别绑定在固定的 CPU 核心上，不让它们来回切换，这样一来，他们各自使用的 CPU 资源互不影响。</p><p>其实，这个方案 Redis 官方已经想到了。</p><p>Redis 在 6.0 版本已经推出了这个功能，我们可以通过以下配置，对主线程、后台线程、后台 RDB 进程、AOF rewrite 进程，绑定固定的 CPU 逻辑核心：</p><pre class="line-numbers language-none"><code class="language-none"># Redis Server 和 IO 线程绑定到 CPU核心 0,2,4,6server_cpulist 0-7:2# 后台子线程绑定到 CPU核心 1,3bio_cpulist 1,3# 后台 AOF rewrite 进程绑定到 CPU 核心 8,9,10,11aof_rewrite_cpulist 8-11# 后台 RDB 进程绑定到 CPU 核心 1,10,11# bgsave_cpulist 1,10-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你使用的正好是 Redis 6.0 版本，就可以通过以上配置，来进一步提高 Redis 性能。</p><p>这里我需要提醒你的是，一般来说，Redis 的性能已经足够优秀，除非你对 Redis 的性能有更加严苛的要求，否则不建议你绑定 CPU。</p><p>从上面的分析你也能看出，绑定 CPU 需要你对计算机体系结构有非常清晰的了解，否则谨慎操作。</p><p>我们继续分析还有什么场景会导致 Redis 变慢。</p><h1 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h1><p>如果你发现 Redis 突然变得非常慢，<strong>每次的操作耗时都达到了几百毫秒甚至秒级</strong>，那此时你就需要检查 Redis 是否使用到了 Swap，在这种情况下 Redis 基本上已经无法提供高性能的服务了。</p><p>什么是 Swap？为什么使用 Swap 会导致 Redis 的性能下降？</p><p>如果你对操作系统有些了解，就会知道操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。</p><p>问题就在于，当内存中的数据被换到磁盘上后，Redis 再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍！</p><p><strong>尤其是针对 Redis 这种对性能要求极高、性能极其敏感的数据库来说，这个操作延时是无法接受的。</strong></p><p>此时，你需要检查 Redis 机器的内存使用情况，确认是否存在使用了 Swap。</p><p>你可以通过以下方式来查看 Redis 进程是否使用到了 Swap：</p><pre class="line-numbers language-none"><code class="language-none"># 先找到 Redis 的进程 ID$ ps -aux | grep redis-server# 查看 Redis Swap 使用情况$ cat /proc/$pid/smaps | egrep '^(Swap|Size)'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下：</p><pre class="line-numbers language-none"><code class="language-none">Size:               1256 kBSwap:                  0 kBSize:                  4 kBSwap:                  0 kBSize:                132 kBSwap:                  0 kBSize:              63488 kBSwap:                  0 kBSize:                132 kBSwap:                  0 kBSize:              65404 kBSwap:                  0 kBSize:            1921024 kBSwap:                  0 kB...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个结果会列出 Redis 进程的内存使用情况。</p><p>每一行 Size 表示 Redis 所用的一块内存大小，Size 下面的 Swap 就表示这块 Size 大小的内存，有多少数据已经被换到磁盘上了，如果这两个值相等，说明这块内存的数据都已经完全被换到磁盘上了。</p><p>如果只是少量数据被换到磁盘上，例如每一块 Swap 占对应 Size 的比例很小，那影响并不是很大。<strong>如果是几百兆甚至上 GB 的内存被换到了磁盘上</strong>，那么你就需要警惕了，这种情况 Redis 的性能肯定会急剧下降。</p><p>此时的解决方案是：</p><ol><li>增加机器的内存，让 Redis 有足够的内存可以使用</li><li>整理内存空间，释放出足够的内存供 Redis 使用，然后释放 Redis 的 Swap，让 Redis 重新使用内存</li></ol><p>释放 Redis 的 Swap 过程通常要重启实例，为了避免重启实例对业务的影响，一般会先进行主从切换，然后释放旧主节点的 Swap，重启旧主节点实例，待从库数据同步完成后，再进行主从切换即可。</p><p>可见，当 Redis 使用到 Swap 后，此时的 Redis 性能基本已达不到高性能的要求（你可以理解为武功被废），所以你也需要提前预防这种情况。</p><p>预防的办法就是，你需要对 Redis 机器的内存和 Swap 使用情况进行监控，在内存不足或使用到 Swap 时报警出来，及时处理。</p><h1 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h1><p>Redis 的数据都存储在内存中，当我们的应用程序频繁修改 Redis 中的数据时，就有可能会导致 Redis 产生内存碎片。</p><p>内存碎片会降低 Redis 的内存使用率，我们可以通过执行 INFO 命令，得到这个实例的内存碎片率：</p><pre class="line-numbers language-none"><code class="language-none"># Memoryused_memory:5709194824used_memory_human:5.32Gused_memory_rss:8264855552used_memory_rss_human:7.70G...mem_fragmentation_ratio:1.45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个内存碎片率是怎么计算的？</p><p>很简单，mem_fragmentation_ratio = used_memory_rss / used_memory。</p><p>其中 used_memory 表示 Redis 存储数据的内存大小，而 used_memory_rss 表示操作系统实际分配给 Redis 进程的大小。</p><p>如果 mem_fragmentation_ratio &gt; 1.5，说明内存碎片率已经超过了 50%，这时我们就需要采取一些措施来降低内存碎片了。</p><p>解决的方案一般如下：</p><ol><li>如果你使用的是 Redis 4.0 以下版本，只能通过重启实例来解决</li><li>如果你使用的是 Redis 4.0 版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理</li></ol><p><strong>但是，开启内存碎片整理，它也有可能会导致 Redis 性能下降。</strong></p><p>原因在于，Redis 的碎片整理工作是也在<strong>主线程</strong>中执行的，当其进行碎片整理时，必然会消耗 CPU 资源，产生更多的耗时，从而影响到客户端的请求。</p><p>所以，当你需要开启这个功能时，最好提前测试评估它对 Redis 的影响。</p><p>Redis 碎片整理的参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none"># 开启自动内存碎片整理（总开关）activedefrag yes# 内存使用 100MB 以下，不进行碎片整理active-defrag-ignore-bytes 100mb# 内存碎片率超过 10%，开始碎片整理active-defrag-threshold-lower 10# 内存碎片率超过 100%，尽最大努力碎片整理active-defrag-threshold-upper 100# 内存碎片整理占用 CPU 资源最小百分比active-defrag-cycle-min 1# 内存碎片整理占用 CPU 资源最大百分比active-defrag-cycle-max 25# 碎片整理期间，对于 List/Set/Hash/ZSet 类型元素一次 Scan 的数量active-defrag-max-scan-fields 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你需要结合 Redis 机器的负载情况，以及应用程序可接受的延迟范围进行评估，合理调整碎片整理的参数，尽可能降低碎片整理期间对 Redis 的影响。</p><h1 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h1><p>如果以上产生性能问题的场景，你都规避掉了，而且 Redis 也稳定运行了很长时间，但在某个时间点之后开始，操作 Redis 突然开始变慢了，而且一直持续下去，这种情况又是什么原因导致？</p><p>此时你需要排查一下 Redis 机器的网络带宽是否过载，是否存在某个实例把整个机器的网路带宽占满的情况。</p><p>网络带宽过载的情况下，服务器在 TCP 层和网络层就会出现数据包发送延迟、丢包等情况。</p><p>Redis 的高性能，除了操作内存之外，就在于网络 IO 了，如果网络 IO 存在瓶颈，那么也会严重影响 Redis 的性能。</p><p>如果确实出现这种情况，你需要及时确认占满网络带宽 Redis 实例，如果属于正常的业务访问，那就需要及时扩容或迁移实例了，避免因为这个实例流量过大，影响这个机器的其他实例。</p><p>运维层面，你需要对 Redis 机器的各项指标增加监控，包括网络流量，在网络流量达到一定阈值时提前报警，及时确认和扩容。</p><h1 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h1><p>好了，以上这些方面就是如何排查 Redis 延迟问题的思路和路径。</p><p>除了以上这些，还有一些比较小的点，你也需要注意一下：</p><p><strong>1) 频繁短连接</strong></p><p>你的业务应用，应该使用长连接操作 Redis，避免频繁的短连接。</p><p>频繁的短连接会导致 Redis 大量时间耗费在连接的建立和释放上，TCP 的三次握手和四次挥手同样也会增加访问延迟。</p><p><strong>2) 运维监控</strong></p><p>前面我也提到了，要想提前预知 Redis 变慢的情况发生，必不可少的就是做好完善的监控。</p><p>监控其实就是对采集 Redis 的各项运行时指标，通常的做法是监控程序定时采集 Redis 的 INFO 信息，然后根据 INFO 信息中的状态数据做数据展示和报警。</p><p>这里我需要提醒你的是，在写一些监控脚本，或使用开源的监控组件时，也不能掉以轻心。</p><p>在写监控脚本访问 Redis 时，尽量采用长连接的方式采集状态信息，避免频繁短连接。同时，你还要注意控制访问 Redis 的频率，避免影响到业务请求。</p><p>在使用一些开源的监控组件时，最好了解一下这些组件的实现原理，以及正确配置这些组件，防止出现监控组件发生 Bug，导致短时大量操作 Redis，影响 Redis 性能的情况发生。</p><p>我们当时就发生过，DBA 在使用一些开源组件时，因为配置和使用问题，导致监控程序频繁地与 Redis 建立和断开连接，导致 Redis 响应变慢。</p><p><strong>3）其它程序争抢资源</strong></p><p>最后需要提醒你的是，你的 Redis 机器最好专项专用，只用来部署 Redis 实例，不要部署其他应用程序，尽量给 Redis 提供一个相对「安静」的环境，避免其它程序占用 CPU、内存、磁盘资源，导致分配给 Redis 的资源不足而受到影响。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，以上就是我总结的在使用 Redis 过程中，常见的可能导致延迟、甚至阻塞的问题场景，以及如何快速定位和分析这些问题，并且针对性地提供了解决方案。</p><p>这里再简单总结一下，Redis 的性能问题，既涉及到了业务开发人员的使用方面，也涉及到了 DBA 的运维方面。</p><p>作为业务开发人员，我们需要了解 Redis 的基本原理，例如各个命令执行的时间复杂度、数据过期策略、数据淘汰策略等，从而更合理地使用 Redis 命令，并且结合业务场景进行优化。</p><p>作为 DBA 和运维人员，需要了解 Redis 运行机制，例如数据持久化、内存碎片整理、进程绑核配置。除此之外，还需要了解操作系统相关知识，例如写时复制、内存大页、Swap 机制等等。</p><p>同时，DBA 在部署 Redis 时，需要提前对进行容量规划，预留足够的机器资源，还要对 Redis 机器和实例做好完善的监控，这样才能尽可能地保证 Redis 的稳定运行。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果你能耐心地看到这里，想必你肯定已经对 Redis 的性能调优有了很大的收获。</p><p>你应该也发现了，Redis 的性能问题，涉及到的知识点非常广，几乎涵盖了 CPU、内存、网络、甚至磁盘的方方面面，同时，你还需要了解计算机的体系结构，以及操作系统的各种机制。</p><p>从资源使用角度来看，包含的知识点如下：</p><ul><li>CPU 相关：使用复杂度过高命令、数据的持久化，都与耗费过多的 CPU 资源有关</li><li>内存相关：bigkey 内存的申请和释放、数据过期、数据淘汰、碎片整理、内存大页、内存写时复制都与内存息息相关</li><li>磁盘相关：数据持久化、AOF 刷盘策略，也会受到磁盘的影响</li><li>网络相关：短连接、实例流量过载、网络流量过载，也会降低 Redis 性能</li><li>计算机系统：CPU 结构、内存分配，都属于最基础的计算机系统知识</li><li>操作系统：写时复制、内存大页、Swap、CPU 绑定，都属于操作系统层面的知识</li></ul><p>没想到吧？Redis 为了把性能做到极致，涉及到了这么多项优化。</p><p>希望这篇文章能给你带来帮助。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>limit &amp; offset 为什么会慢</title>
      <link href="/2021/10/19/mysql-fen-ye-cha-xun/"/>
      <url>/2021/10/19/mysql-fen-ye-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="从一个问题说起"><a href="#从一个问题说起" class="headerlink" title="从一个问题说起"></a>从一个问题说起</h2><p>五年前发现分页场景下，mysql请求速度非常慢。数据量只有10w的情况下，select xx from 单机大概2，3秒。我就问我导师为什么，他反问“索引场景，mysql中获得第n大的数，时间复杂度是多少？”</p><h2 id="答案的追寻"><a href="#答案的追寻" class="headerlink" title="答案的追寻"></a>答案的追寻</h2><h3 id="确认场景"><a href="#确认场景" class="headerlink" title="确认场景"></a>确认场景</h3><p>假设status上面有索引。select * from table where status = xx limit 10 offset 10000。会非常慢。数据量不大的情况就有几秒延迟。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>仔细分析一下，会发现通过索引去找很别扭。因为你不知道前100个数在左子树和右子数的分布情况，所以其是无法利用二叉树的查找特性。</p><p><img src="https://image.fyxemmmm.cn/blog/images/mysqlfy-0.jpg"></p><p>看了这个图，就豁然开朗了。可以直接通过叶子节点组成的链表，以o(n)的复杂度找到第100大的树。但是即使是o(n)，也不至于慢得令人发指，是否还有原因。</p><h3 id="系统学习"><a href="#系统学习" class="headerlink" title="系统学习"></a>系统学习</h3><p>这里推荐两本书，一本《MySQL技术内幕 InnoDB存储引擎》，通过他可以对InnoDB的实现机制，如mvcc，索引实现，文件存储会有更深理解。</p><p>第二本是《高性能MySQL》，这本书从着手使用层面，但讲得比较深入，而且提到了很多设计的思路。</p><p>两本书相结合，反复领会，mysql就勉强能登堂入室了。</p><p>这里有两个关键概念：</p><ul><li>聚簇索引：包含主键索引和对应的实际数据，索引的叶子节点就是数据节点</li><li>辅助索引：可以理解为二级节点，其叶子节点还是索引节点，包含了主键id。</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/mysqlfy-1.jpg"></p><p>即使前10000个会扔掉，mysql也会通过二级索引上的主键id,去聚簇索引上查一遍数据，这可是10000次随机io，自然慢成哈士奇。这里可能会提出疑问，为什么会有这种行为，这是和mysql的分层有关系，limit offset 只能作用于引擎层返回的结果集。换句话说，引擎层也很无辜，他并不知道这10000个是要扔掉的。以下是mysql分层示意图，可以看到，引擎层和server层，实际是分开的。</p><p><img src="https://image.fyxemmmm.cn/blog/images/mysqlfy-2.jpg"></p><h2 id="拨开迷雾"><a href="#拨开迷雾" class="headerlink" title="拨开迷雾"></a>拨开迷雾</h2><p>其实一条语句的查询，是由逻辑算子组成。</p><p>逻辑算子介绍 在写具体的优化规则之前，先简单介绍查询计划里面的一些逻辑算子。</p><ul><li>DataSource 这个就是数据源，也就是表，select * from t 里面的 t。</li><li>Selection 选择，例如 select xxx from t where xx = 5 里面的 where 过滤条件。</li><li>Projection 投影， select c from t 里面的取 c 列是投影操作。</li><li>Join 连接， select xx from t1, t2 where t1.c = t2.c 就是把 t1 t2 两个表做 Join。</li></ul><p>选择，投影，连接（简称 SPJ） 是最基本的算子。其中 Join 有内连接，左外右外连接等多种连接方式。</p><p><code>select b from t1, t2 where t1.c = t2.c and t1.a &gt; 5</code> 变成逻辑查询计划之后，t1 t2 对应的 DataSource，负责将数据捞上来。上面接个 Join 算子，将两个表的结果按 t1.c = t2.c连接，再按 <code>t1.a &gt; 5</code> 做一个 Selection 过滤，最后将 b 列投影。下图是未经优化的表示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/mysqlfy-3.jpg"></p><p>所以说不是mysql不想把limit, offset传递给引擎层，而是因为划分了逻辑算子，所以导致无法直到具体算子包含了多少符合条件的数据。</p><h2 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h2><p>《高性能MySQL》提到了两种方案</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>根据业务实际需求，看能否替换为下一页，上一页的功能，特别在ios, android端，以前那种完全的分页是不常见的。这里是说，把limit, offset，替换为&gt;辅助索引（即搜索条件）id的方式。该id再调用时，需要返回给前端。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>正面刚。这里介绍一个概念：索引覆盖：当辅助索引查询的数据，只有id和辅助索引本身，那么就不必再去查聚簇索引。</p><p>思路如下：`select xxx,xxx from in (select id from table where second_index = xxx limit 10 offset 10000)`` 这句话是说，先从条件查询中，查找数据对应的数据库唯一id值，因为主键在辅助索引上就有，所以不用回归到聚簇索引的磁盘去拉取。再通过这些已经被limit出来的10个主键id，去查询聚簇索引。这样只会十次随机io。在业务确实需要用分页的情况下，使用该方案可以大幅度提高性能。通常能满足性能要求。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> limit </tag>
            
            <tag> offset </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单说说「跨域请求」</title>
      <link href="/2021/10/14/cors/"/>
      <url>/2021/10/14/cors/</url>
      
        <content type="html"><![CDATA[<p>“前端如何解决跨域问题？” 这个是前段在知乎看到的一个提问，这几乎是做前端都会遇到的一个问题，产生的情况可能会很多，解决一个问题还是要先了解下为什么会产生这样问题，学习最好的方法就是结合一些实际的案例来学习，理解和掌握也会更加的深刻，本文结合 Node.js 写一些 Demo 看一下跨域问题及解决办法，最好是自己看完也能够动手操作下～</p><p>Cross-origin Resource Sharing 中文名称 “<strong>跨域资源共享</strong>” 简称 “<strong>CORS</strong>”，它突破了一个请求在浏览器发出只能在同源的情况下向服务器获取数据的限制。</p><p>本文会先从一个示例开始，分析是浏览器还是服务器的限制，之后讲解什么时候会产生预检请求，在整个过程中，也会讲解一下解决该问题的实现方法，文末会再总结如何使用 Node.js 中的 cors 模块和 Nginx 反向代理来解决跨域问题。</p><p>文中使用 Node.js 做一些 Demo 的演示，每一小节之后也会给予代码的 Demo 地址。</p><h2 id="浏览器还是服务器的限制"><a href="#浏览器还是服务器的限制" class="headerlink" title="浏览器还是服务器的限制"></a>浏览器还是服务器的限制</h2><p>先思考下，CORS 是浏览器端还是服务器端的限制？为了更好的说明这个问题，从一段示例开始。</p><h3 id="从一段示例开始"><a href="#从一段示例开始" class="headerlink" title="从一段示例开始"></a>从一段示例开始</h3><p><strong>index.html</strong></p><p>创建 index.html 使用 fetch 调用 <a href="http://127.0.0.1:3011/api/data">http://127.0.0.1:3011/api/data</a></p><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;  &lt;!-- &lt;script src="https://cdn.bootcdn.net/ajax/libs/fetch/3.0.0/fetch.min.js"&gt;&lt;/script&gt; --&gt;  &lt;script&gt;    fetch('http://127.0.0.1:3011/api/data');  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>client.js</strong></p><p>创建 client.js 用来加载上面 index.html。设置端口为 3010。</p><pre class="line-numbers language-none"><code class="language-none">const http = require('http');const fs = require('fs');const PORT = 3010;http.createServer((req, res) =&gt; {  fs.createReadStream('index.html').pipe(res);}).listen(PORT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>server.js</strong></p><p>创建 server.js 开启一个服务，根据不同的请求返回不同的响应。设置端口为 3011。</p><pre class="line-numbers language-none"><code class="language-none">const http = require('http');const PORT = 3011;http.createServer((req, res) =&gt; {  const url = req.url;  console.log('request url: ', url);  if (url === '/api/data') {    return res.end('ok!');  }  if (url === '/script') {    return res.end('console.log("hello world!");');  }}).listen(PORT);console.log('Server listening on port ', PORT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试分析原因"><a href="#测试分析原因" class="headerlink" title="测试分析原因"></a>测试分析原因</h3><p>运行上面的 client.js、server.js 浏览器输入 <a href="http://127.0.0.1:3010/">http://127.0.0.1:3010</a> 在 Chrome 浏览器中打开 Network 项查看请求信息，如下所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/cors-1.jpg"></p><p>左侧是使用 fetch 请求的 127.0.0.1:3011/api/data 接口，在请求头里可以看到有 Origin 字段，显示了我们当前的请求信息。另外还有三个 Sec-Fetch-* 开头的字段，这是一个新的草案 **Fetch Metadata Request Headers[1]**。</p><p>其中 Sec-Fetch-Mode 表示请求的模式，通过左右两侧结果对比也可以看出左侧是跨域的。Sec-Fetch-Site 表示的是这个请求是同源还是跨域，由于我们这两个请求都是由 3010 端口发出去请求 3011 端口，是不符合同源策略的。</p><p>看下浏览器 Console 下的日志信息，根据提示得知原因是从 “<a href="http://127.0.0.1:3010”">http://127.0.0.1:3010”</a> 访问 “<a href="http://127.0.0.1:3011/api/data%E2%80%9D">http://127.0.0.1:3011/api/data”</a> 被 CORS 策略阻止了，没有 “Access-Control-Allow-Origin” 标头。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cors-2.jpg"></p><p>在看下服务端的日志，因为请求 3011 服务，所以就看下 3011 服务的日志信息：</p><pre class="line-numbers language-none"><code class="language-none">Server listening on port  3011request url:  /scriptrequest url:  /api/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在服务端是有收到请求信息的，说明服务端是正常工作的。</p><p>我们也可以在终端通过 curl 命令测试下，在终端脱离浏览器环境也是可以正常请求的。</p><pre class="line-numbers language-none"><code class="language-none">$ curl http://127.0.0.1:3011/api/dataok!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本节代码示例：</p><pre class="line-numbers language-none"><code class="language-none">github.com/qufei1993/http-protocol/tree/master/example/cors/01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="总结回答最开始提出的问题"><a href="#总结回答最开始提出的问题" class="headerlink" title="总结回答最开始提出的问题"></a>总结回答最开始提出的问题</h3><p><strong>浏览器限制了从脚本内发起的跨源 HTTP 请求</strong>，例如 <strong>XMLHttpRequest</strong> 和我们本示例中使用的 <strong>Fetch API 都是遵循的同源策略</strong>。</p><p>当一个请求在浏览器端发送出去后，服务端是会收到的并且也会处理和响应，只不过浏览器在解析这个请求的响应之后，发现不属于浏览器的<strong>同源策略</strong>（地址里面的协议、域名和端口号均相同）也没有包含正确的 CORS 响应头，返回结果被浏览器给拦截了。</p><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>预检请求是在发送实际的请求之前，客户端会先发送一个 OPTIONS 方法的请求向服务器确认，如果通过之后，浏览器才会发起真正的请求，这样可以避免跨域请求对服务器的用户数据造成影响。</p><p>看到这里你可能有疑问为什么上面的示例没有预检请求？因为 <strong>CORS 将请求分为了两类：简单请求和非简单请求</strong>。我们上面的情况属于简单请求，所以也就没有了预检请求。</p><p>让我们继续在看下简单请求和非简单请求是如何定义的。</p><h3 id="预检请求定义"><a href="#预检请求定义" class="headerlink" title="预检请求定义"></a>预检请求定义</h3><p>根据 MDN 的文档定义，请求方法为：GET、POST、HEAD，请求头 Content-Type 为：text/plain、multipart/form-data、application/x-www-form-urlencoded 的就属于 “简单请求” 不会触发 CORS 预检请求。</p><p>例如，如果请求头的 Content-Type 为 application/json 就会触发 CORS 预检请求，这里也会称为 “非简单请求”。</p><p><strong>“MDN 文档 developer.mozilla.org/en-US/docs/Web/HTTP/CORS 简单请求”</strong>[2] 有更多关于简单请求的字段定义。</p><h3 id="预检请求示例"><a href="#预检请求示例" class="headerlink" title="预检请求示例"></a>预检请求示例</h3><p>通过一个示例学习下预检请求。</p><h4 id="设置客户端"><a href="#设置客户端" class="headerlink" title="设置客户端"></a>设置客户端</h4><p>为 index.html 里的 fetch 方法增加一些设置，设置请求的方法为 PUT，请求头增加一个自定义字段 Test-Cors。</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;  fetch('http://127.0.0.1:3011/api/data', {    method: 'PUT',    headers: {      'Content-Type': 'text/plain',      'Test-Cors': 'abc'    }  });&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在浏览器执行时会发现是一个非简单请求，就会先执行一个预检请求，Request Headers 会有如下信息：</p><pre class="line-numbers language-none"><code class="language-none">OPTIONS /api/data HTTP/1.1Host: 127.0.0.1:3011Access-Control-Request-Method: PUTAccess-Control-Request-Headers: content-type,test-corsOrigin: http://127.0.0.1:3010Sec-Fetch-Mode: cors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到有一个 OPTIONS 是预检请求使用的方法，该方法是在 HTTP/1.1 协议中所定义的，还有一个重要的字段 <strong>Origin 表示请求来自哪个源</strong>，服务端则可以根据这个字段判断是否是合法的请求源，例如 Websocket 中因为没有了同源策略限制，服务端可以根据这个字段来判断。</p><p><strong>Access-Control-Request-Method</strong> 告诉服务器，实际请求将使用 PUT 方法。</p><p><strong>Access-Control-Request-Headers</strong> 告诉服务器，实际请求将使用两个头部字段 content-type,test-cors。这里如果 content-type 指定的为简单请求中的几个值，Access-Control-Request-Headers 在告诉服务器时，实际请求将只有 test-cors 这一个头部字段。</p><h4 id="设置服务端"><a href="#设置服务端" class="headerlink" title="设置服务端"></a>设置服务端</h4><p>上面讲解了客户端的设置，同样的要使请求能够正常响应，还需服务端的支持。</p><p>修改我们的 server.js 重点是设置 Response Headers 代码如下所示：</p><pre class="line-numbers language-none"><code class="language-none">res.writeHead(200, {  'Access-Control-Allow-Origin': 'http://127.0.0.1:3010',  'Access-Control-Allow-Headers': 'Test-CORS, Content-Type',  'Access-Control-Allow-Methods': 'PUT,DELETE',  'Access-Control-Max-Age': 86400});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么是以上配置？首先预检请求时，浏览器给了服务器几个重要的信息 Origin、Method 为 PUT、Headers 为 content-type,test-cors 服务端在收到之后，也要做些设置，给予回应。</p><p>Access-Control-Allow-Origin 表示 “<a href="http://127.0.0.1:3010”">http://127.0.0.1:3010”</a> 这个请求源是可以访问的，该字段也可以设置为 “*” 表示允许任意跨源请求。</p><p>Access-Control-Allow-Methods 表示服务器允许客户端使用 PUT、DELETE 方法发起请求，可以一次设置多个，表示服务器所支持的所有跨域方法，而不单是当前请求那个方法，这样好处是为了避免多次预检请求。</p><p>Access-Control-Allow-Headers 表示服务器允许请求中携带 Test-CORS、Content-Type 字段，也可以设置多个。</p><p>Access-Control-Max-Age 表示该响应的有效期，单位为秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。还有一点需要注意，该值要小于浏览器自身维护的最大有效时间，否则是无效的。</p><p>看下增加了预检请求的效果，第一次先发出了 OPTIONS 请求，并且在请求头设置了本次请求的方法和 Headers 信息，服务端在 Response 也做了回应，在 OPTIONS 成功之后，浏览器紧跟着才发起了我们本次需要的真实请求，如图右侧所示 Resquest Method 为 PUT。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cors-3.jpg"></p><p>本节代码示例：</p><pre class="line-numbers language-none"><code class="language-none">github.com/qufei1993/http-protocol/tree/master/example/cors/02<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="CORS-与认证"><a href="#CORS-与认证" class="headerlink" title="CORS 与认证"></a>CORS 与认证</h2><p>对于跨域的 XMLHttpRequest 或 Fetch 请求，浏览器是不会发送身份凭证信息的。例如我们要在跨域请求中发送 Cookie 信息，就要做些设置：</p><p>为了能看到效果，我先自定义了一个 cookie 信息 id=NodejsRoadmap。</p><p>重点是设置认证字段，本文中 fetch 示例设置 <strong>credentials: “include”</strong> 如果是 XMLHttpRequest 则设置 <strong>withCredentials:”include”</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;  &lt;script&gt;    document.cookie = `id=NodejsRoadmap`;    fetch('http://127.0.0.1:3011/api/data', {      method: 'PUT',      headers: {        'Content-Type': 'application/json',        'Test-Cors': 'abc',      },      credentials: "include"    });  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过以上设置，浏览器发送实际请求时会向服务器发送 Cookies，同时服务器也需要在响应中设置 Access-Control-Allow-Credentials 响应头</p><pre class="line-numbers language-none"><code class="language-none">res.writeHead(200, {  'Access-Control-Allow-Origin': 'http://127.0.0.1:3010',  'Access-Control-Allow-Credentials': true});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果服务端不设置浏览器就不会正常响应，会报一个跨域错误，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">Access to fetch at 'http://127.0.0.1:3011/api/data' from origin 'http://127.0.0.1:3010' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一点需要注意，如果我们在请求中设置了 <strong>credentials: “include”</strong> 服务端就不能设置 <strong>Access-Control-Allow-Origin: “*“</strong> 只能设置为一个明确的地址。</p><p>本节代码示例：</p><pre class="line-numbers language-none"><code class="language-none">github.com/qufei1993/http-protocol/tree/master/example/cors/03<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解决跨域问题的几种方法"><a href="#解决跨域问题的几种方法" class="headerlink" title="解决跨域问题的几种方法"></a>解决跨域问题的几种方法</h2><p>通过上面的分析了解跨域产生的原因之后，解决其实并不难，上面的讲解中其实也提供了解决方案，例如在 Node.js 中我们可以设置响应头部字段 Access-Control-Allow-Origin、Access-Control-Expose-Headers、Access-Control-Allow-Methods 等，但是在实际开发中这样设置难免繁琐，下面介绍几种常用的解决方法。</p><h3 id="使用-CORS-模块"><a href="#使用-CORS-模块" class="headerlink" title="使用 CORS 模块"></a>使用 CORS 模块</h3><p>在 Node.js 中推荐你使用 cors 模块 <strong>github.com/expressjs/cors</strong>[3]。</p><p>在我们本节的示例中，一直使用的 Node.js 原生模块来编写我们的示例，在引入 cors 模块后，可以按照如下方式改写：</p><pre class="line-numbers language-none"><code class="language-none">const http = require('http');const PORT = 3011;const corsMiddleware = require('cors')({  origin: 'http://127.0.0.1:3010',  methods: 'PUT,DELETE',  allowedHeaders: 'Test-CORS, Content-Type',  maxAge: 1728000,  credentials: true,});http.createServer((req, res) =&gt; {  const { url, method } = req;  console.log('request url:', url, ', request method:', method);  const nextFn = () =&gt; {    if (method === 'PUT' &amp;&amp; url === '/api/data') {      return res.end('ok!');    }    return res.end();  }  corsMiddleware(req, res, nextFn);}).listen(PORT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cors 在预检请求之后或在预检请求里并选项中设置了 preflightContinue 属性之后才会执行 nextFn 这个函数，如果预检失败就不会执行 nextFn 函数。</p><p>如果你用的 Express.js 框架，使用起来也很简单，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">const express = require('express')const cors = require('cors')const app = express()app.use(cors());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>浏览器是允许像 link、img、script 标签在路径上加载一些内容进行请求，是允许跨域的，那么 jsonp 的实现原理就是在 script 标签里面加载了一个链接，去访问服务器的某个请求，返回内容。</p><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;  &lt;script&gt;    // fetch('http://127.0.0.1:3011/api/data', {    //   method: 'PUT',    //   headers: {    //     'Content-Type': 'application/json',    //     'Test-Cors': 'abc',    //   },    //   credentials: "include"    // });    &lt;srcipt src="http://127.0.0.1:3011/api/data"&gt;&lt;/srcipt&gt;  &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比上面 CORS 模块，JSONP 只支持 GET 请求，显然是没有 CORS 模块强大的。</p><h3 id="Nginx-代理服务器配置跨域"><a href="#Nginx-代理服务器配置跨域" class="headerlink" title="Nginx 代理服务器配置跨域"></a>Nginx 代理服务器配置跨域</h3><p>使用 Nginx 代理服务器之后，请求不会直接到达我们的 Node.js 服务器端，请求会先经过 Nginx 在设置一些跨域等信息之后再由 Nginx 转发到我们的 Node.js 服务端，所以这个时候我们的 Nginx 服务器去监听的 3011 端口，我们把 Node.js 服务的端口修改为 30011，简单配置如下所示：</p><pre class="line-numbers language-none"><code class="language-none">server {  listen          3011;  server_name     localhost;  location / {    if ($request_method = 'OPTIONS') {      add_header 'Access-Control-Allow-Origin' 'http://127.0.0.1:3010';      add_header 'Access-Control-Allow-Methods' 'PUT,DELETE';      add_header 'Access-Control-Allow-Headers' 'Test-CORS, Content-Type';      add_header 'Access-Control-Max-Age' 1728000;      add_header 'Access-Control-Allow-Credentials' 'true';      add_header 'Content-Length' 0;      return 204;    }    add_header 'Access-Control-Allow-Origin' 'http://127.0.0.1:3010';    add_header 'Access-Control-Allow-Credentials' 'true';    proxy_pass http://127.0.0.1:30011;    proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本节代码示例：</p><pre class="line-numbers language-none"><code class="language-none">github.com/qufei1993/http-protocol/tree/master/example/cors/04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你是一个前端开发者，在工作难免会遇到跨域问题，虽然它属于浏览器的同源策略限制，但是要想解决这问题还需浏览器端与服务端的共同支持，希望读到这篇文章的读者能够理解跨域产生的原因，最后给予的几个解决方案，也希望能解决你对于跨域这个问题的困惑。</p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> cors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes nfs-provider</title>
      <link href="/2021/10/09/k8s-nfs-provider/"/>
      <url>/2021/10/09/k8s-nfs-provider/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是StorageClass"><a href="#一、什么是StorageClass" class="headerlink" title="一、什么是StorageClass"></a>一、什么是StorageClass</h3><pre class="line-numbers language-none"><code class="language-none">Kubernetes提供了一套可以自动创建PV的机制,即:Dynamic Provisioning.而这个机制的核心在于:StorageClass这个API对象.StorageClass对象会定义下面两部分内容:1,PV的属性.比如,存储类型,Volume的大小等.2,创建这种PV需要用到的存储插件有了这两个信息之后,Kubernetes就能够根据用户提交的PVC,找到一个对应的StorageClass,之后Kubernetes就会调用该StorageClass声明的存储插件,进而创建出需要的PV.但是其实使用起来是一件很简单的事情,你只需要根据自己的需求,编写YAML文件即可,然后使用kubectl create命令执行即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、为什么需要StorageClass"><a href="#二、为什么需要StorageClass" class="headerlink" title="二、为什么需要StorageClass"></a>二、为什么需要StorageClass</h3><pre class="line-numbers language-none"><code class="language-none">在一个大规模的Kubernetes集群里,可能有成千上万个PVC,这就意味着运维人员必须实现创建出这个多个PV,此外,随着项目的需要,会有新的PVC不断被提交,那么运维人员就需要不断的添加新的,满足要求的PV,否则新的Pod就会因为PVC绑定不到PV而导致创建失败.而且通过 PVC 请求到一定的存储空间也很有可能不足以满足应用对于存储设备的各种需求而且不同的应用程序对于存储性能的要求可能也不尽相同，比如读写速度、并发性能等，为了解决这一问题，Kubernetes 又为我们引入了一个新的资源对象：StorageClass，通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="三、StorageClass运行原理及部署流程"><a href="#三、StorageClass运行原理及部署流程" class="headerlink" title="三、StorageClass运行原理及部署流程"></a>三、StorageClass运行原理及部署流程</h3><p>要使用 StorageClass，我们就得安装对应的自动配置程序，比如我们这里存储后端使用的是 nfs，那么我们就需要使用到一个 nfs-client 的自动配置程序，我们也叫它 Provisioner，这个程序使用我们已经配置好的 nfs 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p><pre class="line-numbers language-none"><code class="language-none">1.自动创建的 PV 以${namespace}-${pvcName}-${pvName}这样的命名格式创建在 NFS 服务器上的共享数据目录中2.而当这个 PV 被回收后会以archieved-${namespace}-${pvcName}-${pvName}这样的命名格式存在 NFS 服务器上。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="1-原理及部署流程说明"><a href="#1-原理及部署流程说明" class="headerlink" title="1.原理及部署流程说明"></a>1.原理及部署流程说明</h6><p><strong>详细的运作流程可以参考下图:</strong></p><p><img src="https://image.fyxemmmm.cn/blog/images/nfs01.png"></p><p> <strong>搭建StorageClass+NFS,大致有以下几个步骤:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.创建一个可用的NFS Serve2.创建Service Account.这是用来管控NFS provisioner在k8s集群中运行的权限3.创建StorageClass.负责建立PVC并调用NFS provisioner进行预定的工作,并让PV与PVC建立管理4.创建NFS provisioner.有两个功能,一个是在NFS共享目录下创建挂载点(volume),另一个则是建了PV并将PV与NFS的挂载点建立关联  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、创建StorageClass"><a href="#四、创建StorageClass" class="headerlink" title="四、创建StorageClass"></a>四、创建StorageClass</h3><h6 id="1-创建NFS共享服务"><a href="#1-创建NFS共享服务" class="headerlink" title="1.创建NFS共享服务"></a>1.创建NFS共享服务</h6><p><strong>该步骤比较简单不在赘述,大家可以自行百度搭建</strong></p><p><strong>当前环境NFS server及共享目录信息</strong></p><pre class="line-numbers language-none"><code class="language-none">IP: 172.16.155.227Export PATH: /data/volumes/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="2-使用以下文档配置account及相关权限"><a href="#2-使用以下文档配置account及相关权限" class="headerlink" title="2.使用以下文档配置account及相关权限"></a>2.使用以下文档配置account及相关权限</h6><p><strong>rbac.yaml:   #唯一需要修改的地方只有namespace,根据实际情况定义</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default        <span class="token comment">#根据实际环境设定namespace,下面类同</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumeclaims"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storage.k8s.io"</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storageclasses"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"events"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"endpoints"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> run<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"endpoints"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3-创建NFS资源的StorageClass"><a href="#3-创建NFS资源的StorageClass" class="headerlink" title="3.创建NFS资源的StorageClass"></a>3.创建NFS资源的StorageClass</h6><p><strong>nfs-StorageClass.yaml</strong> </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> managed<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> qgg<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage <span class="token comment">#这里的名称要和provisioner配置文件中的环境变量PROVISIONER_NAME保持一致parameters:  archiveOnDelete: "false"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="4-创建NFS-provisioner"><a href="#4-创建NFS-provisioner" class="headerlink" title="4.创建NFS provisioner"></a>4.创建NFS provisioner</h6><p><strong>nfs-provisioner.yaml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token comment">#与RBAC文件中的namespace保持一致</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> Recreate  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner          <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/external_storage/nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">:</span>latest          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /persistentvolumes          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PROVISIONER_NAME              <span class="token key atrule">value</span><span class="token punctuation">:</span> qgg<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage  <span class="token comment">#provisioner名称,请确保该名称与 nfs-StorageClass.yaml文件中的provisioner名称保持一致</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_SERVER              <span class="token key atrule">value</span><span class="token punctuation">:</span> 172.16.155.227   <span class="token comment">#NFS Server IP地址</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_PATH                <span class="token key atrule">value</span><span class="token punctuation">:</span> /data/volumes    <span class="token comment">#NFS挂载卷</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.16.155.227  <span class="token comment">#NFS Server IP地址</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/volumes     <span class="token comment">#NFS 挂载卷</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、创建测试pod-检查是否部署成功"><a href="#五、创建测试pod-检查是否部署成功" class="headerlink" title="五、创建测试pod,检查是否部署成功"></a>五、创建测试pod,检查是否部署成功</h3><h6 id="1-Pod-PVC"><a href="#1-Pod-PVC" class="headerlink" title="1.Pod+PVC"></a>1.Pod+PVC</h6><p>创建PVC</p><p><strong>test-claim.yaml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>claim  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">volume.beta.kubernetes.io/storage-class</span><span class="token punctuation">:</span> <span class="token string">"managed-nfs-storage"</span>   <span class="token comment">#与nfs-StorageClass.yaml metadata.name保持一致</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>确保PVC状态为Bound</strong></p><pre class="line-numbers language-none"><code class="language-none">[root@k8s-master-155-221 deploy]# kubectl get pvcNAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGEtest-claim   Bound    pvc-aae2b7fa-377b-11ea-87ad-525400512eca   1Mi        RWX            managed-nfs-storage   2m48s[root@k8s-master-155-221 deploy]# kubectl get pvNAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS          REASON   AGEpvc-aae2b7fa-377b-11ea-87ad-525400512eca   1Mi        RWX            Delete           Bound    default/test-claim   managed-nfs-storage            4m13s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建测试pod,查看是否可以正常挂载</strong></p><p><strong>test-pod.yaml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.24</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"/bin/sh"</span>    <span class="token key atrule">args</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"-c"</span>      <span class="token punctuation">-</span> <span class="token string">"touch /mnt/SUCCESS &amp;&amp; exit 0 || exit 1"</span>   <span class="token comment">#创建一个SUCCESS文件后退出</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pvc        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/mnt"</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> <span class="token string">"Never"</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pvc      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>claim  <span class="token comment">#与PVC名称保持一致</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>检查结果:</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-keepalived-155-227 ~]# ll /data/volumes/default-test-claim-pvc-aae2b7fa-377b-11ea-87ad-525400512eca/   #文件规则是按照${namespace}-${pvcName}-${pvName}创建的总用量 0-rw-r--r-- 1 root root 0 2020-01-15 17:51 SUCCESS  #下面有一个 SUCCESS 的文件，证明我们上面的验证是成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="2-StateFulDet-volumeClaimTemplates自动创建PV"><a href="#2-StateFulDet-volumeClaimTemplates自动创建PV" class="headerlink" title="2.StateFulDet+volumeClaimTemplates自动创建PV"></a>2.StateFulDet+volumeClaimTemplates自动创建PV</h6><p><strong>创建无头服务及statefulset</strong></p><p><strong>nginx-statefulset.yaml</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>headless  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> web  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None   <span class="token comment">#注意此处的值,None表示无头服务</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token comment">#两个副本</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> ikubernetes/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> web        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> www      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>        <span class="token key atrule">volume.beta.kubernetes.io/storage-class</span><span class="token punctuation">:</span> <span class="token string">"managed-nfs-storage"</span>   <span class="token comment">#managed-nfs-storage为我们创建的storage-class名称</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>检查结果:</strong></p><p><strong>集群节点上</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> [root@k8s-master-155-221 classStorage]#kubectl delete -f nginx-statefulset.yaml [root@k8s-master-155-221 classStorage]# kubectl get pods -l app=nginx  #检查pod状态NAME    READY   STATUS    RESTARTS   AGEweb-0   1/1     Running   0          115mweb-1   1/1     Running   0          114m[root@k8s-master-155-221 classStorage]# kubectl get pvc #查看PVCNAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGEtest-claim   Bound    pvc-aae2b7fa-377b-11ea-87ad-525400512eca   1Mi        RWX            managed-nfs-storage   19hwww-web-0    Bound    pvc-4d7e342a-3810-11ea-87ad-525400512eca   1Gi        RWO            managed-nfs-storage   115mwww-web-1    Bound    pvc-5431c8ba-3810-11ea-87ad-525400512eca   1Gi        RWO            managed-nfs-storage   115m[root@k8s-master-155-221 classStorage]# kubectl get pv #查看PVNAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS          REASON   AGEpvc-4d7e342a-3810-11ea-87ad-525400512eca   1Gi        RWO            Delete           Bound    default/www-web-0    managed-nfs-storage            115mpvc-5431c8ba-3810-11ea-87ad-525400512eca   1Gi        RWO            Delete           Bound    default/www-web-1    managed-nfs-storage            115mpvc-aae2b7fa-377b-11ea-87ad-525400512eca   1Mi        RWX            Delete           Bound    default/test-claim   managed-nfs-storage            19h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NFS Server上:</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@nginx-keepalived-155-227 ~]# cd /data/volumes/[root@nginx-keepalived-155-227 volumes]# ll  #注意目录的命名格式总用量 0drwxrwxrwx 2 root root 21 2020-01-15 17:51 default-test-claim-pvc-aae2b7fa-377b-11ea-87ad-525400512ecadrwxrwxrwx 2 root root  6 2020-01-16 11:28 default-www-web-0-pvc-4d7e342a-3810-11ea-87ad-525400512ecadrwxrwxrwx 2 root root  6 2020-01-16 11:28 default-www-web-1-pvc-5431c8ba-3810-11ea-87ad-525400512eca[root@nginx-keepalived-155-227 volumes]# echo "web-00" &gt; default-www-web-0-pvc-4d7e342a-3810-11ea-87ad-525400512eca/index.html #分别创建不同的index文件[root@nginx-keepalived-155-227 volumes]# echo "web-01" &gt; default-www-web-1-pvc-5431c8ba-3810-11ea-87ad-525400512eca/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>集群任意节点上:</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master-155-221 classStorage]# kubectl exec -it pod-cm-1 -- /bin/sh  #进入集群中任意pod中,解析nginx-headless 服务/ # nslookup nginx-headlessnslookup: can't resolve '(null)': Name does not resolveName:      nginx-headlessAddress 1: 172.17.136.7 172-17-136-7.nginx-headless.default.svc.cluster.local  #可以看到有两个地址Address 2: 172.17.248.5 172-17-248-5.nginx-headless.default.svc.cluster.local[root@k8s-master-155-221 classStorage]# curl 172.17.248.5 #分别访问一下查看结果web-00[root@k8s-master-155-221 classStorage]# curl 172.17.136.7web-01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#对于statefulset我们可以通过添加/删除pod副本的数量,观察PV/PVC的状态及变化.</strong></p><h3 id="六、关于StorageClass回收策略对数据的影响"><a href="#六、关于StorageClass回收策略对数据的影响" class="headerlink" title="六、关于StorageClass回收策略对数据的影响"></a>六、关于StorageClass回收策略对数据的影响</h3><h6 id="1-第一种配置"><a href="#1-第一种配置" class="headerlink" title="1.第一种配置"></a>1.第一种配置</h6><pre class="line-numbers language-none"><code class="language-none">archiveOnDelete: "false"  reclaimPolicy: Delete   #默认没有配置,默认值为Delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>测试结果:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.pod删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用2.sc删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用3.删除PVC后,PV被删除且NFS Server对应数据被删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="2-第二种配置"><a href="#2-第二种配置" class="headerlink" title="2.第二种配置"></a>2.第二种配置</h6><pre class="line-numbers language-none"><code class="language-none">archiveOnDelete: "false"  reclaimPolicy: Retain  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>测试结果:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.pod删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用2.sc删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用3.删除PVC后,PV不会别删除,且状态由Bound变为Released,NFS Server对应数据被保留4.重建sc后,新建PVC会绑定新的pv,旧数据可以通过拷贝到新的PV中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3-第三种配置"><a href="#3-第三种配置" class="headerlink" title="3.第三种配置"></a>3.第三种配置</h6><pre class="line-numbers language-none"><code class="language-none">archiveOnDelete: "ture"  reclaimPolicy: Retain  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>结果:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.pod删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用2.sc删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用3.删除PVC后,PV不会别删除,且状态由Bound变为Released,NFS Server对应数据被保留4.重建sc后,新建PVC会绑定新的pv,旧数据可以通过拷贝到新的PV中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="4-第四种配置"><a href="#4-第四种配置" class="headerlink" title="4.第四种配置"></a>4.第四种配置</h6><pre class="line-numbers language-none"><code class="language-none">archiveOnDelete: "ture"  reclaimPolicy: Delete  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>结果:</strong></p><pre class="line-numbers language-none"><code class="language-none">1.pod删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用2.sc删除重建后数据依然存在,旧pod名称及数据依然保留给新pod使用3.删除PVC后,PV不会别删除,且状态由Bound变为Released,NFS Server对应数据被保留4.重建sc后,新建PVC会绑定新的pv,旧数据可以通过拷贝到新的PV中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结:除以第一种配置外,其他三种配置在PV/PVC被删除后数据依然保留</strong></p><h3 id="七、常见问题"><a href="#七、常见问题" class="headerlink" title="七、常见问题"></a>七、常见问题</h3><h6 id="1-如何设置默认的StorageClass"><a href="#1-如何设置默认的StorageClass" class="headerlink" title="1.如何设置默认的StorageClass"></a>1.如何设置默认的StorageClass</h6><p><strong>我们可以用 kubectl patch 命令来更新：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master-155-221 classStorage]# kubectl get sc  #查看当前sc NAME                  PROVISIONER       AGE managed-nfs-storage   qgg-nfs-storage   20h[root@k8s-master-155-221 classStorage]# kubectl patch storageclass managed-nfs-storage -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'  #设置managed-nfs-storage为默认后端存储storageclass.storage.k8s.io/managed-nfs-storage patched[root@k8s-master-155-221 classStorage]# kubectl get sc  #再次查看,注意是否有default标识NAME                            PROVISIONER       AGEmanaged-nfs-storage (default)   qgg-nfs-storage   20h[root@k8s-master-155-221 deploy]# kubectl patch storageclass managed-nfs-storage -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}' #取消默认存储后端storageclass.storage.k8s.io/managed-nfs-storage patched[root@k8s-master-155-221 deploy]# kubectl get scNAME                  PROVISIONER       AGEmanaged-nfs-storage   qgg-nfs-storage   20h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h6><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> managed<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">"storageclass.kubernetes.io/is-default-class"</span><span class="token punctuation">:</span> <span class="token string">"true"</span>   <span class="token comment">#添加此注释</span><span class="token key atrule">provisioner</span><span class="token punctuation">:</span> qgg<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage <span class="token comment">#or choose another name, must match deployment's env PROVISIONER_NAME'</span><span class="token key atrule">parameters</span><span class="token punctuation">:</span>  <span class="token key atrule">archiveOnDelete</span><span class="token punctuation">:</span> <span class="token string">"false"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-如何使用默认的StorageClass"><a href="#2-如何使用默认的StorageClass" class="headerlink" title="2.如何使用默认的StorageClass"></a>2.如何使用默认的StorageClass</h6><p> <strong>如果集群有一个默认的StorageClass能够满足我们的需求，那么剩下所有需要做的就是创建PersistentVolumeClaim(PVC)，剩下的都有默认的动态配置搞定，包括无需去指定storageClassName：</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypvc <span class="token key atrule">namespace</span><span class="token punctuation">:</span> testns<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> ReadWriteOnce <span class="token key atrule">resources</span><span class="token punctuation">:</span>   <span class="token key atrule">requests</span><span class="token punctuation">:</span>     <span class="token key atrule">storage</span><span class="token punctuation">:</span> 10Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3-修改默回收策略-默认为Delete"><a href="#3-修改默回收策略-默认为Delete" class="headerlink" title="3.修改默回收策略(默认为Delete)"></a>3.修改默回收策略(默认为Delete)</h6><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> managed<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage  <span class="token key atrule">annotations</span><span class="token punctuation">:</span><span class="token key atrule">provisioner</span><span class="token punctuation">:</span> qgg<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>storage <span class="token comment">#or choose another name, must match deployment's env PROVISIONER_NAME'</span><span class="token key atrule">parameters</span><span class="token punctuation">:</span>  <span class="token key atrule">archiveOnDelete</span><span class="token punctuation">:</span> <span class="token string">"ture"</span> <span class="token comment">#暂时不清楚该值对回收策略产生什么影响</span><span class="token key atrule">reclaimPolicy</span><span class="token punctuation">:</span> Retain   <span class="token comment">#只有NFS 和hostPth支持两种回收策略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="4-能过删除-关闭默认的StorageClass"><a href="#4-能过删除-关闭默认的StorageClass" class="headerlink" title="4.能过删除/关闭默认的StorageClass"></a>4.能过删除/关闭默认的StorageClass</h6><pre class="line-numbers language-none"><code class="language-none">不能删除默认的StorageClass，因为它是作为集群的add-on安装的，如果它被删除，会被重新安装。当然，可以停掉默认的StorageClass行为，通过删除annotation：storageclass.beta.kubernetes.io/is-default-class,或者设置为false。如果没有StorageClass对象标记默认的annotation，那么PersistentVolumeClaim对象（在不指定StorageClass情况下）将不自动触发动态配置。相反，它们将回到绑定可用的*PersistentVolume(PV)*的状态。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="5-当删除PersistentVolumeClaim-PVC-会发生什么"><a href="#5-当删除PersistentVolumeClaim-PVC-会发生什么" class="headerlink" title="5.当删除PersistentVolumeClaim(PVC)会发生什么"></a>5.当删除PersistentVolumeClaim(PVC)会发生什么</h6><pre class="line-numbers language-none"><code class="language-none">如果一个卷是动态配置的卷，则默认的回收策略为“删除”。这意味着，在默认的情况下，当PVC被删除时，基础的PV和对应的存储也会被删除。如果需要保留存储在卷上的数据，则必须在PV被设置之后将回收策略从delete更改为retain。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考文档:<a href="https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client">https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client</a></p><blockquote><p>issue: <a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/issues/25">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/issues/25</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang pprof 实操</title>
      <link href="/2021/10/03/pprof/"/>
      <url>/2021/10/03/pprof/</url>
      
        <content type="html"><![CDATA[<p>pprof是一个好工具，但掌握好工具的正确用法，才能发挥好工具的威力，不然就算你手里有屠龙刀，也成不了天下第一，本文就是带你用pprof定位内存泄露问题。</p><p>关于Go的内存泄露有这么一句话不知道你听过没有：</p><blockquote><p>10次内存泄露，有9次是goroutine泄露。</p></blockquote><p>我所解决的问题，也是goroutine泄露导致的内存泄露，所以<strong>这篇文章主要介绍Go程序的goroutine泄露，掌握了如何定位和解决goroutine泄露，就掌握了内存泄露的大部分场景</strong>。</p><blockquote><p>本文草稿最初数据都是生产坏境数据，为了防止敏感内容泄露，全部替换成了demo数据，demo的数据比生产环境数据简单多了，更适合入门理解，有助于掌握pprof。</p></blockquote><hr><h1 id="go-pprof基本知识"><a href="#go-pprof基本知识" class="headerlink" title="go pprof基本知识"></a>go pprof基本知识</h1><p>定位goroutine泄露会使用到pprof，pprof是Go的性能工具，在开始介绍内存泄露前，先简单介绍下pprof的基本使用，更详细的使用给大家推荐了资料。</p><h2 id="什么是pprof"><a href="#什么是pprof" class="headerlink" title="什么是pprof"></a>什么是pprof</h2><p>pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等，当需要性能调优或者定位Bug时候，这些记录的信息是相当重要。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用pprof有多种方式，Go已经现成封装好了1个：<code>net/http/pprof</code>，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务，能够通过浏览器和命令行2种方式获取运行数据。</p><p>看个最简单的pprof的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 开启pprof，监听请求</span>ip <span class="token operator">:=</span> <span class="token string">"0.0.0.0:6060"</span><span class="token keyword">if</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"start pprof failed on %s\n"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="浏览器方式"><a href="#浏览器方式" class="headerlink" title="浏览器方式"></a>浏览器方式</h3><p><img src="https://image.fyxemmmm.cn/blog/images/pp1.png"></p><p>输入网址<code>ip:port/debug/pprof/</code>打开pprof主页，从上到下依次是<strong>5类profile信息</strong>：</p><ol><li><strong>block</strong>：goroutine的阻塞信息，本例就截取自一个goroutine阻塞的demo，但block为0，没掌握block的用法</li><li><strong>goroutine</strong>：所有goroutine的信息，下面的<code>full goroutine stack dump</code>是输出所有goroutine的调用栈，是goroutine的debug=2，后面会详细介绍。</li><li><strong>heap</strong>：堆内存的信息</li><li><strong>mutex</strong>：锁的信息</li><li><strong>threadcreate</strong>：线程信息</li></ol><p>这篇文章我们主要关注goroutine和heap，这两个都会打印调用栈信息，goroutine里面还会包含goroutine的数量信息，heap则是内存分配信息，本文用不到的地方就不展示了，最后推荐几篇文章大家去看。</p><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>当连接在服务器终端上的时候，是没有浏览器可以使用的，Go提供了命令行的方式，能够获取以上5类信息，这种方式用起来更方便。</p><p>使用命令<code>go tool pprof url</code>可以获取指定的profile文件，此命令会发起http请求，然后下载数据到本地，之后进入交互式模式，就像gdb一样，可以使用命令查看运行信息，以下是5类请求的方式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30sgo tool pprof http://localhost:6060/debug/pprof/profile   # 30-second CPU profilego tool pprof http://localhost:6060/debug/pprof/profile?seconds=120     # wait 120s# 下载heap profilego tool pprof http://localhost:6060/debug/pprof/heap      # heap profile# 下载goroutine profilego tool pprof http://localhost:6060/debug/pprof/goroutine # goroutine profile# 下载block profilego tool pprof http://localhost:6060/debug/pprof/block     # goroutine blocking profile# 下载mutex profilego tool pprof http://localhost:6060/debug/pprof/mutex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>pprof/demo.go</code>太简单了，如果去获取内存profile，几乎获取不到什么，换一个Demo进行内存profile的展示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 展示内存增长和pprof，并不是泄露</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span><span class="token string">"os"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token comment">// 运行一段时间：fatal error: runtime: out of memory</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 开启pprof</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ip <span class="token operator">:=</span> <span class="token string">"0.0.0.0:6060"</span><span class="token keyword">if</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"start pprof failed on %s\n"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>tick <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">for</span> <span class="token keyword">range</span> tick <span class="token punctuation">{</span>buf <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个demo会不断的申请内存，把它编译运行起来，然后执行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ go tool pprof http://localhost:6060/debug/pprof/heapFetching profile over HTTP from http://localhost:6060/debug/pprof/heapSaved profile in /home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz       //&lt;--- 下载到的内存profile文件File: demo // 程序名称Build ID: a9069a125ee9c0df3713b2149ca859e8d4d11d5aType: inuse_spaceTime: May 16, 2019 at 8:55pm (CST)Entering interactive mode (type "help" for commands, "o" for options)(pprof)(pprof)(pprof) help  // 使用help打印所有可用命令  Commands:    callgrind        Outputs a graph in callgrind format    comments         Output all profile comments    disasm           Output assembly listings annotated with samples    dot              Outputs a graph in DOT format    eog              Visualize graph through eog    evince           Visualize graph through evince    gif              Outputs a graph image in GIF format    gv               Visualize graph through gv    kcachegrind      Visualize report in KCachegrind    list             Output annotated source for functions matching regexp    pdf              Outputs a graph in PDF format    peek             Output callers/callees of functions matching regexp    png              Outputs a graph image in PNG format    proto            Outputs the profile in compressed protobuf format    ps               Outputs a graph in PS format    raw              Outputs a text representation of the raw profile    svg              Outputs a graph in SVG format    tags             Outputs all tags in the profile    text             Outputs top entries in text form    top              Outputs top entries in text form    topproto         Outputs top entries in compressed protobuf format    traces           Outputs all profile samples in text form    tree             Outputs a text rendering of call graph    web              Visualize graph through web browser    weblist          Display annotated source in a web browser    o/options        List options and their current values    quit/exit/^D     Exit pprof        ....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上信息我们只关注2个地方：</p><ol><li>下载得到的文件：<code>/home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</code>，这其中包含了程序名<code>demo</code>，profile类型<code>alloc</code>已分配的内存，<code>inuse</code>代表使用中的内存。</li><li><code>help</code>可以获取帮助，最先会列出支持的命令，想掌握pprof，要多看看，多尝试。</li></ol><p>关于命令，本文只会用到3个，我认为也是最常用的：<code>top</code>、<code>list</code>、<code>traces</code>，分别介绍一下。</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>按指标大小列出前10个函数，比如内存是按内存占用多少，CPU是按执行时间多少。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">(pprof) topShowing nodes accounting for 814.62MB, 100% of 814.62MB total      flat  flat%   sum%        cum   cum%  814.62MB   100%   100%   814.62MB   100%  main.main         0     0%   100%   814.62MB   100%  runtime.main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>top会列出5个统计数据：</p><ul><li>flat: 本函数占用的内存量。</li><li>flat%: 本函数内存占使用中内存总量的百分比。</li><li>sum%: 前面每一行flat百分比的和，比如第2行虽然的100% 是 100% + 0%。</li><li>cum: 是累计量，加入main函数调用了函数f，函数f占用的内存量，也会记进来。</li><li>cum%: 是累计量占总量的百分比。</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>查看某个函数的代码，以及该函数每行代码的指标信息，如果函数名不明确，会进行模糊匹配，比如<code>list main</code>会列出<code>main.main</code>和<code>runtime.main</code>。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">(pprof) list main.main  // 精确列出函数Total: 814.62MBROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go  814.62MB   814.62MB (flat, cum)   100% of Total         .          .     20:}()         .          .     21:         .          .     22:tick := time.Tick(time.Second / 100)         .          .     23:var buf []byte         .          .     24:for range tick {  814.62MB   814.62MB     25:buf = append(buf, make([]byte, 1024*1024)...)         .          .     26:}         .          .     27:}         .          .     28:(pprof) list main  // 匹配所有函数名带main的函数Total: 814.62MBROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go  814.62MB   814.62MB (flat, cum)   100% of Total         .          .     20:}()         .          .     21:..... // 省略几行         .          .     28:ROUTINE ======================== runtime.main in /usr/lib/go-1.10/src/runtime/proc.go         0   814.62MB (flat, cum)   100% of Total         .          .    193:// A program compiled with -buildmode=c-archive or c-shared..... // 省略几行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在<code>main.main</code>中的第25行占用了814.62MB内存，左右2个数据分别是flat和cum，含义和top中解释的一样。</p><h4 id="traces"><a href="#traces" class="headerlink" title="traces"></a>traces</h4><p>打印所有调用栈，以及调用栈的指标信息。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">(pprof) tracesFile: demo2Type: inuse_spaceTime: May 16, 2019 at 7:08pm (CST)-----------+-------------------------------------------------------     bytes:  813.46MB  813.46MB   main.main             runtime.main-----------+-------------------------------------------------------     bytes:  650.77MB         0   main.main             runtime.main....... // 省略几十行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个<code>- - - - -</code> 隔开的是一个调用栈，能看到<code>runtime.main</code>调用了<code>main.main</code>，并且<code>main.main</code>中占用了813.46MB内存。</p><p><strong>其他的profile操作和内存是类似的</strong></p><hr><h1 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h1><p>内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。</p><p>Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。</p><h1 id="怎么发现内存泄露"><a href="#怎么发现内存泄露" class="headerlink" title="怎么发现内存泄露"></a>怎么发现内存泄露</h1><p>在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：</p><ol><li><strong>监控工具</strong>：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。</li><li><strong>go pprof</strong>：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。</li></ol><p>这2种方式分别介绍一下。</p><h2 id="监控工具查看进程内在占用情况"><a href="#监控工具查看进程内在占用情况" class="headerlink" title="监控工具查看进程内在占用情况"></a>监控工具查看进程内在占用情况</h2><p><strong>如果使用云平台部署Go程序</strong>，云平台都提供了内存查看的工具，可以查看OS的内存占用情况和某个进程的内存占用情况，比如阿里云，我们在1个云主机上只部署了1个Go服务，所以OS的内存占用情况，基本是也反映了进程内存占用情况，OS内存占用情况如下，可以看到<strong>随着时间的推进，内存的占用率在不断的提高，这是内存泄露的最明显现象</strong>：</p><p><img src="https://image.fyxemmmm.cn/blog/images/pp2.png"></p><p><strong>如果没有云平台这种内存监控工具，可以制作一个简单的内存记录工具。</strong></p><p>1、建立一个脚本<code>prog_mem.sh</code>，获取进程占用的物理内存情况，脚本内容如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/bashprog_name="your_programe_name"prog_mem=$(pidstat  -r -u -h -C $prog_name |awk 'NR==4{print $12}')time=$(date "+%Y-%m-%d %H:%M:%S")echo $time"\tmemory(Byte)\t"$prog_mem &gt;&gt;~/record/prog_mem.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、然后使用<code>crontab</code>建立定时任务，每分钟记录1次。使用<code>crontab -e</code>编辑crontab配置，在最后增加1行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">*/1 * * * * ~/record/prog_mem.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>脚本输出的内容保存在<code>prog_mem.log</code>，只要大体浏览一下就可以发现内存的增长情况，判断是否存在内存泄露。如果需要可视化，可以直接黏贴<code>prog_mem.log</code>内容到Excel等表格工具，绘制内存占用图。</p><p><img src="https://image.fyxemmmm.cn/blog/images/pp3.png"></p><h2 id="go-pprof发现存在内存问题"><a href="#go-pprof发现存在内存问题" class="headerlink" title="go pprof发现存在内存问题"></a>go pprof发现存在内存问题</h2><ol><li><strong>内存profiling记录的是堆内存分配的情况，以及调用栈信息</strong>，并不是进程完整的内存情况，猜测这也是在go pprof中称为heap而不是memory的原因。</li><li><strong>栈内存的分配是在调用栈结束后会被释放的内存，所以并不在内存profile中</strong>。</li><li>内存profiling是基于抽样的，默认是每1000次堆内存分配，执行1次profile记录。</li><li>因为内存profiling是基于抽样和它跟踪的是已分配的内存，而不是使用中的内存，（比如有些内存已经分配，看似使用，但实际以及不使用的内存，比如内存泄露的那部分），所以<strong>不能使用内存profiling衡量程序总体的内存使用情况</strong>。</li><li><strong>使用内存profiling不能够发现内存泄露</strong>。</li></ol><p>基于目前对heap的认知，我有2个观点：</p><ol><li><strong>heap能帮助我们发现内存问题，但不一定能发现内存泄露问题</strong>，这个看法与Dave是类似的。heap记录了内存分配的情况，我们能通过heap观察内存的变化，增长与减少，内存主要被哪些代码占用了，程序存在内存问题，这只能说明内存有使用不合理的地方，但并不能说明这是内存泄露。</li><li><strong>heap在帮助定位内存泄露原因上贡献的力量微乎其微</strong>。如第一条所言，能通过heap找到占用内存多的位置，但这个位置通常不一定是内存泄露，就算是内存泄露，也只是内存泄露的结果，并不是真正导致内存泄露的根源。</li></ol><p>接下来，我介绍怎么用heap发现问题，然后再解释为什么heap几乎不能定位内存泄露的根因。</p><h3 id="怎么用heap发现内存问题"><a href="#怎么用heap发现内存问题" class="headerlink" title="怎么用heap发现内存问题"></a>怎么用heap发现内存问题</h3><p>使用pprof的heap能够获取程序运行时的内存信息，在程序平稳运行的情况下，每个一段时间使用heap获取内存的profile，<strong>然后使用<code>base</code>能够对比两个profile文件的差别，就像<code>diff</code>命令一样显示出增加和减少的变化</strong>，使用一个简单的demo来说明heap和base的使用，依然使用demo2进行展示。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 展示内存增长和pprof，并不是泄露</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span><span class="token string">"os"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token comment">// 运行一段时间：fatal error: runtime: out of memory</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 开启pprof</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ip <span class="token operator">:=</span> <span class="token string">"0.0.0.0:6060"</span><span class="token keyword">if</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"start pprof failed on %s\n"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>tick <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">for</span> <span class="token keyword">range</span> tick <span class="token punctuation">{</span>buf <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面代码运行起来，执行以下命令获取profile文件，Ctrl-D退出，1分钟后再获取1次。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">go tool pprof http://localhost:6060/debug/pprof/heap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我已经获取到了两个profile文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ lspprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gzpprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>base</code>把001文件作为基准，然后用002和001对比，先执行<code>top</code>看<code>top</code>的对比，然后执行<code>list main</code>列出<code>main</code>函数的内存对比，结果如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ go tool pprof -base pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gzFile: demo2Type: inuse_spaceTime: May 14, 2019 at 2:33pm (CST)Entering interactive mode (type "help" for commands, "o" for options)(pprof)(pprof)(pprof) topShowing nodes accounting for 970.34MB, 32.30% of 3003.99MB total      flat  flat%   sum%        cum   cum%  970.34MB 32.30% 32.30%   970.34MB 32.30%  main.main   // 看这         0     0% 32.30%   970.34MB 32.30%  runtime.main(pprof)(pprof)(pprof) list main.mainTotal: 2.93GBROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go  970.34MB   970.34MB (flat, cum) 32.30% of Total         .          .     20:}()         .          .     21:         .          .     22:tick := time.Tick(time.Second / 100)         .          .     23:var buf []byte         .          .     24:for range tick {  970.34MB   970.34MB     25:buf = append(buf, make([]byte, 1024*1024)...) // 看这         .          .     26:}         .          .     27:}         .          .     28:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>top</code>列出了<code>main.main</code>和<code>runtime.main</code>，<code>main.main</code>就是我们编写的main函数，<code>runtime.main</code>是runtime包中的main函数，也就是所有main函数的入口。</p><p><code>top</code>显示<code>main.main</code> 第2次内存占用，比第1次内存占用多了970.34MB。</p><p><code>list main.main</code>告诉了我们增长的内存都在这一行：</p><pre class="line-numbers language-none"><code class="language-none">buf = append(buf, make([]byte, 1024*1024)...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>001和002 profile的文件不进去看了，你本地测试下计算差值，绝对是刚才对比出的970.34MB。</p><h3 id="heap“不能”定位内存泄露"><a href="#heap“不能”定位内存泄露" class="headerlink" title="heap“不能”定位内存泄露"></a>heap“不能”定位内存泄露</h3><p>heap能显示内存的分配情况，以及哪行代码占用了多少内存，我们能轻易的找到占用内存最多的地方，如果这个地方的数值还在不断怎大，基本可以认定这里就是内存泄露的位置。</p><p>曾想按图索骥，从内存泄露的位置，根据调用栈向上查找，总能找到内存泄露的原因，这种方案看起来是不错的，但实施起来却找不到内存泄露的原因，结果是事半功倍。</p><p>原因在于一个Go程序，其中有大量的goroutine，这其中的调用关系也许有点复杂，也许内存泄露是在某个三方包里。举个栗子，比如下面这幅图，每个椭圆代表1个goroutine，其中的数字为编号，箭头代表调用关系。heap profile显示g111（最下方标红节点）这个协程的代码出现了泄露，任何一个从g101到g111的调用路径都可能造成了g111的内存泄露，有2类可能：</p><ol><li>该goroutine只调用了少数几次，但消耗了大量的内存，说明每个goroutine调用都消耗了不少内存，<strong>内存泄露的原因基本就在该协程内部</strong>。</li><li>该goroutine的调用次数非常多，虽然每个协程调用过程中消耗的内存不多，但该调用路径上，协程数量巨大，造成消耗大量的内存，并且这些goroutine由于某种原因无法退出，占用的内存不会释放，<strong>内存泄露的原因在到g111调用路径上某段代码实现有问题，造成创建了大量的g111</strong>。</li></ol><p><strong>第2种情况，就是goroutine泄露，这是通过heap无法发现的，所以heap在定位内存泄露这件事上，发挥的作用不大</strong>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/pp4.png"></p><hr><h1 id="goroutine泄露怎么导致内存泄露"><a href="#goroutine泄露怎么导致内存泄露" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h1><h2 id="什么是goroutine泄露"><a href="#什么是goroutine泄露" class="headerlink" title="什么是goroutine泄露"></a>什么是goroutine泄露</h2><p>如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p><blockquote><p>提前思考：什么会导致goroutine无法退出/阻塞？</p></blockquote><h2 id="goroutine泄露怎么导致内存泄露-1"><a href="#goroutine泄露怎么导致内存泄露-1" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h2><p>每个goroutine占用2KB内存，泄露1百万goroutine至少泄露<code>2KB * 1000000 = 2GB</code>内存，为什么说至少呢？</p><p>goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p><p>所以goroutine泄露有2种方式造成内存泄露：</p><ol><li>goroutine本身的栈所占用的空间造成内存泄露。</li><li>goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。</li></ol><p>如果不知道何时停止一个goroutine，这个goroutine就是潜在的内存泄露：</p><h2 id="怎么确定是goroutine泄露引发的内存泄露"><a href="#怎么确定是goroutine泄露引发的内存泄露" class="headerlink" title="怎么确定是goroutine泄露引发的内存泄露"></a>怎么确定是goroutine泄露引发的内存泄露</h2><p><strong>判断依据：在节点正常运行的情况下，隔一段时间获取goroutine的数量，如果后面获取的那次，某些goroutine比前一次多，如果多获取几次，是持续增长的，就极有可能是goroutine泄露</strong>。</p><p>goroutine导致内存泄露的demo：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// goroutine泄露导致内存泄露</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span><span class="token string">"os"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 开启pprof</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ip <span class="token operator">:=</span> <span class="token string">"0.0.0.0:6060"</span><span class="token keyword">if</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"start pprof failed on %s\n"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>outCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment">// 死代码，永不读取</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token punctuation">{</span><span class="token operator">&lt;-</span>outCh<span class="token punctuation">}</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 每s起100个goroutine，goroutine会阻塞，不释放内存</span>tick <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span>i <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token keyword">range</span> tick <span class="token punctuation">{</span>i<span class="token operator">++</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token function">alloc1</span><span class="token punctuation">(</span>outCh<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">alloc1</span><span class="token punctuation">(</span>outCh <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">alloc2</span><span class="token punctuation">(</span>outCh<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">alloc2</span><span class="token punctuation">(</span>outCh <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"alloc-fm exit"</span><span class="token punctuation">)</span><span class="token comment">// 分配内存，假用一下</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"alloc done"</span><span class="token punctuation">)</span>outCh <span class="token operator">&lt;-</span> <span class="token number">0</span> <span class="token comment">// 53行</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并运行以上代码，然后使用<code>go tool pprof</code>获取gorourine的profile文件。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">go tool pprof http://localhost:6060/debug/pprof/goroutine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>已经通过pprof命令获取了2个goroutine的profile文件:</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ls/home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz/home/ubuntu/pprof/pprof.leak_demo.goroutine.002.pb.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同heap一样，我们可以使用<code>base</code>对比2个goroutine profile文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$go tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gzFile: leak_demoType: goroutineTime: May 16, 2019 at 2:44pm (CST)Entering interactive mode (type "help" for commands, "o" for options)(pprof)(pprof) topShowing nodes accounting for 20312, 100% of 20312 total      flat  flat%   sum%        cum   cum%     20312   100%   100%      20312   100%  runtime.gopark         0     0%   100%      20312   100%  main.alloc2         0     0%   100%      20312   100%  main.alloc2.func1         0     0%   100%      20312   100%  runtime.chansend         0     0%   100%      20312   100%  runtime.chansend1         0     0%   100%      20312   100%  runtime.goparkunlock(pprof)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到运行到<code>runtime.gopark</code>的goroutine数量增加了20312个。再通过002文件，看一眼执行到<code>gopark</code>的goroutine数量，即挂起的goroutine数量：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">go tool pprof pprof.leak_demo.goroutine.002.pb.gzFile: leak_demoType: goroutineTime: May 16, 2019 at 2:47pm (CST)Entering interactive mode (type "help" for commands, "o" for options)(pprof) topShowing nodes accounting for 24330, 100% of 24331 totalDropped 32 nodes (cum &lt;= 121)      flat  flat%   sum%        cum   cum%     24330   100%   100%      24330   100%  runtime.gopark         0     0%   100%      24326   100%  main.alloc2         0     0%   100%      24326   100%  main.alloc2.func1         0     0%   100%      24326   100%  runtime.chansend         0     0%   100%      24326   100%  runtime.chansend1         0     0%   100%      24327   100%  runtime.goparkunlock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示有24330个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</p><p>是什么导致如此多的goroutine被挂起而无法退出？接下来就看怎么定位goroutine泄露。</p><hr><h1 id="定位goroutine泄露的2种方法"><a href="#定位goroutine泄露的2种方法" class="headerlink" title="定位goroutine泄露的2种方法"></a>定位goroutine泄露的2种方法</h1><p>使用pprof有2种方式，一种是web网页，一种是<code>go tool pprof</code>命令行交互，这两种方法查看goroutine都支持，但有轻微不同，也有各自的优缺点。</p><p>我们先看Web的方式，再看命令行交互的方式，这两种都很好使用，结合起来用也不错。</p><h2 id="Web可视化查看"><a href="#Web可视化查看" class="headerlink" title="Web可视化查看"></a>Web可视化查看</h2><p>Web方式适合web服务器的端口能访问的情况，使用起来方便，有2种方式：</p><ol><li><strong>查看某条调用路径上，当前阻塞在此goroutine的数量</strong></li><li>查看所有goroutine的运行栈（调用路径），可以<strong>显示阻塞在此的时间</strong></li></ol><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>url请求中设置debug=1：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http://ip:port/debug/pprof/goroutine?debug=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><img src="https://image.fyxemmmm.cn/blog/images/pp5.png"></p><p>看起来密密麻麻的，其实简单又十分有用，看上图标出来的部分，手机上图看起来可能不方便，那就放大图片，或直接看下面各字段的含义：</p><ol><li><code>goroutine profile: total 32023</code>：32023是<strong>goroutine的总数量</strong>，</li><li><code>32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 ...</code>：32015代表当前有32015个goroutine运行这个调用栈，并且停在相同位置，@后面的十六进制，现在用不到这个数据，所以暂不深究了。</li><li>下面是当前goroutine的<strong>调用栈</strong>，列出了<strong>函数和所在文件的行数，这个行数对定位很有帮助</strong>，如下：</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 0x6d8559 0x6d831b 0x45abe1#0x6d8558main.alloc2.func1+0xf8/home/ubuntu/heap/leak_demo.go:53#0x6d831amain.alloc2+0x2a/home/ubuntu/heap/leak_demo.go:54<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据上面的提示，就能判断32015个goroutine运行到<code>leak_demo.go</code>的53行：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">alloc2</span><span class="token punctuation">(</span>outCh <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"alloc-fm exit"</span><span class="token punctuation">)</span><span class="token comment">// 分配内存，假用一下</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"alloc done"</span><span class="token punctuation">)</span>outCh <span class="token operator">&lt;-</span> <span class="token number">0</span> <span class="token comment">// 53行</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阻塞的原因是outCh这个写操作无法完成，outCh是无缓冲的通道，并且由于以下代码是死代码，所以goroutine始终没有从outCh读数据，造成outCh阻塞，进而造成无数个alloc2的goroutine阻塞，形成内存泄露：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>    <span class="token operator">&lt;-</span>outCh<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>url请求中设置debug=2：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http://ip:port/debug/pprof/goroutine?debug=2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://image.fyxemmmm.cn/blog/images/pp6.png"></p><p>第2种方式和第1种方式是互补的，它可以看到每个goroutine的信息：</p><ol><li><code>goroutine 20 [chan send, 2 minutes]</code>：20是goroutine id，<code>[]</code>中是当前goroutine的状态，阻塞在写channel，并且阻塞了2分钟，长时间运行的系统，你能看到阻塞时间更长的情况。</li><li>同时，也可以看到调用栈，看当前执行停到哪了：<code>leak_demo.go</code>的53行，</li></ol><pre class="line-numbers language-none"><code class="language-none">goroutine 20 [chan send, 2 minutes]:main.alloc2.func1(0xc42015e060)/home/ubuntu/heap/leak_demo.go:53 +0xf9  // 这main.alloc2(0xc42015e060)/home/ubuntu/heap/leak_demo.go:54 +0x2bcreated by main.alloc1/home/ubuntu/heap/leak_demo.go:42 +0x3f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令行交互式方法"><a href="#命令行交互式方法" class="headerlink" title="命令行交互式方法"></a>命令行交互式方法</h2><p>Web的方法是简单粗暴，无需登录服务器，浏览器打开看看就行了。但就像前面提的，没有浏览器可访问时，命令行交互式才是最佳的方式，并且也是手到擒来，感觉比Web一样方便。</p><p>命令行交互式只有1种获取goroutine profile的方法，不像Web网页分<code>debug=1</code>和<code>debug=2</code>2中方式，并将profile文件保存到本地：</p><pre class="line-numbers language-none"><code class="language-none">// 注意命令没有`debug=1`，debug=1，加debug有些版本的go不支持$ go tool pprof http://0.0.0.0:6060/debug/pprof/goroutineFetching profile over HTTP from http://localhost:6061/debug/pprof/goroutineSaved profile in /home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz  // profile文件保存位置File: leak_demoType: goroutineTime: May 16, 2019 at 2:44pm (CST)Entering interactive mode (type "help" for commands, "o" for options)(pprof)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令行只需要掌握3个命令就好了。</p><ol><li><strong>top</strong>：显示正运行到某个函数goroutine的数量</li><li><strong>traces</strong>：显示所有goroutine的调用栈</li><li><strong>list</strong>：列出代码详细的信息。</li></ol><p>我们依然使用<code>leak_demo.go</code>这个demo，</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$  go tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gzFile: leak_demoType: goroutineTime: May 16, 2019 at 2:44pm (CST)Entering interactive mode (type "help" for commands, "o" for options)(pprof)(pprof)(pprof) topShowing nodes accounting for 20312, 100% of 20312 total      flat  flat%   sum%        cum   cum%     20312   100%   100%      20312   100%  runtime.gopark         0     0%   100%      20312   100%  main.alloc2         0     0%   100%      20312   100%  main.alloc2.func1         0     0%   100%      20312   100%  runtime.chansend         0     0%   100%      20312   100%  runtime.chansend1         0     0%   100%      20312   100%  runtime.goparkunlock(pprof)(pprof) tracesFile: leak_demoType: goroutineTime: May 16, 2019 at 2:44pm (CST)-----------+-------------------------------------------------------     20312   runtime.gopark             runtime.goparkunlock             runtime.chansend             runtime.chansend1 // channel发送             main.alloc2.func1 // alloc2中的匿名函数             main.alloc2-----------+-------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接看traces命令，traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数<code>alloc2.func1</code>调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出<code>alloc2.func1</code>的代码，显示有20312个goroutine阻塞在53行：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">(pprof) list main.alloc2.func1Total: 20312ROUTINE ======================== main.alloc2.func1 in /home/ubuntu/heap/leak_demo.go         0      20312 (flat, cum)   100% of Total         .          .     48:// 分配内存，假用一下         .          .     49:buf := make([]byte, 1024*1024*10)         .          .     50:_ = len(buf)         .          .     51:fmt.Println("alloc done")         .          .     52:         .      20312     53:outCh &lt;- 0  // 看这         .          .     54:}()         .          .     55:}         .          .     56:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>友情提醒：使用list命令的前提是程序的源码在当前机器，不然可没法列出源码。</strong>服务器上，通常没有源码，那我们咋办呢？刚才介绍了Web查看的方式，那里会列出代码行数，我们可以使用<code>wget</code>下载网页：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ wget http://localhost:6060/debug/pprof/goroutine?debug=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载网页后，使用编辑器打开文件，使用关键字<code>main.alloc2.func1</code>进行搜索，找到与当前相同的调用栈，就可以看到该goroutine阻塞在哪一行了，不要忘记使用<code>debug=2</code>还可以看到阻塞了多久和原因，Web方式中已经介绍了，此处省略代码几十行。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="goroutine泄露的本质"><a href="#goroutine泄露的本质" class="headerlink" title="goroutine泄露的本质"></a>goroutine泄露的本质</h2><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p><h2 id="goroutine泄露的发现和定位"><a href="#goroutine泄露的发现和定位" class="headerlink" title="goroutine泄露的发现和定位"></a>goroutine泄露的发现和定位</h2><p>利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p><h2 id="goroutine泄露的场景"><a href="#goroutine泄露的场景" class="headerlink" title="goroutine泄露的场景"></a>goroutine泄露的场景</h2><p>泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p><ol><li>channel的读或者写：<ol><li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li><li>有缓冲的channel因为缓冲区满了，写操作阻塞</li><li>期待从channel读数据，结果没有goroutine写</li></ol></li><li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li></ol><h2 id="编码goroutine泄露的建议"><a href="#编码goroutine泄露的建议" class="headerlink" title="编码goroutine泄露的建议"></a>编码goroutine泄露的建议</h2><p>为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p><ol><li>goroutine如何退出？</li><li>是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？</li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pprof </tag>
            
            <tag> 性能诊断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux syscall 原理</title>
      <link href="/2021/09/30/linux-syscall-yuan-li/"/>
      <url>/2021/09/30/linux-syscall-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Syscall意义"><a href="#一、Syscall意义" class="headerlink" title="一、Syscall意义"></a>一、Syscall意义</h2><p>内核提供用户空间程序与内核空间进行交互的一套标准接口，这些接口让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。用户空间发生请求，内核空间负责执行，这些接口便是用户空间和内核空间共同识别的桥梁，这里提到两个字“受限”，是由于为了保证内核稳定性，而不能让用户空间程序随意更改系统，必须是内核对外开放的且满足权限的程序才能调用相应接口。</p><p>在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于每个系统调用都会有一个对应的系统调用号，比很多操作系统要少很多。</p><p>安全性与稳定性：内核驻留在受保护的地址空间，用户空间程序无法直接执行内核代码，也无法访问内核数据，通过系统调用</p><p>性能：Linux上下文切换时间很短，以及系统调用处理过程非常精简，内核优化得好，所以性能上往往比很多其他操作系统执行要好。</p><h2 id="二、Syscall查找方式"><a href="#二、Syscall查找方式" class="headerlink" title="二、Syscall查找方式"></a>二、Syscall查找方式</h2><p>这里以kill()方法为例子，来找一找kill()方法系统调用的过程。</p><p>Tips 1： 用户空间的方法<code>xxx</code>，对应系统调用层方法则是<code>sys_xxx</code>；<br>Tips 2： <code>unistd.h</code>文件记录着系统调用中断号的信息。</p><p>故用户空间<code>kill</code>方法则对应系统调用层便是<code>sys_kill</code>，这个方法去哪里找呢？从<code>/kernel/include/uapi/asm-generic/unistd.h</code>等还有很多<code>unistd.h</code>去慢慢查看，查看关键字<code>sys_kill</code>，便能看到下面几行：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* kernel/signal.c */</span><span class="token function">__SYSCALL</span><span class="token punctuation">(</span>__NR_kill<span class="token punctuation">,</span> sys_kill<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据这个能得到一丝线索，那就是kill对应的方法sys_kill位于<code>/kernel/signal.c</code>文件。</p><p>Tips 3： 宏定义SYSCALL_DEFINEx(xxx,…)，展开后对应的方法则是<code>sys_xxx</code>；<br>Tips 4： 方法参数的个数x，对应于SYSCALL_DEFINEx。</p><p><code>kill(int pid, int sig)</code>方法共两个参数，则对应方法于<code>SYSCALL_DEFINE2(kill,...)</code>，进入signal.c文件，再次搜索关键字，便能看到方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>kill<span class="token punctuation">,</span> <span class="token class-name">pid_t</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">siginfo</span> info<span class="token punctuation">;</span>    info<span class="token punctuation">.</span>si_signo <span class="token operator">=</span> sig<span class="token punctuation">;</span>    info<span class="token punctuation">.</span>si_errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>si_code <span class="token operator">=</span> SI_USER<span class="token punctuation">;</span>    info<span class="token punctuation">.</span>si_pid <span class="token operator">=</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>si_uid <span class="token operator">=</span> <span class="token function">from_kuid_munged</span><span class="token punctuation">(</span><span class="token function">current_user_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">current_uid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">kill_something_info</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code> 基本等价于 <code>asmlinkage long sys_kill(int pid, int sig)</code>，这里用的是基本等价，往下看会解释原因。</p><h4 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h4><p>比如kill命令, 有两个参数. 则可以直接在kernel目录下搜索 “SYSCALL_DEFINE2(kill”,即可直接找到,所有对应的Syscall方法位于signal.c</p><h2 id="三、Syscall流程"><a href="#三、Syscall流程" class="headerlink" title="三、Syscall流程"></a>三、Syscall流程</h2><p>Syscall是通过中断方式实现的，ARM平台上通过swi中断来实现系统调用，实现从用户态切换到内核态，发送软中断swi时，从中断向量表中查看跳转代码，其中异常向量表定义在文件/kernelarch/arm/kernel/entry-armv.S(汇编语言文件)。当执行系统调用时会根据系统调用号从系统调用表中来查看目标函数的入口地址，在calls.S文件中声明了入口地址信息。</p><p>总体流程：kill() -&gt; kill.S -&gt; swi陷入内核态 -&gt; 从sys_call_table查看到sys_kill -&gt; ret_fast_syscall -&gt; 回到用户态执行kill()下一行代码。 下面介绍部分核心流程：</p><p>3.1： 用户程序通过软中断swi指令切入内核态，执行vector_swi处的指令。<code>vector_swi</code>在文件<code>/kenel/arch/arm/kernel/entry-common.S</code>中定义，此处省略。像每一个异常处理程序一样，要做的第一件事当然就是保护现场了。紧接着是获得系统调用的系统调用号</p><p>3.2： 仍以kill()函数为例，来详细说说Syscall调用流程，用户空间kill()定义位于文件<code>kill.S</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;private/bionic_asm.h&gt;</span></span><span class="token function">ENTRY</span><span class="token punctuation">(</span>kill<span class="token punctuation">)</span>    mov     ip<span class="token punctuation">,</span> r7    ldr     r7<span class="token punctuation">,</span> <span class="token operator">=</span>__NR_kill    swi     #<span class="token number">0</span>    mov     r7<span class="token punctuation">,</span> ip    cmn     r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span>MAX_ERRNO <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    bxls    lr    neg     r0<span class="token punctuation">,</span> r0    b       __set_errno_internal<span class="token function">END</span><span class="token punctuation">(</span>kill<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当调用kill时, 系统先保存r7内容, 然后将__NR_kill值放入r7, 再执行swi软中断指令切换进内核态。</p><p>3.3： Linux内核中，每个Syscall都有唯一的系统调用号对应，kill的系统调用号为__NR_kill，用户空间的系统调用号定义于<code>/bionic/libc/kernel/uapi/asm-generic/unistd.h</code>，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__NR_kill</span> <span class="token expression"><span class="token punctuation">(</span>__NR_SYSCALL_BASE <span class="token operator">+</span> <span class="token number">37</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中__NR_SYSCALL_BASE=0，也就是__NR_kill系统调用号=37。</p><p>3.4： 在内核中有与系统调用号对应的系统调用表，定义在文件<code>/kernel/arch/arm/kernel/calls.S</code>，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 35 */</span>    <span class="token function">CALL</span><span class="token punctuation">(</span>sys_ni_syscall<span class="token punctuation">)</span>        <span class="token comment">/* was sys_ftime */</span>            <span class="token function">CALL</span><span class="token punctuation">(</span>sys_sync<span class="token punctuation">)</span>            <span class="token function">CALL</span><span class="token punctuation">(</span>sys_kill<span class="token punctuation">)</span>  <span class="token comment">//此处为37号</span>            <span class="token function">CALL</span><span class="token punctuation">(</span>sys_rename<span class="token punctuation">)</span>            <span class="token function">CALL</span><span class="token punctuation">(</span>sys_mkdir<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里可知37号系统调用对应sys_kill()，该方法所对应的函数声明在syscalls.h文件</p><p>3.5： 文件<code>/kernel/include/linux/syscalls.h</code>中有如下声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_kill</span><span class="token punctuation">(</span><span class="token keyword">int</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>asmlinkage是gcc标签，代表函数读取的参数来自于栈中，而非寄存器。</p><h4 id="3-1-SYSCALL-DEFINE"><a href="#3-1-SYSCALL-DEFINE" class="headerlink" title="3.1 SYSCALL_DEFINE"></a>3.1 SYSCALL_DEFINE</h4><p>sys_kill()定义在内核源码找不到直接定义，而是通过<code>syscalls.h</code>文件中的SYSCALL_DEFINE宏定义。前面已经讲过sys_kill是通过语句<code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code>来定义，下面来一层层剖开，这条宏定义的真面目：</p><p>等价 1：</p><p><code>syscalls.h</code>中有大量如下宏定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE0</span><span class="token expression"><span class="token punctuation">(</span>sname<span class="token punctuation">)</span>                    </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>_</span><span class="token punctuation">##</span><span class="token expression">sname<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                </span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> sys_</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">sname</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE1</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE2</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE3</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE4</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE5</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINE6</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可得出原语句等价：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> _kill<span class="token punctuation">,</span> <span class="token class-name">pid_t</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等价 2：</p><p><code>syscalls.h</code>中有如下宏定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SYSCALL_DEFINEx</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> x<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可得出原语句等价：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>_kill<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">pid_t</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> _kill<span class="token punctuation">,</span> <span class="token class-name">pid_t</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>define __SYSCALL_DEFINEx(x, name, …)</p><p>等价 3：</p><p><code>syscalls.h</code>中有如下宏定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SYSCALL_DEFINEx</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                    </span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span><span class="token function">__stringify</span><span class="token punctuation">(</span>SyS</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">{</span>                                </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">long</span> ret <span class="token operator">=</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>                </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">return</span> ret<span class="token punctuation">;</span>                        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span>                                </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可得出原语句等价：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_kill</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>    \    <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span><span class="token function">__stringify</span><span class="token punctuation">(</span>SyS_kill<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        \<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">SYSC_kill</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    \asmlinkage <span class="token keyword">long</span> <span class="token function">SyS_kill</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    \asmlinkage <span class="token keyword">long</span> <span class="token function">SyS_kill</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>    \<span class="token punctuation">{</span>                                \    <span class="token keyword">long</span> ret <span class="token operator">=</span> <span class="token function">SYSC_kill</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    \    <span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>                \    <span class="token function">__PROTECT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    \    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>                        \<span class="token punctuation">}</span>                                \<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">SYSC_kill</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>__VA_ARGS__</code>等于 <code>pid_t, pid, int, sig</code>。</p><p>等价 4:</p><p>先说说这里涉及的宏定义</p><p>__MAP宏定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP0</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP1</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP2</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span>t<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__MAP1</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP3</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span>t<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__MAP2</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP4</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span>t<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__MAP3</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP5</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span>t<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__MAP4</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP6</span><span class="token expression"><span class="token punctuation">(</span>m<span class="token punctuation">,</span>t<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__MAP5</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__MAP</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> __MAP</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">n</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关宏定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SC_DECL</span><span class="token expression"><span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span>    t a</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SC_LONG</span><span class="token expression"><span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token function">__typeof</span><span class="token punctuation">(</span><span class="token function">__builtin_choose_expr</span><span class="token punctuation">(</span><span class="token function">__TYPE_IS_LL</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0LL</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SC_CAST</span><span class="token expression"><span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span>    <span class="token punctuation">(</span>t<span class="token punctuation">)</span> a</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SC_ARGS</span><span class="token expression"><span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span>    a</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SC_TEST</span><span class="token expression"><span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">BUILD_BUG_ON_ZERO</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__TYPE_IS_LL</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>展开：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span> <span class="token class-name">pid_t</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span> <span class="token comment">//等价于 pid_t pid, int sig</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span> <span class="token comment">//等价于 long pid, long sig</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span> <span class="token comment">//等价于 (pid_t) pid, (int)sig</span><span class="token function">__MAP</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span> <span class="token comment">//等价于 pid, sig</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可得出原语句等价：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//函数声明sys_kill()，并别名指向SyS_kill</span>asmlinkage <span class="token keyword">long</span> <span class="token function">sys_kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span><span class="token function">__stringify</span><span class="token punctuation">(</span>SyS_kill<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">SYSC_kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数声明SyS_kill()</span>asmlinkage <span class="token keyword">long</span> <span class="token function">SyS_kill</span><span class="token punctuation">(</span><span class="token keyword">long</span> pid<span class="token punctuation">,</span> <span class="token keyword">long</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>asmlinkage <span class="token keyword">long</span> <span class="token function">SyS_kill</span><span class="token punctuation">(</span><span class="token keyword">long</span> pid<span class="token punctuation">,</span> <span class="token keyword">long</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> ret <span class="token operator">=</span> <span class="token function">SYSC_kill</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span><span class="token punctuation">)</span> pid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">BUILD_BUG_ON_ZERO</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">BUILD_BUG_ON_ZERO</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__PROTECT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">SYSC_kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过以上分析过程：</p><ul><li>kill添加了<code>sys_</code>前缀，声明sys_kill()函数；</li><li>定义SYSC_kill()函数和SyS_kill()函数；</li><li>sys_kill，通过别名机制等同于SyS_kill().</li></ul><p>看到这或许很多人(包括我)会觉得诧异，为何要如此复杂呢，后来查资料，发现这是由于之前64位Linux存在<code>CVE-2009-2009</code>的漏洞，简单说就是32位参数存放在64位寄存器，修改符号扩展可能导致产生一个非法内存地址，从而导致系统崩溃或者提升权限。 为了修复这个问题，把寄存器高位清零即可，但做起来比较困难，为了做尽可能少的修改，将调用参数统一采用使用long型来接收，再强转为相应参数。 窥见一斑，可见Linux大师们精湛的宏定义，已经用得出神入化。</p><p>如果觉得很复杂，那么可以忽略这个宏定义，只要记住<code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code> 基本等价于 <code>asmlinkage long sys_kill(int pid, int sig)</code> 就足够了。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h4 id="4-1-内核空间"><a href="#4-1-内核空间" class="headerlink" title="4.1 内核空间"></a>4.1 内核空间</h4><ol><li>系统调用的函数原型的指针：位于文件/kernel/arch/arm/kernel/calls.S，格式为<code>CALL(sys_xxx)</code>，指定了目标函数的入口地址。</li><li>系统调用号的宏定义：位于文件/kernel/arch/arm/include/Uapi/asm/unistd.h，记录着内核空间的系统调用号，格式为<code>#define__NR_xxx (__NR_SYSCALL_BASE+[num])</code></li><li>系统调用的函数声明：位于文件/kernel/include/linux/syscalls.h，格式为<code>asmlinkage long sys_xxx(args ...);</code></li><li>系统调用的函数实现：不同函数位于不同文件，比如kill()位于/kernel/kernel/signal.c文件，格式为<code>SYSCALL_DEFINEx(x, sname, ...)</code></li></ol><p>前面这4步都是在内核空间相关的文件定义，有了这些，那么内核就可以使用相应的系统调用号。</p><h4 id="4-2-用户空间"><a href="#4-2-用户空间" class="headerlink" title="4.2 用户空间"></a>4.2 用户空间</h4><ol><li><p>系统调用号的宏定义：位于文件/bionic/libc/kernel/uapi/asm-arm/asm/unistd.h，记录着用户空间的系统调用号，格式为<code>#define__NR_xxx (__NR_SYSCALL_BASE+[num])</code>。这个文件就是由内核空间同名的头文件自动生成的，所以该文件与内核空间的系统调用号是完全一致。</p></li><li><p>汇编定义相关函数的中断调用过程：位于文件/bionic/libc/arch-arm/syscalls/xxx.S，比如kill()位于kill.S，格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span>    mov     ip<span class="token punctuation">,</span> r7    ldr     r7<span class="token punctuation">,</span> <span class="token operator">=</span>__NR_xxx    swi     #<span class="token number">0</span>    mov     r7<span class="token punctuation">,</span> ip    cmn     r0<span class="token punctuation">,</span> #<span class="token punctuation">(</span>MAX_ERRNO <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    bxls    lr    neg     r0<span class="token punctuation">,</span> r0    b       __set_errno_internal<span class="token function">END</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>当然kill()方法还有函数声明，有了这些，用户空间也能在程序中使用系统调用。明白了这些过程，那么自己新添加系统调用其实也并不是多困难的一件事，新增系统调用号还需要修改syscalls总个数，但强烈不建议自己新增系统调用号，尽量保持与linux kernel主线一致，兼容性更好，所以就不进一步介绍新增流程了。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust 核心概念</title>
      <link href="/2021/09/26/rust-suo-you-quan/"/>
      <url>/2021/09/26/rust-suo-you-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言概述"><a href="#1-前言概述" class="headerlink" title="1. 前言概述"></a>1. 前言概述</h2><p>所有权可以说是Rust中最为独特的一个功能了。正是所有权概念和相关工具的引入，Rust才能够在没有垃圾回收机制的前提下保障内存安全。因此，正确地理解所有权概念及其在Rust中的实现方式，对于所有Rust开发者来说都是非常重要的。本篇的内容会详细的讨论所有权相关功能:借用，切片以及Rust在内存中布局数据的方式。</p><h2 id="2-什么是所有权"><a href="#2-什么是所有权" class="headerlink" title="2. 什么是所有权"></a>2. 什么是所有权</h2><p>所有权的概念本身的含义并不复杂，但作为Rust语言的核心功能，它对语言的其他部分产生了十分深远的影响。</p><p>一般来讲，所有的程序都需要管理自己在运行时使用的计算机内存空间。某些使用垃圾回收机制的语言会在运行时定期检查并回收那些没有被继续使用的内存:比如golang,java,这些语言都是标准的带有垃圾回收机制的语言，还有一些语言是需要程序员去手动释放内存的，比如C语言，C++。但是Rust确实另辟蹊径，采用了与众不同的第三种方式：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不产生任何的运行时的开销。</p><p>所有权的概念并不是那么的好理解，对于我自己而言本身也是一件非常新鲜的事物。但是已经是做好了心里准备，而且是抱着一定要学会Rust的想法去学习，一定要掌握所有权并且写出高效安全的Rust代码的。</p><p>在讲述所有权之前还是要补充一下堆与栈的知识。</p><h3 id="2-1-堆与栈"><a href="#2-1-堆与栈" class="headerlink" title="2.1 堆与栈"></a>2.1 堆与栈</h3><p>在许多编程语言中，程序员本身就不需要频繁的考虑栈空间和堆空间的区别。但是对于Rust这种系统级的编程语言而言，一个值被存储在堆上还是栈上会极大的影响到语言的行为，进而影响到我们编写代码时的设计选择。</p><p>栈和堆都是代码在运行时可以使用的内存空间，不过它们通常以不同的结构组织而成。栈会以我们放入值的顺序来存储它们，并且以相反的顺序将值取出，熟悉数据结构的同学对这些是再熟悉不过了，也就是所谓的””先进后出”的策略。具象的你可以把栈操作想象成堆放盘子。当你需要放置盘子时，你只能将它们放置在栈的顶部，而你要取出盘子时，正常和安全的操作是从顶部取。从中间和底部去把盘子取出来很不安全，盘子可能会发生意外碎了。用计算机的术语来说就是添加数据这一操作被称为入栈，移除数据则被称为出栈。</p><p>所有存储在栈中的数据都必须有一个已知且固定大小的空间。对于那些在编译期无法确定大小的数据，你就只能将它们存储在堆中。堆的空间管理是较为松散的。当你希望将数据放入堆中时，你就可以请求特定大小的空间。操作系统会根据你的请求在堆中找到一块足够大的可用空间。将它们标记为已使用，并把指向这片空间地址的指针返回给我们。这一过程就是所谓的堆分配。它也常常被称为分配。将值压入栈中不叫分配。由于指针的大小是固定的且可以在编译期确定。所以可以将指针存储在栈中。当想要访问指针所指向的具体数据时，可以通过指针指向的地址来访问。</p><p>具象化的再举一个例子。我们可以把堆栈的分配的过程想象成是到餐厅聚餐。当你到达餐厅表明自己需要的座位数后，服务员会找到一张足够大的空桌子，并将你们领过去入座。即便这时有小伙伴来迟了，他们也可以通过询问你们就座的位置来找到你们。向栈上推入数据要比我们在堆上进行分配会更有效率些。因为操作系统省去了搜索新数据存储位置的工作；这个位置永远处于栈的顶端。除此之外，操作系统在堆上分配空间时还必须首先找到足够放下对应数据的空间，并进行某些记录工作来协调随后进行的其余分配操作。</p><p>由于多了指针跳转的环节，所以访问堆上的数据要慢于访问栈上的数据。一般来说，现代处理器在进行计算的过程中，由于缓存的缘故，指令在内存中跳转的次数越多，性能就越差。继续使用上面的餐厅的例子来做类比。假设现在同时有许多桌的顾客正在等待服务员处理。那么最高效率的处理方式自然是报完一张桌子所有的订单后再接着服务下一张桌子的顾客。而一旦服务员每次在单个桌子前只处理单个订单，那么他就不得不浪费较多的时间往返于不同的桌子之间。由于同样的原因，处理器在操作排布紧密的数据（比如在栈上）时要比操作排布稀疏的数据（比如在堆上）有效率的多。另外，分配命令本身可能也会消耗不少的时钟周期。</p><p>许多系统编程语言都需要你记录代码中分配的堆空间。最小化堆上的冗余数据，并及时清理堆上的无用数据以避免消耗空间。而所有权概念则解决了这些问题。一旦熟练的掌握了所有权及其相关工具，就可以将这些问题交给Rust处理，减轻用于思考堆和栈的心智负担。不过，知晓如何使用和管理堆内存可以帮助我们理解所有权存在的意义及其背后的工作原理。</p><h3 id="2-2-所有权规则"><a href="#2-2-所有权规则" class="headerlink" title="2.2 所有权规则"></a>2.2 所有权规则</h3><p>现在，我们来具体看一下所有权规则。</p><ul><li>Rust中每一个值都有一个对应的变量作为它的所有者。</li><li>在同一时间内，值有且仅有一个所有者。</li><li>当所有者离开自己的作用域时，它持有的值就会被释放掉。</li></ul><h3 id="2-3-变量作用域"><a href="#2-3-变量作用域" class="headerlink" title="2.3 变量作用域"></a>2.3 变量作用域</h3><p>第一个示例代码，我们先来了解下变量的作用域。简单来讲作用域是一个对象在程序中有序的范围。假设有这样一个变量</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的变量s指向了一个字符串，它的值被硬编码到了当前的程序中。变量从声明的位置开始直到当前作用域结束都是有效的。如</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token punctuation">{</span>                            <span class="token comment">// 由于变量s还未被声明，所有它在这里是不可用的。</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>         <span class="token comment">// 从这里开始变量s变得可用。</span>xxxxxxxxxx               <span class="token comment">// 执行与s相关的操作</span><span class="token punctuation">}</span>                            <span class="token comment">// 作用域到这里结束，变量s再次不可用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的这段分析有两个重点:</p><ul><li>s在进入作用域后变得有效。</li><li>它会保持自己的有效性直到自己离开作用域为止。</li></ul><p>到目前为止，Rust语言变量的有效性与作用域之间的关系跟其他编程语言中的类似。现在，让我们继续在作用域的基础上学习String类型。</p><h3 id="2-4-String类型"><a href="#2-4-String类型" class="headerlink" title="2.4 String类型"></a>2.4 String类型</h3><p>为了掩饰所有权的相关规则，我们需要一个特别的数据类型，它要比上一章中讲Rust基本数据类型设计的类型更加复杂。之前接触的那些类型会将数据存储在栈上，并在离开自己的作用域时将数据弹出栈空间。我们需要一个存储在堆上的数据类型来研究Rust是如何自动回收这些数据的。</p><p>我们将以String类型为例，并将注意力集中到String类型与所有权概念相关的部分。这些部分同样适用于标准库中提供的或者是你自己穿件的其他的复杂的数据类型。之后还是会继续深入的讲解String类型。</p><p>上面的代码我们已经知道了什么是字符串变量。他们是那些被硬编码进程序的字符串值。字符串字面量确实是很方便，但它们并不能满足所有需要使用文本的场景。原因之一在于字符串字面量是不可变的。而另一个原因则在于并不是所有字符串的值都能够在编写代码时就确定的，假如我们想要获取用户的输入并保存，应该怎么办呢？为了应对这种情况，Rust提供了第二种字符串类型String。这个类型会在堆上分配到自己需要的存储空间，所以它能够处理在编译时未知大小的文本。你可以调用from函数根据字符串字面量来创建一个String实例：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的双冒号（::）运算符允许我们调用置于String命名空间下面的特定from函数，而不需要使用类似于String_from这样名字，在后续讲Rust方法的时候会着重讲解这个语法，以及讨论基于模块的命名空间。</p><p>上面定义的字符串对象能够被声明为可变的:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// push_str()函数向String空间的尾部添加了一段字面量</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里会输出完整的hello,world!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或许在此刻你会有一个疑问就是关于为什么String是可变的，而字符串字面量不是？这是因为采用了不同的内存处理方式。</p><h3 id="2-5-内存与分配"><a href="#2-5-内存与分配" class="headerlink" title="2.5 内存与分配"></a>2.5 内存与分配</h3><p>对于字符串字面量而言，由于我们在编译时就知道其内容，所以这部分硬编码的文本被直接嵌入到了最终的可执行文件中。这就是访问字符串字面量异常高效的原因，而这些性质完全得益于字符串字面量的不可变性。不幸的是，我们没有办法将那些未知大小的文本在编译期统统放入二进制文件中，更何况这些文本的大小还可能随着程序的运行而发生改变。</p><p>对于String类型而言，为了支持一个可变的，可增长的文本类型，我们需要在堆上分配一块在编译时未知大小的内存来存放数据。这同时也是意味着:</p><ul><li>我们使用的内存是由操作系统在运行时动态分配出来的。</li><li>当使用完String时，我们需要通过某种方式来将这些内存归还给操作系统。</li></ul><p>这里的第一步由我们，也就是程序的编写者，在调用String::from时完成，这个函数会请求自己需要的内存空间。在大部分编程语言中都有类似的设计：由程序员来发起堆内存的分配请求。</p><p>然而，对于不同的编程语言来说，第二步实现起来就各有区别了。在某些拥有垃圾回收（Garbage Collector ,GC）机制的语言中，GC会代替程序员来负责记录并清除那些不再使用的内存。而对于那些没有GC的语言来说，识别不在使用的内存并调用代码显示释放的工作就依然需要由程序员去完成，正如我们请求分配时一样。按照以往的经验来看，正确地完成这些任务往往是十分困难的。假如我们忘记释放内存，那么就会造成内存泄漏：假如我们过早的释放内存，那么就会产生一个非法变量；假如我们重复释放同一块内存，那么就会产生无法预知的后果。为了程序的稳定运行，我们必须严格地将分配和释放操作一一对应起来。</p><p>与这些语言不同，Rust提供了另外一套解决方案：内存会自动地在拥有它的变量离开作用域后进行释放。下面的代码类似于示例中的代码，不过我们将字符串字面量换成了String类型：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token punctuation">{</span><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从这里开始，变量s变得有效</span>xxxxxxxxxxxxxxxx <span class="token comment">// 执行与s相关的操作</span><span class="token comment">// 作用域到这里结束，变量s失效</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>审视上面的代码，有一个很适合用来回收内存给操作系统的地方：变量s离开作用域的地方。Rust在变量离开作用域时，会调用一个叫drop的特殊函数。String类型的作者可以在这个函数中编写释放内存的代码。记住，Rust会在作用域结束的地方（即}处）自动调用drop函数。</p><p><strong>注意:</strong></p><p>在C++中，这种在对象生命周期结束时释放资源的模式有时也被称作资源获取即初始化（Resource Acquisition Is Initialization,RAII）。假如你使用过类似的模式，那么你应该对Rust中的特殊函数drop并不陌生。</p><p>这种模式极大地影响了Rust中的许多设计模块，并最终决定了我们现在编写Rust代码的方式。在上面的例子中，这套释放机制看起来也许还算简单，然而一旦把它放在默写更加复杂的环境中，代码呈现出来的行为往往会出乎你的意料，特别是当我们拥有多个指向同一处堆内存的变量时。让我们接着来看一看其中一些可能使用的场景。</p><h4 id="2-5-1-变量和数据交互的方式-移动"><a href="#2-5-1-变量和数据交互的方式-移动" class="headerlink" title="2.5.1 变量和数据交互的方式:移动"></a>2.5.1 变量和数据交互的方式:移动</h4><p>Rust中的多个变量可以采用一种独特的方式与同一数据进行交互。接下来我们来看一段代码，使用了一个整型作为数据：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例中的代码将变量X绑定的整数值重新绑定到变量y上，你也许能够猜到这段代码的执行效果：将整数值5绑定到变量x上：然后创建一个x值的拷贝，并将它绑定到y上。结果我们有了两个变量x和y，它们的值都是5。这正是实际发生的情形，因为整数是已知固定大小的简单值，两个值5会同时被推入当前栈中。</p><p>现在让我们下上述代码的String版本：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上这两段代码非常相似，你也许会假设他们的运行能力也是一致的。也就是说，第二行代码可能会生成一个s1值的拷贝，并将它绑定到s2上。不过实际上并非如此。</p><p>String的示例代码展示了String的内存布局，它实际上由3部分组成，如下图左侧所示：一个指向存放字符串内容的指针（ptr），一个长度（len）及一个容量（capacity），这部分的数据存放在了栈中。图片右侧显示了字符串存储在堆上的文本内容</p><p><img src="https://image.fyxemmmm.cn/blog/images/syq-1.jpg"></p><p> <strong>绑定到变量s1上，拥有值”hello”的String的内存布局</strong></p><p>长度字段被用来记录当前String的文本使用了多少字节的内存。而容量字段则被用来记录String向操作系统总共获取到的内存字节数量。长度和容量之间的区别十分重要，但我们先不去讨论这个问题，简单地忽略内容字段即可。</p><p>当我们将s1赋值给s2时，便复制了一次String的数据，这意味着我们复制了它存储在栈上的指针，长度以及容量字段。但需要注意的是，我们没有复制指针指向的堆数据。换句话说，此时的内存布局应该是类似于下图</p><p><img src="https://image.fyxemmmm.cn/blog/images/syq-2.jpg"></p><p> <strong>变量s2在复制了s1的指针，长度及容量后的内存布局</strong></p><p>由于Rust不会在复制时深度地复制堆上的数据，所以这里的布局不会像下图所以的那样。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syq-3.jpg"></p><p> <strong>当Rust也复制了堆上的数据时，执行完s2=s1语句后可能产生的布局内存</strong></p><p>假如Rust依旧这样的模式去执行赋值，那么当堆上的数据足够大时，类似于s2=s1这样的指令就会造成相当可观的运行时的性能消耗。</p><p>前面我们提到过，当一个变量离开当前的作用域时，当Rust会自动调节它的drop函数，并将变量使用的堆内存释放回收。不过，第二张图展示的内存布局里有两个指针指向了同一个地址，这就导致了一个问题：当s2和s1离开自己作用域时，它们会尝试去重复释放相同的内存。这也就是我们之前提到过的内存的错误之一，臭名昭著的二次释放。重复释放内存可能会导致某些正在使用的数据发生损坏，进而产生潜在的安全隐患。</p><p>为了确保内存安全，同时避免了复制分配的内存，Rust在这种场景下会简单的将s1废弃，不再视其为一个有效的变量。因此，Rust也不需要在s1离开作用域后清理任何东西。试图在s2创建完毕后使用s1，如下所示会导致编译错误。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"{},world!"</span><span class="token punctuation">,</span>s1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了阻止你使用的无效的引用，Rust会产生类似于下面的错误提示</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">error<span class="token punctuation">[</span><span class="token constant">E0382</span><span class="token punctuation">]</span><span class="token punctuation">:</span> borrow of moved value<span class="token punctuation">:</span> `s1` <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">26</span>  <span class="token operator">|</span><span class="token number">2</span> <span class="token operator">|</span>     <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>         <span class="token operator">-</span><span class="token operator">-</span> <span class="token keyword">move</span> occurs because `s1` has <span class="token keyword">type</span> `<span class="token namespace">std<span class="token punctuation">::</span>string<span class="token punctuation">::</span></span><span class="token class-name">String</span>`<span class="token punctuation">,</span> which does not implement the `<span class="token class-name">Copy</span>` <span class="token keyword">trait</span><span class="token number">3</span> <span class="token operator">|</span>     <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>  <span class="token operator">|</span>              <span class="token operator">-</span><span class="token operator">-</span> value moved here<span class="token number">4</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{},world!"</span><span class="token punctuation">,</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>                          <span class="token operator">^</span><span class="token operator">^</span> value borrowed here after <span class="token keyword">move</span>error<span class="token punctuation">:</span> aborting due to previous error<span class="token punctuation">;</span> <span class="token number">1</span> warning emitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如你在其他语言中接触过浅度拷贝（shallow copy）和深度拷贝（deep copy）这两个术语，那么你也许会将这里复制指针，长度以及容量字段行为视作浅度拷贝。但由于Rust同时使第一个变量无效了，所以我们使用了新的术语移动（move）来描述这一行为，而不再使用浅度拷贝。在上面的示例中我们可以说s1被移动到了s2中。在这个过程中所发生的的操作如下图所示。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syq-4.jpg"></p><p> <strong>s1变为无效之后的内存布局</strong></p><p>这一语义完美的解决了我们的问题！既然只有s2有效，那么也就只有它会在离开自己的作用域时释放空间，所以再也没有二次释放的可能性了。另外，这里还隐含了另外一个设计原则：Rust永远不会自动地创建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可以被视为高效的。</p><h4 id="2-5-2-变量和数据交互的方式：-克隆"><a href="#2-5-2-变量和数据交互的方式：-克隆" class="headerlink" title="2.5.2 变量和数据交互的方式： 克隆"></a>2.5.2 变量和数据交互的方式： 克隆</h4><p>都拿你确实系要去深度拷贝String堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法。后面的篇章中会详细讨论类型方法的语法，但你应该在其他语言中见过类似的东西。</p><p>下面是一个实际使用clone方法的例子：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">lets s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {},s2 = {}"</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码在Rust中完全合法，它显示的生成了第三张图的行为：赋值了堆上的数据。当你看到某处调用了clone时，你就应该知道某些特定的代码将会被执行，而且这些代码可能会相当的消耗资源。你可以很容易的在代码中觉察到一些不同寻常的事情正在发生。</p><h4 id="2-5-3-栈上数据的复制"><a href="#2-5-3-栈上数据的复制" class="headerlink" title="2.5.3 栈上数据的复制"></a>2.5.3 栈上数据的复制</h4><p>上面的讨论中遗留了一个没有提及的知识点。我们在示例中曾经使用整型编写了如下的合法代码</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x = {},y = {}"</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这与我们刚刚在上面说到的内容有些矛盾，即便代码没有调用clone，x在被赋值给y后也依然有效，且没有发生移动现象。</p><p>这是因为类似于整型的类型可以在编译时确定自己的大小，并且能够将自己的数据完整地存储在栈中，对于这些值的复制操作永远都是非常快速的。这也同样意味着，在创建变量y之后，我们没有任何理由去阻止变量x继续保持有效。换句话说，对于这些类型而言，深度拷贝与浅度拷贝没有任何区别，调用clone并不会与直接的浅度拷贝有任何行为上的区别。因此，我们完全不惜要在类似的场景中考虑上面的问题。</p><p>Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型，啥是trait在后续会有详细的说明。一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保存可用性。如果一种类型本身或这种类型的任意成员实现了实现了Drop这种trait，那么Rust就不允许其实现Copy这种trait。尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误。</p><p>那么究竟哪些类型是Copy的，可以去查一下文档来确定，不过一般来说，任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不会是Copy的。下面是一些拥有Copy这种trait的类型：</p><ul><li>所有的整数类型，诸如u32</li><li>仅拥有两种值(true 和 false)的布尔类型：bool</li><li>字符类型：char</li><li>所有的浮点类型，诸如f64</li><li>如果元组包含的所有字段的类型都是Copy的，那么这个元组也是Copy的。诸如（i32,i32）是Copy的，但是（i32,String）则不是。</li></ul><h3 id="2-6-所有权与函数"><a href="#2-6-所有权与函数" class="headerlink" title="2.6 所有权与函数"></a>2.6 所有权与函数</h3><p>将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 变量s进入作用域</span>    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s的值被移动进了函数，所以它从这里开始不再有效</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 变量x进入作用域</span>    <span class="token function">make_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">//变量x同样被传递进了函数，但由于i32是Copy的，所以我们依然可以在这之后使用x</span><span class="token punctuation">}</span> <span class="token comment">// x首先离开作用域,随后是s。</span><span class="token comment">// 但是由于s的值已经发生了移动，所有没有什么特别的事情会发生。</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// some_string进入作用域</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>some_string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// some_string在这里离开作用域，drop函数被自动调用，some_string所占用的内存也就随之被释放了</span><span class="token keyword">fn</span> <span class="token function-definition function">make_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// some_integer 进入作用域</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// some_integer在这里离开作用域，没有发生什么特别的事情</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尝试在调用takes_ownership后使用变量s会导致编译时错误。这类静态检查可以使我们免于犯错。你可以尝试在main函数中使用s和x变量，来看一下所有权规则的约束下能够在哪些地方合法的使用他们。</p><h3 id="2-7-返回值与作用域"><a href="#2-7-返回值与作用域" class="headerlink" title="2.7 返回值与作用域"></a>2.7 返回值与作用域</h3><p>函数在返回值的过程中也会发生所有权的转移。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gives_ownership将它的返回值移动至s1中</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2进入作用域</span>    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">take_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2被移动进函数</span>    <span class="token comment">// take_and_gives_back中，而这个函数的返回值又被移动到了变量s3上</span><span class="token punctuation">}</span> <span class="token comment">// s3在这里离开作用域并被销毁，由于s2已经移动了，所以它不会在离开作用域时发生任何事情。s1最后离开作用域并被销毁。</span><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">{</span> <span class="token comment">// gives_ownership会将它的返回值移动至调用它的函数内</span>    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string进入作用域</span>    some_string <span class="token comment">// some_string作为返回值移动至调用函数</span><span class="token punctuation">}</span><span class="token comment">// take_and_gives_back将取得一个String的所有权并将它作为结果返回</span><span class="token keyword">fn</span> <span class="token function-definition function">take_and_gives_back</span><span class="token punctuation">(</span>a_String<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>    <span class="token comment">// a_String进入作用域</span>    a_String <span class="token comment">// a_String作为返回值移动至调用函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>函数在返回值时所有权的转移过程</strong></p><p>变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。</p><p>在所有的函数中都要获取所有权并返回所有权显得有些繁琐。假如你希望在调用函数时保留参数的所有权，那么就不得不将传入的值作为结果返回。除了这些需要保留所有权的值，函数还可能会返回它们本身的结果。</p><p>当然你也可以利用元组来同时返回多个值。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>s2<span class="token punctuation">,</span>len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '{}' is {}."</span><span class="token punctuation">,</span>s2<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token keyword">usize</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// len()会返回当前字符串的长度</span>    <span class="token punctuation">(</span>s<span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>返回参数的所有权</strong></p><p>但这种写法未免太过笨拙了，类似的概念在编程工作中相当常见。幸运的是，Rust针对这类场景提供了一个名为引用的功能。</p><h3 id="2-8-引用与借用"><a href="#2-8-引用与借用" class="headerlink" title="2.8 引用与借用"></a>2.8 引用与借用</h3><p>在 <strong>返回参数的所有权</strong>的示例代码中，由于调用了calculate_length会导致String移动到函数体内部，而我们又希望在调用完毕之后继续使用该String，所以我们不得不使用元组将String作为元素再次返回。</p><p>下面的示例重新定义了一个新的calculate_length函数。与之前不同的是，新的函数签名使用了String的引用作为参数而没有直接转移值的所有权。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '{}' is {}."</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要注意的是，变量声明及函数返回值中的那些元组代码都消失了。我们调用calculate_length函数使用了&amp;s1作为参数，且在该函数的定义中，我们使用&amp;String替代了String。</p><p>这些&amp;代表的就是引用语义，它们允许你在不获取所有权的前提下使用值，如下图的图解</p><p><img src="https://image.fyxemmmm.cn/blog/images/syq-5.jpg"></p><p> <strong>&amp;String s 指向String s1的图解</strong></p><p>注意：</p><p>与使用&amp;进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符。解应用的使用场景会在后续的章节补上。</p><p>现在，让我们观察下这个函数的调用过程</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的&amp;s1语法允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前的作用域时，它指向的值也不会被丢弃。</p><p>同理，函数签名中的&amp;用来表明参数s的类型是一个引用。下面的注释给出了更详细的解释：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span><span class="token punctuation">{</span> <span class="token comment">// s是一个指向String的引用</span>s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment">// 到这里，s离开作用域。但是由于它并不持有自己所指向值的所有权，所以没有用什么特殊的事情会发生</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此处，变量s的有效作用域与其他任何参数一样，唯一不同的是，它不会在离开自己的作用域时销毁其指向的数据，因为它并不拥有该数据的所有权。当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有获得所有权。</p><p>这种通过引用传递参数给函数的方法也被称为借用（borrowing）。但在现实生活中，假如一个人拥有某种东西，你可以从他那里把东西借过来，但是当你使用完毕时，就必须将东西还回去。</p><p>如果我们尝试着修改借用的值又会发生什么？尝试下修改一下代码，这里我先给出结果：无法通过编译</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>尝试修改借用的值</strong></p><p>编译的结果:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">error<span class="token punctuation">[</span><span class="token constant">E0596</span><span class="token punctuation">]</span><span class="token punctuation">:</span> cannot borrow `<span class="token operator">*</span>some_string` <span class="token keyword">as</span> mutable<span class="token punctuation">,</span> <span class="token keyword">as</span> it is behind a `<span class="token operator">&amp;</span>` reference <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">5</span>  <span class="token operator">|</span><span class="token number">6</span> <span class="token operator">|</span> <span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token operator">|</span>                        <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> help<span class="token punctuation">:</span> consider changing this to be a mutable reference<span class="token punctuation">:</span> `<span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token namespace">std<span class="token punctuation">::</span>string<span class="token punctuation">::</span></span><span class="token class-name">String</span>`<span class="token number">7</span> <span class="token operator">|</span>     some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>     <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> `some_string` is a `<span class="token operator">&amp;</span>` reference<span class="token punctuation">,</span> so the data it refers to cannot be borrowed <span class="token keyword">as</span> mutable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与变量类似，应用默认也是不可变的。Rust不允许我们去修改引用指向的值。</p><h3 id="2-9-可变引用"><a href="#2-9-可变引用" class="headerlink" title="2.9 可变引用"></a>2.9 可变引用</h3><p>我们可以通过进行一个小小的调整来修复2.8中的代码示例</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们需要将变量s声明为mut，即可变的。其实，我们使用&amp;mut来给函数传入一个可变引用，并将函数签名修改为some_string: &amp;mut String来使其可以接受一个可变引用作为参数。</p><p>单可变引用在使用上有一个很大的限制：对于特定作用域中的特定数据来说，一次只能声明一个可变引用。以下代码尝试违背这一限制，则会导致编译错误：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span><span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{},{},{}"</span><span class="token punctuation">,</span>s<span class="token punctuation">,</span>r1<span class="token punctuation">,</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出现的错误如下所示：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">error<span class="token punctuation">[</span><span class="token constant">E0499</span><span class="token punctuation">]</span><span class="token punctuation">:</span> cannot borrow `s` <span class="token keyword">as</span> mutable more than once at a time <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">14</span>  <span class="token operator">|</span><span class="token number">3</span> <span class="token operator">|</span>     <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>  <span class="token operator">|</span>              <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> first mutable borrow occurs here<span class="token number">4</span> <span class="token operator">|</span>     <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>  <span class="token operator">|</span>              <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> second mutable borrow occurs here<span class="token number">5</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{},{},{}"</span><span class="token punctuation">,</span>s<span class="token punctuation">,</span>r1<span class="token punctuation">,</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>                           <span class="token operator">-</span><span class="token operator">-</span> first borrow later used here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个规则使得引用的可变性只能以一种受到严格限制的方式来使用。刚刚接触Rust的开发者会反复的与他们进行斗争，因为大部分的语言都允许你随意修改变量。</p><p>但在另外一方面，在Rust中遵循这条限制性规则则可以帮助我们在编译中避免数据竞争。数据竞争（data race）与竞态条件十分类似，它会在指令满足以下3种情形下发生：</p><ul><li>两个或两个以上的指针同事访问同一空间</li><li>其中至少有一个指针会向空间中写入数据</li><li>没有同步数据访问的机制</li></ul><p>数据竞争会导致未定义的行为，由于这些未定义的行为往往难以在运行时跟踪，也就使得出现的bug更加难以被诊断和修复。Rust则完全避免了这种情形，因为存在数据竞争的代码连编译检查都无法通过！</p><p>与大部分语言类似，我们可以通过或括号来创建一个新的作用域范围，这就使我们可以创建多个可变引用，当然，这些可变引用不会同时存在：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// 由于r1在这里离开了作用域，所以我们可以合法地再创建一个可变引用。</span>  <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在结合使用可变引用于不可变引用时，还有另外一条类似的限制规则，它会导致下面的代码编译失败：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">error<span class="token punctuation">[</span><span class="token constant">E0502</span><span class="token punctuation">]</span><span class="token punctuation">:</span> cannot borrow `s` <span class="token keyword">as</span> mutable because it is also borrowed <span class="token keyword">as</span> immutable <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">14</span>  <span class="token operator">|</span><span class="token number">3</span> <span class="token operator">|</span>     <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span>  <span class="token operator">|</span>              <span class="token operator">-</span><span class="token operator">-</span> immutable borrow occurs here<span class="token number">4</span> <span class="token operator">|</span>     <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span><span class="token number">5</span> <span class="token operator">|</span>     <span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// 错误</span>  <span class="token operator">|</span>              <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> mutable borrow occurs here<span class="token number">6</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{},{},{}"</span><span class="token punctuation">,</span>r1<span class="token punctuation">,</span>r2<span class="token punctuation">,</span>r3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>                         <span class="token operator">-</span><span class="token operator">-</span> immutable borrow later used here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不知道大家有没有发现，我们不能在拥有不可变引用的同时创建可变引用。听上去有点拗口，像是一句绕口令。不可变引用的用户可不会希望他们眼皮底下的值突然发生变化！不过，同时存在多个不可变引用是合理合法的，对数据的只读操作不会影响到其他读取数据的用户。</p><p>尽管这些编译错误会让人感到沮丧，但是要牢记一点：Rust编译器可以为我们提早（在编译时而不是在运行时）暴露那些潜在的bug，并且明确指出出现问题的地方。你不再需要去追踪调试为何数据会在运行时发生了非预期的变化。</p><h3 id="2-10-悬垂引用"><a href="#2-10-悬垂引用" class="headerlink" title="2.10 悬垂引用"></a>2.10 悬垂引用</h3><p>是用拥有多指针概念的语言会非常容易错误地创建悬垂指针。这类指针指向曾经存在的某处内存地址，但该内存已经被释放掉甚至是被重新分配另作他用了。而在Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。假如我们当前持有某一个数据的引用，那么编译器可以保证这个数据不会在引被销毁前离开自己的作用域。</p><p>我们来创建一个悬垂引用，看看Rust是如何在编译期发现这个错误的：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> reference_to_nothing <span class="token operator">=</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>s<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">rror<span class="token punctuation">[</span><span class="token constant">E0106</span><span class="token punctuation">]</span><span class="token punctuation">:</span> missing lifetime specifier <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">16</span>  <span class="token operator">|</span><span class="token number">5</span> <span class="token operator">|</span> <span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">{</span>  <span class="token operator">|</span>                <span class="token operator">^</span> expected named lifetime parameter  <span class="token operator">|</span>  <span class="token operator">=</span> help<span class="token punctuation">:</span> this function<span class="token lifetime-annotation symbol">'s</span> <span class="token keyword">return</span> <span class="token keyword">type</span> contains a borrowed value<span class="token punctuation">,</span> but there is no value <span class="token keyword">for</span> it to be borrowed fromhelp<span class="token punctuation">:</span> consider using the `<span class="token lifetime-annotation symbol">'static</span>` lifetime  <span class="token operator">|</span><span class="token number">5</span> <span class="token operator">|</span> <span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>  <span class="token operator">|</span>                <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段错误提示信息包含了一个目前还未讲解过的新概念：生命周期。后续会出章节详细讨论。不过即使我们先将生命周期放置不管，这条错误提示信息也准确的指出了代码中的问题：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">this function<span class="token lifetime-annotation symbol">'s</span> <span class="token keyword">return</span> <span class="token keyword">type</span> contains a borrowed value<span class="token punctuation">,</span> but there is no value <span class="token keyword">for</span> it to be borrowed from<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>仔细的看下dangle函数中发生了什么</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token comment">// 返回一个指向String的引用</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s被绑定到新的String上</span>    <span class="token operator">&amp;</span>s <span class="token comment">// 我们将指向s的引用返回给调用者，变量s在这里离开作用域并随之被销毁，它指向的内存自然也不会再有效。一个危险的操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于变量s创建在函数dangle内，所以它会在dangle执行完毕随之释放。但是，我们的代码依旧尝试返回一个指向s的引用，这个引用指向的是一个无效的String，这可不对！Rust成功地拦截了我们的危险代码。</p><p>解决这个问题的方法也很简单，直接返回String就好：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">no_dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法没有任何问题，所有权被转移出函数，自然也就不会涉及释放操作了。</p><h3 id="2-11-引用的规则"><a href="#2-11-引用的规则" class="headerlink" title="2.11 引用的规则"></a>2.11 引用的规则</h3><p>让我们简要的概括下对引用的讨论：</p><ul><li>在任何一段给定的时间里，你要么只能拥有一个可变的引用，要么只能拥有任意数量的不可变引用。</li><li>引用总是有效的</li></ul><p>接下来着重研究一下引用的另外一种形式：切片</p><h3 id="2-12-切片"><a href="#2-12-切片" class="headerlink" title="2.12 切片"></a>2.12 切片</h3><p>除了引用，Rust还有另外一种不持有所有权的数据类型：切片(slice)。</p><p>切片允许我们引用集合中某一段连续的元素序列，而不是整个集合。</p><p>考虑到这样一个小问题；编写一个搜索函数，它接收字符串作为参数，并将字符串中的首个单词作为结果返回。如果字符串中不存在空格，那么就意味着整个字符串是一个单词，直接返回整个字符串作为结果即可。</p><p>让我们来看下这个函数的签名该如何设计：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于我们不需要获得传入的所有权，所以这个函数first_word采用了&amp;String作为参数。但它应该返回什么？我们还没有一个获取部分字符串的方法。当然，你可以将首个单词结尾处的索引返回给调用者，如示:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span><span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span><span class="token punctuation">{</span>    ① <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span>② <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>③<span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ④ <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  ⑤ s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>first_word函数会返回String参数中首个单词结尾处的索引作为结果</strong></p><p>这段代码首先使用as_byte①将String转换为字节数组，因为我们的算法需要依次检查String中的字节是否为空格。接着，我们通过iter③方法创建了一个可以遍历字节数组的迭代器。</p><p>迭代器后续再详细讨论。目前，我们只需知道iter方法会依次返回集合中的每一个元素即可。随后的enumerate则将iter的每个输出作为元素逐一封装在对应的元组中返回。元组的第一个元素是索引，第二个元素是指向集合中字节的引用。使用enumerate可以较为方便地获得迭代索引。</p><p>既然enumerate方法返回的是一个元组，那么我们就可以使用模式匹配来结构他它，就像是Rust中其他使用元组的地方一样。在for循环的遍历语句中，我们指定了一个解构模式，其中i是元组中的索引部分，而&amp;item②则是元组中指向集合元素的引用。由于我们从.iter().enumerate()中获取的是产生引用元素的迭代器，所以我们在模式中使用了&amp;。</p><p>在for循环的代码块中，我们使用了字节字面量语法来搜索数组中代表这空格的字节④。这段代码会在搜索到空格时返回当前的位置索引，并在搜索失败时返回传入字符串的长度s.len()。⑤</p><p>现在，我们初步实现了期望的功能，它能够成功地搜索并返回字符串中第一个单词结尾处的位置索引。但这里依然存在一个设计上的缺陷。我们将一个usize值作为索引独立地返回给调用者，但这个值脱离了传入的&amp;String的上下文之后便毫无意义。换句话说，由于这个值独立于String而存在，所以在函数返回后，我们就再也无法保证它的有效性了。下面的示例中使用first_word函数演示了这种返回值失效的情形。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> _word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 索引5会被绑定到变量word上</span>    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里的clear方法会清空当前字符串，使之变为""</span>    <span class="token comment">// 虽然word依然拥有这5个值，但因为我们用于搜索的字符串发生了改变</span>    <span class="token comment">// 所以这个索引也就没有任何意义了，word到这里变失去了有效性。</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>保存first_word产生的返回值并改变其中String的内容</strong></p><p>上面的程序编译没有任何问题，即便我们在调用s.clear()之后使用_word变量也是没有问题的。同事由于_word变量本身与s没有任何关联，所以_word的值始终是5。但当我们再次使用5去从变量s中提取单词时，一个bug就出现了：此时s中的内容早已在我们将5存入_word后发生了改变。</p><p>这种API的设计方式使我们需要随时关注_word的有效性，确保它与s中的数据是一致的，类似的工作往往相当烦琐且易于出错。这种情况对于另一个函数second_word而言更加明显。这个函数被设计来搜索字符串中的第二个单词，它的签名也许被设计为下面这样：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">second_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span><span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token keyword">usize</span><span class="token punctuation">,</span><span class="token keyword">usize</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们需要同时维护起始和结束两个位置的索引，这两个值基于数据的某个特定状态计算而来，却没有跟数据产生任何程度上的联系。于是我们有了3个彼此不相关的变量需要被同步，这可不妙。</p><p>幸运的是，Rust为这个问题提供了解决方案：字符串切片。</p><h3 id="2-13-字符串切片"><a href="#2-13-字符串切片" class="headerlink" title="2.13 字符串切片"></a>2.13 字符串切片</h3><p>字符串切片是指向String对象中某个连续部分的引用，它的使用方法如下所示</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>①<span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">..</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的语法与创建指向整个String对象的引用有些类似，但不同的是新的语法在结尾的地方多出了一段[0..5]。这段额外的声明告诉编译器我们正在创建一个String的切片引用，而不是对整个字符串本身的引用。</p><p>我们可以在一对方括号中指定切片的范围区间[starting_index,ending_index]，其中starting_index是切片起始位置的索引值，ending_index是切片终止位置的下一个索引值。切片数据结构在内部存储了指向起始位置的引用和一个描述切片长度的字段，这个描述切片长度的字段等价于ending_index减去starting_index。所以在上面实例的①中，world是一个指向变量s第七个字节并且长度为5的切片。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syq-6.jpg"></p><p> <strong>指向String对象中某个连续部分的字符串切片</strong></p><p>Rust的范围语法..有一个小小的语法糖：当你希望范围从第一个元素(也就是索引值为0的元素)开始时，则可以省略两个点号之前的值。换句话说，下面两个创建切片的表达式是等价的：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样地，假如你的切片想要包含String中的最后一个字节，你也可以省略双点号之后的值。下面的切片表达式依然是等价的：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你甚至可以同时省略首位的两个值，来创建一个指向整个字符串所有字节的切片:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>字符串切片的边界必须位于有效的UTF-8字符边界内。尝试从一个多字节字符的中间位置创建字符串切片会导致运行时错误。为了将问题简化，现在使用ASCII字符集，至于UTF-8后续再做讨论。</p><p>基于上述的知识，让我们开始重构first_word函数。该函数可以返回一个切片作为结果。字符串切片的类型写作&amp;str：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个新函数中搜索首个单词索引的方式类似于示例 <strong>first_word函数会返回String参数中首个单词结尾处的索引作为结果</strong>中的代码。一旦搜索成功，就返回一个从首字符开始带这个索引位置结束的字符串切片。</p><p>调用新的first_word函数会返回一个与底层数据紧密联系的切片作为结果，它由指向起始位置的引用和描述元素长度的字段组成。</p><p>当然我们也可以以同样的方式重构second_word函数</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">second_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于编译器会确保指向String的引用持续有效，所以我们新设计的接口变得更加健壮直观了。还记得在示例 <strong>保存first_word产生的返回值并改变其中String的内容</strong>中故意构造出的错误嘛？这段代码在搜索完成并保存索引后清空了字符串的内容，这使得我们存储的索引不再有效。它在逻辑上明显是有问题的，却不会触发任何编译错误，这个问题只会在我们使用第一个单词的索引去读取空字符串暴露出来。切片的引入使我们可以在开发早期快速地发现此类错误。示例<strong>保存first_word产生的返回值并改变其中String的内容</strong>中，新的first_word函数在编译时会抛出一个错误，尝试运行以下代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> _word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//错误</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"the first word is: {}"</span><span class="token punctuation">,</span>_word<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译结果</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">error<span class="token punctuation">[</span><span class="token constant">E0502</span><span class="token punctuation">]</span><span class="token punctuation">:</span> cannot borrow `s` <span class="token keyword">as</span> mutable because it is also borrowed <span class="token keyword">as</span> immutable <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">5</span>  <span class="token operator">|</span><span class="token number">3</span> <span class="token operator">|</span>     <span class="token keyword">let</span> _word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>                            <span class="token operator">-</span><span class="token operator">-</span> immutable borrow occurs here<span class="token number">4</span> <span class="token operator">|</span>     s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">|</span>     <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> mutable borrow occurs here<span class="token number">5</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"the first word is: {}"</span><span class="token punctuation">,</span>_word<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>                                      <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> immutable borrow later used here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回忆一下借用的规则，当我们拥有了某个变量的不可变引用时，我们就无法同时取得该变量的可变引用。由于clear需要截断当前的String实例，所以调用clear需要传入一个可变引用。这就是编译失败的原因。Rust不仅使我们的API更加易用，它还在编译过程中帮助我们避免了此类错误。</p><h4 id="2-13-1-字符串字面量就是切片"><a href="#2-13-1-字符串字面量就是切片" class="headerlink" title="2.13.1 字符串字面量就是切片"></a>2.13.1 字符串字面量就是切片</h4><p>还记得Rust字符串字面量被直接存储在了二进制程序中吗？在学习了切片之后，我们现在可以更恰当地理解字符串字面量了：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"Hello,World!"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，变量s的类型其实就是&amp;str，它是一个指向二进制程序特定位置的切片。正是由于&amp;str是一个不可变的引用，所以字符串字面量自然才是不可变的。</p><h4 id="2-13-2-将字符串切片作为参数"><a href="#2-13-2-将字符串切片作为参数" class="headerlink" title="2.13.2 将字符串切片作为参数"></a>2.13.2 将字符串切片作为参数</h4><p>既然我们可以分别创建字符串字面量和String的切片，那么就能够进一步优化first_word函数的接口，下面就是它目前的签名：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比较有经验的Rust开发者往往会采用下面的写法，这种改进后的签名使函数可以同时处理String与&amp;str;</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <strong>使用字符串切片作为参数s的类型来改进first_word函数</strong></p><p>当你持有字符串切片时，你可以直接调用这个函数。而当你持有String时，你可以创建一个完整String的切片来作为参数。在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能，尝试运行以下代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">let</span> my_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// first_word可以接收String对象的切片作为参数</span><span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> my_string_literal <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token comment">// first_word可以接收字符串字面量的切片作为参数</span><span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//由于字符串字面量本身就是切片，所以我们可以在这里直接将它传入函数</span><span class="token comment">// 而不需要使用额外的切片语法</span><span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span>my_string_literal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-14-其他类型切片"><a href="#2-14-其他类型切片" class="headerlink" title="2.14 其他类型切片"></a>2.14 其他类型切片</h3><p>从名字上可以看出来，字符串切片是专门用于字符串的。但实际上，Rust还有其他更加通用的切片类型，以下面数组为例：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就像我们想要引用字符串的某个部分一样，你也可能希望引用数组的某个部分。这是，我们可以这样做</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的切片类型是&amp;[i32]，它在内部存储了一个指向起始元素的引用及长度，这与字符串切片的工作机制完全一样。你将在各种各样的集合中接触到此类切片，而我们会在后续的学习中再来介绍哪些常用的集合。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>所有权，借用和切片的概念是Rust可以在编译时保证内存安全的关键所在。像其他系统语言一样，Rust语言给与了程序员完善的内存使用控制能力。除此之外，Rust还能够自动清除那些所有者离开了作用域的数据。这极大地减轻了使用者的心智负担，也不需要专门去编写销毁代码和测试代码，所有权也影响着Rust中大部分功能的运作机制。</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 所有权 </tag>
            
            <tag> 借用 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 安全计数</title>
      <link href="/2021/09/19/go-yu-yan-shi-xian-an-quan-ji-shu-de-ruo-gan-chong-fang-fa/"/>
      <url>/2021/09/19/go-yu-yan-shi-xian-an-quan-ji-shu-de-ruo-gan-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇如何用 goroutine-safe 的方式实现计数器的方法汇总。</p><h3 id="不要这样做"><a href="#不要这样做" class="headerlink" title="不要这样做"></a>不要这样做</h3><p>我们先从非安全的实现方式开始：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> NotSafeCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span> number <span class="token builtin">uint64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">NewNotSafeCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Counter <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span>NotSafeCounter<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>NotSafeCounter<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>num <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span>number <span class="token operator">=</span> c<span class="token punctuation">.</span>number <span class="token operator">+</span> num<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>NotSafeCounter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uint64</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span>number<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码上没什么特别的地方。我们来测试下结果正确与否：创建 100 个 goroutine，其中三分之二的 goroutine 对共享计数器加一。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">testCorrectness</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">,</span> counter Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span> wg <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>  wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>   <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>counter Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>   <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>counter Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    counter<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>counter Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span> wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> counter<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">66</span> <span class="token punctuation">{</span>  t<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"counter should be %d and was %d"</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试的结果是不确定的，有时候能正确运行，有时候会出现类似这样的错误：</p><pre class="line-numbers language-none"><code class="language-none">counter_test.go:34: counter should be 66 and was 65<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="经典实现方式"><a href="#经典实现方式" class="headerlink" title="经典实现方式"></a>经典实现方式</h3><p>实现一个正确计数器的传统方式是使用<strong>互斥锁</strong>，保证任意时间只有一个协程操作计数器。Go 语言的话，我们可以使用 sync 包。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MutexCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span> mu     <span class="token operator">*</span>sync<span class="token punctuation">.</span>RWMutex number <span class="token builtin">uint64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">NewMutexCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Counter <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span>MutexCounter<span class="token punctuation">{</span><span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>RWMutex<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>num <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>number <span class="token operator">=</span> c<span class="token punctuation">.</span>number <span class="token operator">+</span> num<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uint64</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span>number<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在测试结果每次都能通过且都是正确的。</p><h3 id="使用-channel"><a href="#使用-channel" class="headerlink" title="使用 channel"></a>使用 channel</h3><p>锁是一种保证同步的低级原语。Go 也提供了更高级实现方式 - channel。</p><p>关于 mutexe 和 channel，现在有太多类似这样的讨论：“mutexe vs channel ”、“哪个更好”、“我应当使用哪一个”等。其中一些讨论非常有趣且有益，但这并不是本文讨论的重点。</p><p>我们使用 channel 来实现协程安全的计数器，使用 channel 充当队列，对计数器的操作(读、写)都缓存在队列中，按顺序操作。具体的操作通过传递 func() 实现。创建时，计数器会衍生出一个 goroutine 并且按顺序执行队列里的操作。</p><p>下面是计数器的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ChannelCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span> ch     <span class="token keyword">chan</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> number <span class="token builtin">uint64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">NewChannelCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Counter <span class="token punctuation">{</span> counter <span class="token operator">:=</span> <span class="token operator">&amp;</span>ChannelCounter<span class="token punctuation">{</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span> <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>counter <span class="token operator">*</span>ChannelCounter<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> f <span class="token operator">:=</span> <span class="token keyword">range</span> counter<span class="token punctuation">.</span>ch <span class="token punctuation">{</span>   <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token keyword">return</span> counter<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个协程调用 Add()，就往队列里面添加一个写操作：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>ChannelCounter<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>num <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span>ch <span class="token operator">&lt;-</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  c<span class="token punctuation">.</span>number <span class="token operator">=</span> c<span class="token punctuation">.</span>number <span class="token operator">+</span> num <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个协程调用 Read()，就往队列里面添加一个读操作：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>ChannelCounter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uint64</span> <span class="token punctuation">{</span> ret <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">uint64</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>ch <span class="token operator">&lt;-</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ret <span class="token operator">&lt;-</span> c<span class="token punctuation">.</span>number  <span class="token function">close</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token operator">&lt;-</span>ret<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我真正喜欢这个实现的地方在于，这种按顺序执行的方式非常的清晰。</p><h3 id="原子方式"><a href="#原子方式" class="headerlink" title="原子方式"></a>原子方式</h3><p>我们甚至可以用更低级别的原语，利用 sync/atomic 包执行原子操作。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> AtomicCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span> number <span class="token builtin">uint64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">NewAtomicCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Counter <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span>AtomicCounter<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>num <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> atomic<span class="token punctuation">.</span><span class="token function">AddUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uint64</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较和交换"><a href="#比较和交换" class="headerlink" title="比较和交换"></a>比较和交换</h3><p>或者，我们可以使用非常经典的原语：CAS，对计时器进行计数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>CASCounter<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>num <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">{</span>  v <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">)</span>  <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v<span class="token operator">+</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>CASCounter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uint64</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="float-类型该如何实现"><a href="#float-类型该如何实现" class="headerlink" title="float 类型该如何实现"></a>float 类型该如何实现</h3><p>在我探索学习过程中，看到一个非常棒的视频 - 《<strong>Prometheus: Designing and Implementing a Modern Monitoring Solution in Go</strong>[1]》。在视频的最后，讨论了如何实现浮点数计数器。到目前为止，所有的技术都适用于浮点数，除了 sync/atomic 包，还没提供浮点数的原子操作。</p><p>在视频里，Björn Rabenstein 介绍了如何通过将浮点数存储为 uint64 并使用 math.Float64bits 和 math.Float64frombits 在 float64 和 uint64 之间进行转换来解决此问题。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> CASFloatCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span> number <span class="token builtin">uint64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">NewCASFloatCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>CASFloatCounter <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span>CASFloatCounter<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>CASFloatCounter<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>num <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">{</span>  v <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">)</span>  newValue <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">Float64bits</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Float64frombits</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> num<span class="token punctuation">)</span>  <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">,</span> v<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>CASFloatCounter<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Float64frombits</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">LoadUint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这篇文章是共享计数器的实现汇总。这是我好奇心驱使的结果，此外对并发也有一个基本的了解。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 索引下推</title>
      <link href="/2021/09/15/mysql-suo-yin-xia-tui/"/>
      <url>/2021/09/15/mysql-suo-yin-xia-tui/</url>
      
        <content type="html"><![CDATA[<p><strong>回表操作</strong></p><p>对于数据库来说，只要涉及到索引，必然绕不过去回表操作。当然这也是我们今天所讲内容的前置基础。</p><p>说到回表，我们需要从索引开始说起。别担心，不会长篇大论，这里只是简单讲下主键索引与普通索引，目的是让大家对回表操作有个认识。如果你对回表操作很熟悉了，那么可以跳过这一段。</p><p>这里我们只以 InnoDB 存储引擎作为讲解对象。</p><p><strong>主键索引</strong></p><p>主键索引在底层的数据存储是通过 B+ 树来实现的。简单来说，就是除叶子节之外的其他节点都存储的是主键值。而叶子节点上存储的是整行的数据。</p><p>大体结构如下图所示。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syxt-2.jpg"></p><p><strong>非主键索引</strong></p><p>除了主键索引外，其它的索引都被称为非主键索引。与主键索引不同的是，非主键索引的叶子节点上存储的是主键的值。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syxt-3.jpg"></p><p>那让我们再回到刚开始的问题：什么是回表操作？</p><p>当我们在非主键索引上查找一行数据时，此时的查找方式是先搜索非主键索引树，拿到对应的主键值，再到主键索引树上查找对应的行数据。</p><p>这种操作就叫作回表操作。</p><p>好了，这里你应该了解了什么是回表操作了。</p><p>简单来讲，就是在非主键索引树上拿到对应的主键值，然后再回到主键索引上找到对应的行数据。</p><p>这样做的前提条件是，所要查找的字段不存在于非主键索引树上。</p><p><strong>低版本实现</strong></p><p>讲完了回表操作，让我们继续回到这篇文章的主题——索引下推。</p><p>其实在 MySQL 5.6 版本之前是没有索引下推这个功能的，从 5.6 版本后才加上了这个优化。所以在引出索引下推前，我们还是先来回顾下没有这个功能时是怎样一种处理方式。</p><p>我们以一个真实例子来进行讲解。</p><p>在这里有张用户表 user，记录着用户的姓名，性别，身高，年龄等信息。表中 id 是自增主键，(name,sex) 是联合索引。在这里用 1 表示男，2 表示女。现在需要查找所有姓王的男性信息。</p><p>SQL 实现起来很简单：</p><p><img src="https://image.fyxemmmm.cn/blog/images/syxt-4.jpg"></p><p>但是它的实现原理是什么呢？</p><p>根据联合索引最左前缀原则，我们在非主键索引树上找到第一个满足条件的值时，通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比是否为当前所要查找的性别。</p><p>整个原理可以用下边的图进行表示。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syxt-5.jpg"></p><p>看到了吧，低版本中需要每条数据都进行回表，增加了树的搜索次数。如果遇到所要查找的数据量很大的话，性能必然有所缺失。</p><p><strong>高版本实现</strong></p><p>讲完了低版本实现，让我们继续回到这篇文章的主题——索引下推。</p><p>知道了痛点，那怎么解决？很简单，只有符合条件了再进行回表。结合我们的例子来说就是当满足了性别 sex = 1 ，再回表查找。这样原本可能需要进行回表查找 4 次，现在可能只需要 2 次就可以了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/syxt-6.jpg"></p><p>所以本质来说，索引下推就是只有符合条件再进行回表，对索引中包含的字段先进行判断，不符合条件的跳过，减少了不必要的回表操作。</p><p><strong>总结</strong></p><p><strong>回表操作</strong></p><ul><li>当所要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据，这个过程称为回表操作。</li></ul><p><strong>索引下推</strong></p><ul><li>索引下推主要是减少了不必要的回表操作。对于查找出来的数据，先过滤掉不符合条件的，其余的再去主键索引树上查找。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引下推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang string与bytes的转换</title>
      <link href="/2021/09/11/golang-string-bytes-mi-mi/"/>
      <url>/2021/09/11/golang-string-bytes-mi-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="byte类型"><a href="#byte类型" class="headerlink" title="byte类型"></a>byte类型</h2><p>我们看一下官方对<code>byte</code>的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span><span class="token comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span><span class="token comment">// integer values.</span><span class="token keyword">type</span> <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token builtin">uint8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到<code>byte</code>就是<code>uint8</code>的别名，它是用来区分<strong>字节值</strong>和<strong>8位无符号整数值</strong>。</p><p>其实可以把<code>byte</code>当作一个<code>ASCII</code>码的一个字符。</p><p>示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token number">65</span><span class="token keyword">var</span> ch <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token string">'\x41'</span><span class="token keyword">var</span> ch <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token string">'A'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="byte类型-1"><a href="#byte类型-1" class="headerlink" title="[]byte类型"></a><code>[]byte</code>类型</h2><p><code>[]byte</code>就是一个<code>byte</code>类型的切片，切片本质也是一个结构体，定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// src/runtime/slice.go</span><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">{</span>    array unsafe<span class="token punctuation">.</span>Pointer    <span class="token builtin">len</span>   <span class="token builtin">int</span>    <span class="token builtin">cap</span>   <span class="token builtin">int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里简单说明一下这几个字段，<code>array</code>代表底层数组的指针，<code>len</code>代表切片长度，<code>cap</code>代表容量。看一个简单示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> sl <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> sl <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>sl<span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span> sl <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>sl<span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据这个例子我们可以画一个图：<img src="https://image.fyxemmmm.cn/blog/images/wxbs1.png"></p><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>先来看一下<code>string</code>的官方定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// string is the set of all strings of 8-bit bytes, conventionally but not</span><span class="token comment">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><span class="token comment">// not nil. Values of string type are immutable.</span><span class="token keyword">type</span> <span class="token builtin">string</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>string</code>是一个<code>8</code>位字节的集合，通常但不一定代表UTF-8编码的文本。string可以为空，但是不能为nil。<strong>string的值是不能改变的</strong>。</p><p>看一个简单的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> str <span class="token operator">:=</span> <span class="token string">"asong"</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>string</code>类型本质也是一个结构体，定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> stringStruct <span class="token keyword">struct</span> <span class="token punctuation">{</span>    str unsafe<span class="token punctuation">.</span>Pointer    <span class="token builtin">len</span> <span class="token builtin">int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>stringStruct</code>和<code>slice</code>还是很相似的，<code>str</code>指针指向的是某个数组的首地址，<code>len</code>代表的就是数组长度。怎么和<code>slice</code>这么相似，底层指向的也是数组，是什么数组呢？我们看看他在实例化时调用的方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//go:nosplit</span><span class="token keyword">func</span> <span class="token function">gostringnocopy</span><span class="token punctuation">(</span>str <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span> ss <span class="token operator">:=</span> stringStruct<span class="token punctuation">{</span>str<span class="token punctuation">:</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">:</span> <span class="token function">findnull</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">}</span> s <span class="token operator">:=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ss<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>入参是一个<code>byte</code>类型的指针，从这我们可以看出<code>string</code>类型底层是一个<code>byte</code>类型的数组，所以我们可以画出这样一个图片：</p><p><img src="https://image.fyxemmmm.cn/blog/images/wxbs2.png"></p><h2 id="string和-byte有什么区别"><a href="#string和-byte有什么区别" class="headerlink" title="string和[]byte有什么区别"></a>string和[]byte有什么区别</h2><p>上面我们一起分析了<code>string</code>类型，其实他底层本质就是一个<code>byte</code>类型的数组，那么问题就来了，<code>string</code>类型为什么还要在数组的基础上再进行一次封装呢？</p><p>这是因为在<code>Go</code>语言中<code>string</code>类型被设计为不可变的，不仅是在<code>Go</code>语言，其他语言中<code>string</code>类型也是被设计为不可变的，这样的好处就是：在并发场景下，我们可以在不加锁的控制下，多次使用同一字符串，在保证高效共享的情况下而不用担心安全问题。</p><p><code>string</code>类型虽然是不能更改的，但是可以被替换，因为<code>stringStruct</code>中的<code>str</code>指针是可以改变的，只是指针指向的内容是不可以改变的。看个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> str <span class="token operator">:=</span> <span class="token string">"song"</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> str <span class="token operator">=</span> <span class="token string">"asong"</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 运行结果</span><span class="token number">0xc00001a090</span><span class="token number">0xc00001a098</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看出来，指针指向的位置发生了变化，也就说每一个更改字符串，就需要重新分配一次内存，之前分配的空间会被<code>gc</code>回收。</p><h2 id="string和-byte标准转换"><a href="#string和-byte标准转换" class="headerlink" title="string和[]byte标准转换"></a>string和[]byte标准转换</h2><p><code>Go</code>语言中提供了标准方式对<code>string</code>和<code>[]byte</code>进行转换，先看一个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> str <span class="token operator">:=</span> <span class="token string">"asong"</span> by <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> str1 <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>by<span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准转换用起来还是比较简单的，那你知道他们内部是怎样实现转换的吗？我们来分析一下：</p><ul><li><code>string</code>类型转换到<code>[]byte</code>类型</li></ul><p>我们对上面的代码执行如下指令<code>go tool compile -N -l -S ./string_to_byte/string.go</code>，可以看到调用的是<code>runtime.stringtoslicebyte</code>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// runtime/string.go go 1.15.7</span><span class="token keyword">const</span> tmpStringBufSize <span class="token operator">=</span> <span class="token number">32</span><span class="token keyword">type</span> tmpBuf <span class="token punctuation">[</span>tmpStringBufSize<span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">func</span> <span class="token function">stringtoslicebyte</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>tmpBuf<span class="token punctuation">,</span> s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token keyword">if</span> buf <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">*</span>buf <span class="token operator">=</span> tmpBuf<span class="token punctuation">{</span><span class="token punctuation">}</span>  b <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  b <span class="token operator">=</span> <span class="token function">rawbyteslice</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token function">copy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token keyword">return</span> b<span class="token punctuation">}</span><span class="token comment">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span><span class="token keyword">func</span> <span class="token function">rawbyteslice</span><span class="token punctuation">(</span>size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token builtin">cap</span> <span class="token operator">:=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> p <span class="token operator">:=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">!=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token operator">-</span><span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>slice<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> slice<span class="token punctuation">{</span>p<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里分了两种状况，通过字符串长度来决定是否需要重新分配一块内存。也就是说预先定义了一个长度为<code>32</code>的数组，字符串的长度超过了这个数组的长度，就说明<code>[]byte</code>不够用了，需要重新分配一块内存了。这也算是一种优化吧，<code>32</code>是阈值，只有超过<code>32</code>才会进行内存分配。</p><p>最后我们会通过调用<code>copy</code>方法实现string到[]byte的拷贝，具体实现在<code>src/runtime/slice.go</code>中的<code>slicestringcopy</code>方法，这里就不贴这段代码了，这段代码的核心思路就是：<strong>将string的底层数组从头部复制n个到[]byte对应的底层数组中去</strong></p><ul><li><code>[]byte</code>类型转换到<code>string</code>类型</li></ul><p><code>[]byte</code>类型转换到<code>string</code>类型本质调用的就是<code>runtime.slicebytetostring</code>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 以下无关的代码片段</span><span class="token keyword">func</span> <span class="token function">slicebytetostring</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>tmpBuf<span class="token punctuation">,</span> ptr <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span> <span class="token punctuation">}</span> <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>  p <span class="token operator">:=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>staticuint64s<span class="token punctuation">[</span><span class="token operator">*</span>ptr<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> sys<span class="token punctuation">.</span>BigEndian <span class="token punctuation">{</span>   p <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">=</span> p  <span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token keyword">return</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> p unsafe<span class="token punctuation">.</span>Pointer <span class="token keyword">if</span> buf <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>  p <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">=</span> p <span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> n <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码我们可以看出会根据<code>[]byte</code>的长度来决定是否重新分配内存，最后通过<code>memove</code>可以拷贝数组到字符串。</p><h2 id="string和-byte强转换"><a href="#string和-byte强转换" class="headerlink" title="string和[]byte强转换"></a>string和[]byte强转换</h2><p>标准的转换方法都会发生内存拷贝，所以为了减少内存拷贝和内存申请我们可以使用强转换的方式对两者进行转换。在标准库中有对这两种方法实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// runtime/string.go</span><span class="token keyword">func</span> <span class="token function">slicebytetostringtmp</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token function">stringStructOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> n <span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">stringtoslicebytetmp</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>    str <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>stringStruct<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>    ret <span class="token operator">:=</span> slice<span class="token punctuation">{</span>array<span class="token punctuation">:</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">:</span> str<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">:</span> str<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这两个方法我们可知道，主要使用的就是<code>unsafe.Pointer</code>进行指针替换，为什么这样可以呢？因为<code>string</code>和<code>slice</code>的结构字段是相似的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> stringStruct <span class="token keyword">struct</span> <span class="token punctuation">{</span>    str unsafe<span class="token punctuation">.</span>Pointer    <span class="token builtin">len</span> <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">{</span>    array unsafe<span class="token punctuation">.</span>Pointer    <span class="token builtin">len</span>   <span class="token builtin">int</span>    <span class="token builtin">cap</span>   <span class="token builtin">int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唯一不同的就是<code>cap</code>字段，<code>array</code>和<code>str</code>是一致的，<code>len</code>是一致的，所以他们的内存布局上是对齐的，这样我们就可以直接通过<code>unsafe.Pointer</code>进行指针替换。</p><h2 id="两种转换如何取舍"><a href="#两种转换如何取舍" class="headerlink" title="两种转换如何取舍"></a>两种转换如何取舍</h2><p>当然是推荐大家使用标准转换方式了，毕竟标准转换方式是更安全的！但是如果你是在高性能场景下使用，是可以考虑使用强转换的方式的，但是要注意强转换的使用方式，他不是安全的，这里举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">stringtoslicebytetmp</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span> str <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>reflect<span class="token punctuation">.</span>StringHeader<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> ret <span class="token operator">:=</span> reflect<span class="token punctuation">.</span>SliceHeader<span class="token punctuation">{</span>Data<span class="token punctuation">:</span> str<span class="token punctuation">.</span>Data<span class="token punctuation">,</span> Len<span class="token punctuation">:</span> str<span class="token punctuation">.</span>Len<span class="token punctuation">,</span> Cap<span class="token punctuation">:</span> str<span class="token punctuation">.</span>Len<span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> str <span class="token operator">:=</span> <span class="token string">"hello"</span> by <span class="token operator">:=</span> <span class="token function">stringtoslicebytetmp</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> by<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">unexpected fault address <span class="token number">0x109d65f</span>fatal <span class="token builtin">error</span><span class="token punctuation">:</span> fault<span class="token punctuation">[</span>signal SIGBUS<span class="token punctuation">:</span> bus <span class="token builtin">error</span> code<span class="token operator">=</span><span class="token number">0x2</span> addr<span class="token operator">=</span><span class="token number">0x109d65f</span> pc<span class="token operator">=</span><span class="token number">0x107eabc</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以看到程序直接发生严重错误了，即使使用<code>defer</code>+<code>recover</code>也无法捕获。原因是什么呢？</p><p>我们前面介绍过，<code>string</code>类型是不能改变的，也就是底层数据是不能更改的，这里因为我们使用的是强转换的方式，那么<code>by</code>指向了<code>str</code>的底层数组，现在对这个数组中的元素进行更改，就会出现这个问题，导致整个程序<code>down</code>掉！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们一起分析<code>byte</code>和<code>string</code>类型的基本定义，也分析了<code>[]byte</code>和<code>string</code>的两种转换方式，应该还差最后一环，也就是大家最关心的性能测试，这个我没有做，我觉得没有很大意义，通过前面的分析就可以得出结论，强转换的方式性能肯定要比标准转换要好。对于这两种方式的使用，大家还是根据实际场景来选择，脱离场景的谈性能就是耍流氓！</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux の 文件系统</title>
      <link href="/2021/09/09/linux-wen-jian-xi-tong-mi-mi/"/>
      <url>/2021/09/09/linux-wen-jian-xi-tong-mi-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统听起来很高大上，通俗话就用来<strong>存数据的一个容器</strong>而已，本质和你的行李箱、仓库没有啥区别。只不过文件系统存储的是数字产品而已。我有一个视频文件，我把这个视频放到这个文件系统里，下次来拿，要能拿到我完整的视频文件数据，这就是文件系统，<strong>对外提供的就是存取服务</strong>。</p><h3 id="现实的存取场景"><a href="#现实的存取场景" class="headerlink" title="现实的存取场景"></a>现实的存取场景</h3><p>就跟你在火车站使用的寄存服务一样，包裹我能存进去，稍后我能取出来，就可以了。问题来了，存进去？怎么取？仔细回忆下存储行李的场景。</p><p><strong>存行李的时候</strong>，是不是要登记一些个人信息？对吧，至少自己名字要写上。可能还会给你一个牌子，让你挂手上，这个东西就是为了标示每一个唯一的行李。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-0.gif" alt="存行李演示"></p><p><strong>取行李的时候</strong>，要报自己名字，有牌子的给他牌子，然后工作人员才能去特定的位置找到你的行李（不然机场那么多人，行李都长差不多，他肯定不知道你的行李是哪个）。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-1.gif" alt="取行李演示"></p><p>**划重点：存的时候必须记录一些关键信息（记录ID、给身份牌），取的时候才能正确定位到。<br> **</p><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>回到我们的文件系统，对比上面的行李存取行为，可以做个简单的类比；</p><ol><li>登记名字就是在文件系统记录文件名；</li><li>生成的牌子就是元数据索引；</li><li>你的行李就是文件；</li><li>寄存室就是磁盘（容纳东西的物理空间）；</li><li>管理员整套运行机制就是文件系统；</li></ol><p>上面的对应并不是非常严谨，仅仅是帮助大家理解文件系统而已，让大家知道其实文件系统是非常朴实的一个东西，思想都来源于生活。</p><p><strong>划重点：文件系统的存储介质是磁盘，文件系统是软件层面的，是管理员，管理怎么使用磁盘空间的软件系统而已。</strong></p><h4 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h4><p>现在思考文件系统是怎么管理空间的？</p><p>如果，一个连续的大磁盘空间给你使用，你会怎么使用这段空间呢？</p><p>直观的一个想法，我把进来的数据就完整的放进去。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-2.gif" alt="不好的空间管理方式"></p><p>这种方式非常容易实现，属于眼前最简单，以后最麻烦的方式。因为会造成很多空洞，明明还有很多空间位置，但是由于整个太大，形状不合适（数据大小），哪里都放不下。因为你要放一个完整的空间。</p><p>这种不能利用的空间我们称之为碎片，准确的说是<strong>外部碎片</strong>，这种碎片在内存池分配内存的时候最常见，产生的原理是一样的。</p><p>怎么改进？有人会想，既然整个放不进去，那就剁碎了呗。这里塞一点，那里塞一点，就塞进去了。</p><p>对，思路完全正确。<strong>改进的方式就是切分，把空间按照一定粒度切分</strong>。每个小粒度的物理块命名为 Block，每个 Block 一般是 4K 大小，用户数据存到文件系统里来自然也是要切分，存储到每一个 Block 。Block 粒度越小则外部碎片则会越少（注意：元数据量会越大），可以尽可能的利用到空间，并且完整的用户数据文件存储到磁盘上则不再连续，而是切成一个个 Block 大小的数据块存到磁盘的各个角落上。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-3.gif" alt="切分后的管理方式"></p><p>图示标号表示这个完整对象的 Block 的序号，用来复原对象用的。</p><p>随之而来又有一个问题：你光会切成块还不行，取文件数据的时候，要给完整的用户数据出去，用户不管你内部怎么实现，他只想要的是最初的样子。<strong>所以，要有一个表记录该文件对应所有 Block 的位置</strong>，要把每一个 Block 的位置记录好，取文件的时候，对照这表恢复出一个完整的块给到用户。</p><p>所以，写流程再完善一下就是这样子：</p><ol><li>先写数据：数据先按照 Block 粒度存储到磁盘的各个位置；</li><li>再写元数据：然后把 Block 所在的各个位置保存起来，这也就是元数据，文件系统里叫做 inode（我用一本书来表示）；</li></ol><p><img src="https://image.fyxemmmm.cn/blog/images/cp-4.gif" alt="文件系统write"></p><p>文件读流程则是：</p><ol><li>先读元数据，找到各个 Block 的位置；</li><li>然后读数据，构造一个完整的文件，给到用户；</li></ol><p><img src="https://image.fyxemmmm.cn/blog/images/cp-5.gif" alt=" 文件系统read"></p><h4 id="inode-block-概念"><a href="#inode-block-概念" class="headerlink" title="inode/block 概念"></a>inode/block 概念</h4><p>好，现在我们引出了两个概念：</p><ol><li>磁盘空间是按照 Block 粒度来划分空间的，存储数据的区域全都是 Block，我们叫做数据区域；</li><li>文件存储不再连续存储在磁盘上，所以需要记录元数据，这个我们叫做 inode；</li></ol><p>文件系统中，一个 inode 唯一对应一个文件，inode 的个数则是在文件系统格式化的时候就确定好了的，换言之，<strong>一个 local 文件系统支持的文件数是天然就有上限的</strong>。</p><p>block 固定大小，每个 4k（大部分文件系统都是，这里不做纠结），block 意图存储打散的用户数据。</p><p>无论是 inode 区，还是 block 区，本质上都是在线性的磁盘空间上。文件系统的空间层次如下：</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-6.jpg"></p><p>一个文件的对应一个 inode，这个文件需要按照 Block 切分存储在磁盘上，存储的位置则由 inode 记录起来，通过 inode 则能找到 block，也就获取到用户数据。</p><p>现在有一个新的小问题，inode 区和 block 区都是在初始化就构造好的。存储一个文件的时候，需要取一个空闲的 inode，然后把数据切分成 4k 大小存储到空闲的 block 上，对吧？</p><p><strong>划重点：空闲的inode，空闲的 block。</strong> 这个很关键，已经存储了数据的地方不能再让写，不然会把别人的数据覆盖掉。</p><p>那么，怎么区分空闲和已经在用的 inode ，block 呢？</p><p><strong>答案是 ：inode 区和 block 区分别需要另一张表，用来表示 inode 是否在用，block 是否在用，这个表的名字我们叫做 bitmap 表</strong>。bitmap 是一个 bit 数组，用 0 表示空闲，1 表示在用，如下：</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-7.jpg" alt="文件系统架构"></p><p>bitmap 什么时候用呢？自然是写的时候，也就是分配 inode 或者 block 的时候，因为只有分配的时候，你才需要找空闲的空间。</p><p>上图我为了突出本质思想，类似于超级块，块描述符都省略了，这个感兴趣可以自己扩展，这里只突出主干哈。</p><p><strong>小结一下</strong>：</p><ol><li>bitmap 本质是个 bit 数组，占用空间极其少，用 0 来表示空闲，1 表示在用。使用时机是在创建文件，或者写数据的时候；</li><li>inode 则对应一个文件，里面存储的是元数据，主要是数据 block 的位置信息；</li><li>block 里面存储的是用户数据，用户数据按照 block 大小（4k）切分，离散的分布在磁盘上。读的时候只有依赖于 inode 里面记录的位置才能恢复出完整的文件；</li><li>inode 和 block 的总个数在文件系统格式化的时候就确定了，所以文件数和文件大小都是有上限的；</li></ol><h4 id="一个文件真实的模样"><a href="#一个文件真实的模样" class="headerlink" title="一个文件真实的模样"></a>一个文件真实的模样</h4><p>上面是抽象的样子，现在我们看一个真实的 inode -&gt; block 的样子。一个文件除了数据需要存储之外，一些元信心也需要存储，例如文件类型，权限，文件大小，创建/修改/访问时间等，这些信息存在 inode 中，每个文件唯一对应一个inode 。</p><p>看一下 inode 的数据结构（就以 linxu ext2 为例，该结构定义在 <code>linux/fs/ext2/ext2.h</code> 头文件中 ）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ext2_inode</span> <span class="token punctuation">{</span>    __le16  i_mode<span class="token punctuation">;</span>     <span class="token comment">/* File mode */</span>    __le16  i_uid<span class="token punctuation">;</span>      <span class="token comment">/* Low 16 bits of Owner Uid */</span>    __le32  i_size<span class="token punctuation">;</span>     <span class="token comment">/* Size in bytes */</span>    __le32  i_atime<span class="token punctuation">;</span>    <span class="token comment">/* Access time */</span>    __le32  i_ctime<span class="token punctuation">;</span>    <span class="token comment">/* Creation time */</span>    __le32  i_mtime<span class="token punctuation">;</span>    <span class="token comment">/* Modification time */</span>    __le32  i_dtime<span class="token punctuation">;</span>    <span class="token comment">/* Deletion Time */</span>    __le16  i_gid<span class="token punctuation">;</span>      <span class="token comment">/* Low 16 bits of Group Id */</span>    __le16  i_links_count<span class="token punctuation">;</span>  <span class="token comment">/* Links count */</span>    __le32  i_blocks<span class="token punctuation">;</span>   <span class="token comment">/* Blocks count */</span>    __le32  i_flags<span class="token punctuation">;</span>    <span class="token comment">/* File flags */</span>    __le32  i_block<span class="token punctuation">[</span>EXT2_N_BLOCKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* Pointers to blocks */</span>    __le32  i_file_acl<span class="token punctuation">;</span> <span class="token comment">/* File ACL */</span>    __le32  i_dir_acl<span class="token punctuation">;</span>  <span class="token comment">/* Directory ACL */</span>    __le32  i_faddr<span class="token punctuation">;</span>    <span class="token comment">/* Fragment address */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重点</strong>：</p><ul><li>上面的结构 mode，uid，size，time 等信息就是我们常说的文件类型，大小，创建修改等时间元数据；</li><li>注意到 <code>i_block[EXT2_N_BLOCKS]</code>  这个字段，这个字段将会带你找到数据, 因为里面存储的就是 block 所在的位置，也就是 block 的编号；</li></ul><p>再来，理解下什么叫做 block 的位置（编号）。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-8.jpg" alt="磁盘划分 block"></p><p><strong>位置就是编号，记录位置就是记录编号，编号就是索引。</strong></p><p>我们看到有一个数组：<code>i_block[EXT2_N_BLOCKS]</code>，这个数组是存储 block 位置的数组。其中 <code>EXT2_N_BLOCKS</code> 是一个宏定义，值为 15 。也就是说，<code>i_block</code> 是一个 15 个元素的数组，每个元素是 4 字节（32 bit）大小。</p><p>举个例子，假设我们现在有一个 6k 的文件，那么只需要 2 个 block 就可以存下了，假设现在数据就存储在编号为 3 和 101  这两个 block 上，那么如下图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-9.jpg" alt="inode 文件索引"></p><p><code>i_block[15]</code> 第一个元素存的是 3，第二个存储的是 101，其他槽位没用用到，<strong>由于 inode 的内存是置零分配的，所以里面的值为 0，表示没有在使用</strong> . 我们通过 [3, 101] 这两个 block 就能拼装出完整的用户数据了。用户的 6k 文件组成如下：</p><ol><li>第一个 4k 数据在 [3<em>4K, 4</em>4K] 范围；</li><li>第二个 2k 数据在 [ 101<em>4K, 101</em>4K+2K] 范围；</li></ol><p>好，现在我们知道了<strong>每个定长 block 都有唯一编号</strong>，我们的 <strong><code>i_block[15]</code> 数组 通过有序存储这个编号找到文件数据所在的位置</strong>，并且拼装出完整文件。</p><p><strong>思考问题：区分文件的切分成 4k 块的编号和 磁盘上物理 4k 块的编号的区别。</strong></p><p>举个栗子，一个文件 12K 的大小，那么按照 4K 切分会存储到 2 个 物理 block 上。</p><p>文件第 0 个 4k 存储到了 101 这个物理 block 上；<br> 文件第 1 个 4k 存储到了 30  这个物理 block 上；<br> 文件第 2 个 4k 存储到了 11  这个物理 block 上；</p><p>文件逻辑空间上的编号是从 0 开始，到 2 结束，对应存储的物理块编号分别是 101，30，11 。</p><p><strong>思考问题：这么一个 inode 结构能够表示多大的文件？</strong></p><p>我们看到 <code>inode-&gt;i_block[15]</code> 是一个一维数组，里面能存 15 个元素。也就是能存 15 个 block 的编号，那么如果直接存储文件的 block 编号最大能表示 60K (15*4K) 的文件。换句话说，如果我拿着 15 个槽位全部用来存储文件的编号，这个文件系统支撑的最大文件却就是 60K。惊呆了？（注意：ext2 文件系统是可以创建 4T 以内的文件的！！）</p><p>那我们自然会思考，怎么解决呢？怎么才能支撑更大的文件？</p><p>最直接思考就是用更大的数组，把 <code>inode-&gt;i_block</code>  数组变得更大。比如，如果你想要支持 100G 的文件：</p><p>那么，需要 i_block 数组大小为 26214400 （计算公式：<code>100\*1024\*1024/4</code>），也就是要分配一个 <code>i_block[26214400]</code>  的数组。</p><p>每个编号占用 4 字节，这个数组就占用 100M 的空间（计算公式：(<code>26214400\*4)/1024/1024</code>）。</p><p>100M ！这里就有点夸张了，注意到 <code>i_block</code> 只是一个 inode 内部的字段，是一个静态分配的数组，也就是说，<strong>这个文件系统为了支持最大 100G 的文件存入，每一个 inode 都要占用 100M 的内存，就算你是一个 1K 的文件，inode 也会占用这么大的内存空间</strong>。并且，这种方案扩展性差，支持的文件 size 越大，<code>i_block[N]</code> 消耗内存情况越严重。</p><p>这是无法接受的。那么怎么才能解决这个问题呢？怎么才能让你既能表示更大的文件，又能不浪费占用空间？</p><p>我们仔细分析这个问题，你会发现，这里有 2 个核心问题：</p><ol><li>第一点，核心在于浪费内存空间（关键点是要保证 inode 内存结构的稳定，无论文件怎么变，inode 结构本身不能变）；</li><li>第二点，仔细思考你会发现，无论是什么神仙方案，如果你要存储一个按照 4k 切分的 100G 文件，都是需要 100M 的空间来存储索引（ block 编号），但是 99.99% 的文件可能都没有这么大；</li></ol><p>我们前面用一个大数组来一把存储 block 编号的方案固然简单，但是问题在于太过死板。核心问题在于存储 block 编号的数组是预分配的，为了还没有发生并且 99% 场景都不会发生的事情（文件大小达到 100G），却不管三七二十一，提前准备好了完整的 block 索引数组，<strong>预分配就是浪费的根源</strong>。</p><p>那么知道了这两个问题，下一步分析下一个个解决：</p><h4 id="索引存磁盘"><a href="#索引存磁盘" class="headerlink" title="索引存磁盘"></a>索引存磁盘</h4><p><strong>问题一的解决：索引存磁盘</strong>：</p><p>既然问题在于浪费内存，inode 内存分配不灵活，那就可以看把 <code>inode-&gt;i_block</code> 下放到磁盘。</p><p>为什么？</p><p>因为磁盘的空间比内存大了不止一个量级。100M 对内存来说<strong>很大</strong>，对磁盘来说<strong>很小</strong>。换句话说，用把用户数据所在的 block 编号存到磁盘上去，这个也需要物理空间，使用的也是 block 来存储，只不过这种 block 存储的是 block 编号信息，而不是用户数据。</p><p>那么我们怎么通过 inode 找到用户数据呢？</p><p>因为这个 block 本身也有编号，我们则需要把这个存储用户 block 编号的 block 所在块的编号存储在 <code>inode-&gt;i_block[15]</code> 里，当读数据的时候，我们需要先找到这个存储编号的 block，然后再通过里面存储的用户数据所在的 block 编号找到用户所在的 block ，去读数据。</p><p>这个<strong>存储用户 block 编号的 block 所在块的编号</strong>我们叫做<strong>间接索引</strong>，然后我们根据跳转的次数可以分类成一级索引，二级索引，三级索引。顾名思义，一级索引就是跳转 1 次就能定位到用户数据，二级索引就是跳转 2 次，三级索引就是跳转 3 次才能定位到用户数据。那么 <code>inode-&gt;i_block[15]</code>  里面存储的可以直接定位到用户数据的 block 就是<strong>直接索引</strong>。</p><p>终于可以说回 ext2 的使用了，ext2 的 <code>inode-&gt;i_block[15]</code> 数组。知识点来了，按照约定，这 15 个槽位分作 4 个不同类别来用：</p><ol><li>前 12 个槽位（也就是 0 - 11 ）我们成为<strong>直接索引</strong>；</li><li>第 13 个位置，我们称为 <strong>1 级索引</strong>；</li><li>第 14 个位置，我们称为 <strong>2 级索引</strong>；</li><li>第 15 个位置，我们称为 <strong>3 级索引</strong>；</li></ol><p><img src="https://image.fyxemmmm.cn/blog/images/cp-10.jpg" alt="inode"></p><p>好，那我们在来看下直接索引，一级，二级，三级索引的表现力。</p><p><strong>直接索引</strong>：能存 12 个 block 编号，每个 block 4K，就是 48K，也就是说，48K 以内的文件，只需要用到 <code>inode-&gt;i_block[15]</code>  前 12 个槽位存储编号就能完全 hold 住。</p><p><strong>一级索引</strong>：</p><p><code>inode-&gt;i_block[12]</code> 这个位置存储的是一个一级索引，也就是说这里存储的编号指向的 block 里面存储的也是 block 编号，里面的编号指向用户数据。一个 block 4K，每个元素 4 字节，也就是有 1024 个编号位置可以存储。</p><p>所以，一级索引能寻址 4M（1024 * 4K）空间 。</p><p><strong>二级索引</strong>：</p><p>二级索引是在一级索引的基础上多了一级而已，换算下来，有了 4M 的空间用来存储用户数据的编号。所以二级索引能寻址 4G (4M/4 * 4K) 的空间。</p><p><strong>三级索引</strong>：</p><p>三级索引是在二级索引的基础上又多了一级，也就是说，有了 4G 的空间来存储用户数据的 block 编号。所以二级索引能寻址 4T （4G/4 * 4K） 的空间。</p><p><strong>最后，看一眼完整的表示图：</strong></p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-11.jpg" alt="间接寻址"></p><p>所以，在我们 ext2 的文件系统上，通过这种间接块索引的方式，最大能支撑的文件大小 = 48K + 4M + 4G + 4T ，约等于 4 T。文件系统最大支撑 16T 空间，因为 4 Byte 的整形最大数就是 <code>2^32=4294967296</code> ， 乘以 4K 就等于 16 T。</p><p>ext2 文件系统支持的最大单文件大小和文件系统最大容量就是这么算出来的（温馨提示：ext4 文件系统不仅兼容间接块的实现，还使用的是 extent 模式来管理的空间，最大支持单文件 16 TB ，文件系统最大 1 EB）。</p><p><strong>思考：这种多级索引寻址性能表现怎么样？</strong></p><p>在不超过 12 个数据块的小文件的寻址是最快的，访问文件中的任意数据理论只需要两次读盘，一次读 inode，一次读数据块。访问大文件中的数据则需要最多五次读盘操作：inode、一级间接寻址块、二级间接寻址块、三级间接寻址块、数据块。</p><h4 id="多级索引和后分配"><a href="#多级索引和后分配" class="headerlink" title="多级索引和后分配"></a>多级索引和后分配</h4><p><strong>问题二解决：多级索引和后分配</strong></p><p><strong>一级索引不够，表现力太差，预留空间又太浪费，不预留空间又无法扩展，怎么解决？</strong></p><p>既然问题在于预分配，我们使用后分配（瘦分配，或精简分配）解决。<strong>也就是说用户文件数据有多大，我才分配出多大的数组</strong>。举个例子，我们存储 100 G 的文件，那么就要用到三级索引块，最多分配 26214400 个槽位的数组（因为要 26214400 个 block）。如果是存储 6K 的文件，那么只需要 2 个槽位的数组。</p><p><strong>索引数组的后分配</strong></p><p>后分配这里说的是 block 索引编号数组的后分配，需要用到的时候才分配，而不是说，现在用户存储一个 1k 的文件，我上来就给他分配一个 100M 的索引数组，只是为了以后这个文件可能增长到 100 G。</p><p><strong>数据的后分配</strong></p><p>既然这里说到，关于后分配还有一个层面，就是数据所占的空间也是用到了才分配，这个也就是涉及到今天 cp的秘密的核心问题。</p><p><strong>实际的栗子</strong></p><p>先看下下正常的文件写入要做的事情（注意这里只描述主干，实际流程可能，有优化）：</p><ol><li>创建一个文件，这个时候分配一个 inode；</li><li>在 [ 0，4K ] 的位置写入 4K 数据，这个时候只需要 一个 block 假设编号 102，把这个编号写到 <code>inode-&gt;i_block[0]</code> 这个位置保存起来；</li><li>在 [ 1T，1T+4K ] 的位置写入 4K 数据，这个时候需要分配一个 block 假设编号 7，因为这个位置已经落到三级索引才能表现的空间了，所以需要还需要分配出 3 个索引块；</li><li>写入完成，close 文件；</li></ol><p>这里解释下文件偏移位置 [1T, 1T+4K] 为什么落到三级索引。</p><ol><li>offset 为 1T，按照 4K 切分，也就是 block 268435456 块（注意这个是虚拟文件块，不是物理位置）；</li><li>先算出范围：直接索引的范围是 [0, 11] 个，一级索引 [12, 1035]，二级索引 [1036, 1049611], 三级索引 [1049612, 1074791435]，（有人如果不知道怎么来的话，可以往前看看 inode 的结构，直接索引 12个，一级索引 1024 个，二级 1M 个，三级 1G 个，然后算出来的）；</li><li>268435456 落在三级索引 [1049612, 1074791435] 这个范围；</li></ol><p><strong>实际存储如图</strong>：</p><p>计算索引：</p><p>12 + 1024 + 1024 * 1024 + 1024 * 1024 * 254 + 1024 * 1022 + 1012 =  268435456</p><p>实际的物理分配如图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-12.jpg" alt="1T文件的存储块"></p><p>因为偏移已经用到了 3 级索引，所以除了用户数据的两个 block ，中间还需要 3 个间接索引 block 分配出来。</p><p>如果要读 [1T, 1T+4K] 这个位置的数据怎么办？</p><p><strong>流程如下</strong>：</p><ol><li>计算 offset 得出在第 268435456 的位置；</li><li>读出三级索引 <code>inode-&gt;i_block[14]</code> 里存储的 block 编号，找到对应的物理 block，这个是第一级的 block；</li><li>然后读该 block 的第 254+1 个槽位里的数据，里面存储的是第二级的 block 编号，把这个编号读出来，通过这个编号找到对应的物理 block；</li><li>读该 block 的第 1022 +1 个操作的数据，里面存储的是第三级的 block 编号，通过这个编号可以找到物理 block 的数据，里面存储的是用户数据所在 block 的编号；</li><li>读该 block 第 1012+1 个槽位里存储的编号，找到物理 block，这个 block 里存的就是用户数据了；</li></ol><p>这个时候，我们的文件看起来是超大文件，size 等于 1T+4K ，但里面实际的数据只有 8 K，位置分别是  [ 0，4K ] ，[ 1T，1T+4K ]。</p><p>重点：文件 size 只是 inode 里面的一个属性，实际物理空间占用则是要看用户数据放了多少个 block 。</p><p><strong>划重点：没写数据的地方不用分配物理 block 块</strong>。</p><p>没写数据不分配物理块？那是什么？那就是我们下面要说的稀疏文件。</p><h2 id="文件的稀疏语义"><a href="#文件的稀疏语义" class="headerlink" title="文件的稀疏语义"></a>文件的稀疏语义</h2><h3 id="什么是稀疏文件"><a href="#什么是稀疏文件" class="headerlink" title="什么是稀疏文件"></a>什么是稀疏文件</h3><p>终于到我们文件的稀疏语义了，稀疏语义什么意思？</p><p>稀疏文件英文名 sparse file 。稀疏文件本质上就是计算机文件，用户不感知，文件系统支持稀疏文件只是为了更有效率的使用磁盘空间而已。稀疏文件就是后分配空间的一种实现形式，做到真正用时才分配，最大效率的利用磁盘空间。</p><p>就以上面举的栗子，文件大小 1T，但是实际数据只有 8K，这种就是稀疏文件，<strong>逻辑大小和实际物理空间是可以不等的</strong>。文件大小只是一个属性，文件只是数据的容器，没有用户数据的位置可以不分配空间。</p><h3 id="为什么要支持稀疏语义？"><a href="#为什么要支持稀疏语义？" class="headerlink" title="为什么要支持稀疏语义？"></a>为什么要支持稀疏语义？</h3><p>还是以上面 1T 的文件举例，如果这 1T 的文件只有首尾分别写了 4K 的数据，而文件系统却要分配 1T 的物理空间，<strong>这里将带来巨大的浪费</strong>。何不等存了用户数据的时候再分配了，实际数据有多少，才去分配多大的 block ，何必着急的预分配呢？</p><p><strong>后分配本着用多少给多少的原则，尽量有效的利用空间。</strong></p><p>后分配还有一个优点，这也减少了首次写入的时间，怎么理解？</p><p>因为，如果文件大小 1T，就要分配 1T 的空间，那么初始分配需要写入全零到空间，否则上面的数据可能是随机数。</p><p><strong>对于稀疏文件空洞的地方，不占用物理空间，但要保证读的时候返回全 0 数据的语义，即可。</strong></p><p>又一个知识点：有时候稀疏文件的空洞和用户真正的全 0 数据是无法区分的，因为对外表现是一样的。</p><p><strong>稀疏文件也要文件系统支持，并不是所有的文件系统都支持稀疏语义，比如 ext2 就没有，ext4 才有稀疏语义，支持的标志是实现文件系统的 fallocate 接口。</strong></p><h3 id="怎么创建一个稀疏文件？"><a href="#怎么创建一个稀疏文件？" class="headerlink" title="怎么创建一个稀疏文件？"></a>怎么创建一个稀疏文件？</h3><p>可以使用 truncate 命令在一个 ext4 的文件系统创建一个文件。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">truncate -s 100G  test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>你 <code>ls -lh ./test.txt</code> 命令看会发现是一个 100 G 的文件；</li><li>但是 <code>du -sh ./test.txt</code>  会发现是一个 0 字节的文件；</li><li><code>stat ./test.txt</code> 会发现是 <code>Size: 107374182400 Blocks: 0</code> 的文件；</li></ul><p>这就是一个典型的稀疏文件。size 只是文件的逻辑大小，实际的物理空间占用还是得看 Blocks 这个数值。</p><p>下面这种 1T 的文件，因为只写了头尾 8K 数据，所以只需要分配 2 个 block 存储用户数据即可。</p><p><img src="https://image.fyxemmmm.cn/blog/images/cp-13.jpg" alt="1T文件的存储块"></p><p>好，我们再深入思考下，文件系统为什么能做到这个？</p><p>这也是为什么理解稀疏语义要先了解文件系统的实现的原因。</p><ol><li>首先，最关键的是把磁盘空间切成离散的、定长的 block 来管理；</li><li>然后，通过 inode 能查找到所有离散的数据（保存了所有的索引）；</li><li>最后，实现索引块和数据块空间的后分配；</li></ol><p>这三点是层层递进的。</p><h3 id="稀疏语义接口"><a href="#稀疏语义接口" class="headerlink" title="稀疏语义接口"></a>稀疏语义接口</h3><p>为了知识的完整性，简要介绍稀疏语义的几个接口：</p><ol><li>preallocate（预分配）：提供接口可以让用户预占用文件内指定范围的物理空间；</li><li>punch hole（打洞）：提供接口可以让用户释放文件内指定范围的物理空间；</li></ol><p>这两个操作刚好相反。</p><p>预分配的意思就是说，当你创建一个 1T的文件，如果你没写数据，这个时候其实没有分配物理空间的，支持稀疏语义的文件系统会提供一个 fallocate 接口给你，让你实现预分配，也就是说把这 1T 的物理空间现在就分配出来。</p><p><strong>思考：这个有什么好处呢？</strong></p><ul><li>第一，如果你命中注定要 1T 的空间，预分配是有好处的，把空间分配的工作量集中在初始化的时候一把做了，避免了实时现场分配的开销；</li><li>第二，如果不提前占坑，很有可能等你想要的时候已经没有空间可占用了。所以你把物理空间先占好，就可以安心使用了；</li></ul><p>linux 提供了一个 fallocate 命令，可以用来预分配空间。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">fallocate -o 0 -l 4096 ./test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令的意思就是给 <code>text.txt</code> 这个文件 [0, 4K] 的位置分配好物理空间。</p><p><strong>打洞（punch hole） 是干啥的呢？</strong></p><p>这个调用允许你把已经占用的物理空间释放掉，从而达到快速释放的目的。这种操作在虚拟机镜像的场景用得多，通常用于快速释放空间，punch hole 能够让业务更有效的利用空间。</p><p>linux 提供了一个 fallocate 命令也可以用来 punch hole 空间。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">fallocate -p -o 0 -l 4096 ./test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令的意思是把 <code>test.txt</code>  [ 0,  4K ] 的物理空间释放掉。</p><h3 id="稀疏文件的应用"><a href="#稀疏文件的应用" class="headerlink" title="稀疏文件的应用"></a>稀疏文件的应用</h3><h3 id="Go-语言实现"><a href="#Go-语言实现" class="headerlink" title="Go 语言实现"></a>Go 语言实现</h3><p>稀疏文件本身和编程语言无具体关系，我下面以 Go 为例，看下稀疏文件的预分配和打洞（punch hole）是怎么实现的。</p><p>预分配实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">PreAllocate</span><span class="token punctuation">(</span>f <span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> sizeInBytes <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token comment">// use mode = 1 to keep size</span>    <span class="token comment">// see FALLOC_FL_KEEP_SIZE</span>    <span class="token keyword">return</span> syscall<span class="token punctuation">.</span><span class="token function">Fallocate</span><span class="token punctuation">(</span><span class="token function">int</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">int64</span><span class="token punctuation">(</span>sizeInBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>punch hole 实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//  mode 0 change to size                  0x0</span><span class="token comment">//  FALLOC_FL_KEEP_SIZE                  = 0x1</span><span class="token comment">//  FALLOC_FL_PUNCH_HOLE                 = 0x2</span><span class="token keyword">func</span> <span class="token function">PunchHole</span><span class="token punctuation">(</span>file <span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> offset <span class="token builtin">int64</span><span class="token punctuation">,</span> size <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Fallocate</span><span class="token punctuation">(</span><span class="token function">int</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">Fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x1</span><span class="token operator">|</span><span class="token number">0x2</span><span class="token punctuation">,</span> offset<span class="token punctuation">,</span> size<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>ENOSYS <span class="token operator">||</span> err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>EOPNOTSUPP <span class="token punctuation">{</span>        <span class="token keyword">return</span> syscall<span class="token punctuation">.</span>EPERM    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，本质上都是系统调用 <code>fallocate</code> ，然后带不同的参数而已。指定文件偏移和长度，就能预分配物理空间或者释放物理空间了。</p><p>这里有一个知识点：punch hole 的调用要保证 4k 对齐才能释放空间。</p><p>举个例子，比如：</p><p>punch hole [0, 6k] 的数据，你会发现只有 [0, 4k] 的数据物理块被释放了，[4k, 6k] 所占的 4k 物理块还占着空间呢。</p><p>这个很容易理解，因为磁盘的物理空间是划分成 4k 的 block，这个是最小单位了，不能再分了，你无法切割一个最小的单位。</p><p><strong>值得注意的是，就算你没有 4k 对齐的发送调用，fallocate 也不会报错，这个请注意了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 文件系统 </tag>
            
            <tag> inode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解「进程间通讯」</title>
      <link href="/2021/09/07/jie-du-jin-cheng-jian-tong-xun/"/>
      <url>/2021/09/07/jie-du-jin-cheng-jian-tong-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>开场小故事</p></blockquote><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-1.jpg"></p><p>炎炎夏日，张三骑着单车去面试花了 1 小时，一路上汗流浃背。</p><p>结果面试过程只花了 5 分钟就结束了，面完的时候，天还是依然是亮的，还得在烈日下奔波 1 小时回去。</p><p><strong>面试五分钟，骑车两小时。</strong></p><p>你看，张三因面试没准备好，吹空调的时间只有 5 分钟，来回路上花了 2 小时晒太阳，你说惨不惨？</p><p>所以啊，炎炎夏日，为了能延长吹空调的时间，我们应该在面试前准备得更充分些，吹空调时间是要自己争取的。</p><p>很明显，在这一场面试中， 张三在<strong>进程间通信</strong>这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，<strong>应该需要进一步了解每种通信方式的优缺点及应用场景。</strong></p><p>说真的，我们这次一起帮张三一起复习下，加深他对进程间通信的理解，好让他下次吹空调的时间能长一点。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-2.jpg"></p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-3.jpg"></p><p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ps auxf | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</p><p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><p>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ mkfifo myPipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ls -lprw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来，我们往 myPipe 这个管道写入数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ echo "hello" &gt; myPipe  // 将数据写进管道                         // 停住了 ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ cat &lt; myPipe  // 读取管道里的数据hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p><p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><blockquote><p>那管道如何创建呢，背后原理是什么？</p></blockquote><p>匿名管道的创建，需要通过下面这个系统调用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">int pipe(int fd[2])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-4.jpg"></p><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-5.jpg"></p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li></ul><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-6.jpg"></p><p>所以说如果需要双向通信，则应该创建两个管道。</p><p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-7.jpg"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><hr><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><hr><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-8.jpg"></p><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-9.jpg"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p><p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-10.jpg"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><hr><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><hr><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">int socket(int domain, int type, int protocal)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM  表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>接下来，简单说一下这三种通信的编程模式。</p><blockquote><p>针对 TCP 协议通信的 socket 编程模型</p></blockquote><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-11.jpg"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><blockquote><p>针对 UDP 协议通信的 socket 编程模型</p></blockquote><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-12.jpg"></p><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><blockquote><p>针对本地进程间通信的 socket 编程模型</p></blockquote><p>本地 socket  被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p><ul><li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li><li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li></ul><p>好了，今日帮张三同学复习就到这了，希望张三同学早日收到心意的 offer，给夏天划上充满汗水的句号。</p><p><img src="https://image.fyxemmmm.cn/blog/images/jctx-13.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 通讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读懂oauth协议</title>
      <link href="/2021/09/06/oauth/"/>
      <url>/2021/09/06/oauth/</url>
      
        <content type="html"><![CDATA[<p>今天，我想登陆豆瓣，看看电影评论，陶冶陶冶情操。</p><p>但是，我从来没注册过豆瓣账号，而我又懒得再注册一个，怎么办呢？</p><p>我打开豆瓣的官网，笑了，原来豆瓣早就为我这种懒人想到了办法。</p><h2 id="懒人三步"><a href="#懒人三步" class="headerlink" title="懒人三步"></a>懒人三步</h2><p><strong>第一步</strong>：在豆瓣官网点击用 QQ 登陆。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-0.jpg"></p><p><strong>第二步</strong>：跳转到 qq 登录页面输入用户名密码，然后点授权并登录。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-1.jpg"></p><p><strong>第三步</strong>：跳回到豆瓣页面，成功登录。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-17.png"></p><p>太方便了！</p><p>但这短短的几秒钟，可不简单，我来给你说说。</p><h2 id="上帝视角看发生了什么"><a href="#上帝视角看发生了什么" class="headerlink" title="上帝视角看发生了什么"></a>上帝视角看发生了什么</h2><p>这几秒钟之内发生的事情，在<strong>外行的用户</strong>视角看来，就是在豆瓣官网上输了个 qq 号和密码就登录成功了。</p><p>在一些<strong>细心的用户</strong>视角看来，页面经历了从豆瓣到 qq，再从 qq 到豆瓣的两次页面跳转。</p><p>但作为一群<strong>专业的程序员</strong>，我们还应该从上帝视角来看这个过程。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-3.jpg"></p><p><strong>第一步：在豆瓣官网点击用 qq 登录</strong></p><p>当你点击用 qq 登录的小图标时，实际上是向豆瓣的服务器发起了一个请求。</p><p><code>http:// www.douban.com/leadToAuthorize</code></p><p>豆瓣服务器会响应一个重定向地址，指向 qq 授权登录的页面地址。</p><p><code>http:// www.qq.com/authorize</code></p><p>当然，这个重定向地址还附带了一个回调地址，这是在 QQ 那边登陆成功后需要跳回的豆瓣地址。</p><p><code>http://www.qq.com/authorize?callback=www.douban.com/callback</code></p><p>这跳回的地址是必然的嘛，不然 QQ 怎么知道在我这边登陆成功后我要干嘛，上杆子找人家 QQ 授权的网站那么多。</p><p>这部分的流程是黄色的这部分。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-4.jpg"></p><p><strong>第二步：跳转到 qq 登录页面输入用户名密码，然后点授权并登录</strong></p><p>上一步，浏览器接到重定向地址</p><p><code>http://www.qq.com/authorize?callback=www.douban.com/callback</code></p><p>自然没什么好说的，乖乖访问过去。</p><p>这回访问的就是 QQ 的页面了。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-5.jpg"></p><p>用户输入 QQ 号和密码，点击授权并登陆，这里走 QQ 服务器自己的校验逻辑，与豆瓣毫无关系。</p><p>若校验成功，会响应给浏览器一个重定向地址</p><p><code>www.douban.com/callback</code></p><p>没错，就是上一步传给 QQ 服务器的 callback 参数！</p><p>但除了这个地址外，还附上了一个 code，我们叫它<strong>授权码</strong>。</p><p><code>www.douban.com/callback?code=xxx</code></p><p>这个 code 是豆瓣服务唯一关心的事情，至于你那边如何校验用户，无所谓，只要最终能给我一个 code 码，我就认为这个用户在你那里登陆成功了。</p><p>这部分的流程是黄色的这部分。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-6.jpg"></p><p><strong>第三步：跳回到豆瓣页面，成功登录</strong></p><p>这一步背后的过程其实是最繁琐的，但对于用户来说是完全感知不到的。</p><p>用户在 QQ 登录页面点击授权登陆后，就直接跳转到豆瓣首页了，但其实经历了很多隐藏的过程。</p><p>首先接上一步，QQ 服务器在判断登录成功后，使页面重定向到之前豆瓣发来的 callback 并附上 code 授权码。</p><p><code>www.douban.com/callback?code=xxx</code></p><p>浏览器接到重定向，乖乖发起请求，此时请求的是<strong>豆瓣服务器</strong>。</p><p>豆瓣服务器收到请求后，对 QQ 服务器发起了两次请求：</p><ol><li><p>用拿到的 code 去换 token</p></li><li><p>再用拿到的 token 换取用户信息</p></li></ol><p>这个 code 和 token 都是有失效时间的，也因此保证了只要不在短时间内泄漏出去，就不会有安全风险。</p><p>拿到用户信息之后，就返回给了浏览器。注意此时的浏览器上是豆瓣的首页，豆瓣也因此可以将你的个人信息展示出来。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-17.png"></p><p>这部分的流程是黄色的这部分。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-8.jpg"></p><p>至此，整个过程结束。</p><p>这个破玩意，就叫做 <strong>OAuth 2.0 协议</strong>。</p><p>这个流程目的是让大家从全局了解 oauth2.0 协议实际上发生了什么，并仅仅以 oauth 的其中一种模式，<strong>授权码模式</strong>进行讲解。</p><p>如想了解更多模式，以及每次的请求和响应的标准齐全的参数，推荐读一下阮一峰的文章。</p><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><h2 id="为啥要这么跳来跳去"><a href="#为啥要这么跳来跳去" class="headerlink" title="为啥要这么跳来跳去"></a><strong>为啥要这么跳来跳去</strong></h2><p>为什么，要这么麻烦呢？跳来跳去的。</p><p>其实之所以有这个协议，我总结起来有两点原因：</p><p><strong>懒 + 不信任</strong></p><p><strong>懒</strong>是指用户懒。</p><p>如果用户不那么懒，直接在豆瓣上新注册一个账号就好了。</p><p><strong>不信任</strong>是什么意思呢？</p><p>如果用户信任豆瓣网站，那完全可以让用户在豆瓣网站输入 QQ 的用户名和密码，由豆瓣传给 QQ 服务器做校验，并返回用户信息。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-9.jpg"></p><p>但这是不可能的，你愿意把你的 QQ 号和密码给豆瓣看到？</p><p>更甚者，如果 QQ 信任豆瓣，用户也信任豆瓣，那 QQ 也可以把自己的数据库直接拷贝给豆瓣，然后豆瓣就可以完全自己拥有一套 QQ 用户数据了，也就可以让用户使用 QQ 登录。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-10.jpg"></p><p>当然，这也是不可能的。</p><p>所以就有了 OAuth 这种协议，你进行第三方授权时（文中的QQ），用户名和密码是不经过目标服务器的（文中的豆瓣），这保证了<strong>授权的安全性</strong>。</p><p>第三方授权服务器只给目标服务器返回有时效性的 code 和 token，目标服务器通过这个去第三方资源服务器，换取用户信息，这达成了<strong>拿到用户信息</strong>的目的。</p><p>所以总的来说，oauth 协议，就是由于三者（用户、目标、第三方）相互<strong>不信任</strong>，又想使用第三方服务器的<strong>授权功能</strong>，以及获取第三方服务器存储的<strong>用户信息</strong>，而产生的一个办法。</p><p>这个破玩意，就叫做 <strong>OAuth 2.0 协议</strong>。</p><p>哦，上面好像说过了。</p><h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a><img src="https://image.fyxemmmm.cn/blog/images/oauth-11.jpg"><strong>coding</strong></h2><p>了解了上述过程后，代码自然就不难写了。</p><p>这里我实现了一个极简版的 oauth2.0 用于体验这个过程，大家可以参考下。</p><p>项目结构非常简单，只有两个模块，分别是豆瓣和QQ，分别启动即可。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-12.jpg"></p><p>最终效果也非常简单清晰，下面请忍受 low 逼的显示效果</p><p><strong>第一步</strong>，登陆豆瓣页面。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-13.jpg"></p><p><strong>第二步</strong>，使用 QQ 页面进行授权。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-14.jpg"></p><p><strong>第三步</strong>，授权成功跳回豆瓣首页。</p><p><img src="https://image.fyxemmmm.cn/blog/images/oauth-18.png"></p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oauth </tag>
            
            <tag> 单点登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解读 「事务消息」</title>
      <link href="/2021/09/04/shi-wu-xiao-xi/"/>
      <url>/2021/09/04/shi-wu-xiao-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="还不知道事务消息吗？这篇文章带你全面扫盲！"><a href="#还不知道事务消息吗？这篇文章带你全面扫盲！" class="headerlink" title="[还不知道事务消息吗？这篇文章带你全面扫盲！]"></a>[还不知道事务消息吗？这篇文章带你全面扫盲！]</h1><p>在分布式系统中，为了保证数据一致性是必须使用分布式事务。分布式事务实现方式就很多种，今天主要介绍一下使用 RocketMQ 事务消息，实现分布事务。</p><h2 id="为什么需要事务消息？"><a href="#为什么需要事务消息？" class="headerlink" title="为什么需要事务消息？"></a>为什么需要事务消息？</h2><p>很多同学可能不知道事务消息是什么，没关系，举一个真实业务场景，先来带你了解一下普通的消息存在问题。</p><p><img src="https://image.fyxemmmm.cn/blog/images/sw1.jpg"></p><p>上面业务场景中，当用户支付成功，将会更新支付订单，然后发送 MQ 消息。手续费系统将会通过拉取消息，计算手续费然后保存到另外一个手续费数据库中。</p><p>由于计算手续费这个步骤可以离线计算，所以这里采用 MQ 解耦支付与计算手续费的流程。</p><p>流程主要涉及三个步骤：</p><ul><li>更新订单数据</li><li>发送消息给 MQ</li><li>手续费系统拉取消息</li></ul><p>上面提到的步骤，任何一个都会失败，如果我们没有处理，就会使两边数据不一致，将会造成下面两种情况：</p><ul><li><strong>订单数据更新了，手续费数据没有生成</strong></li><li><strong>手续费数据生成，订单数据却没有更新</strong></li></ul><p>这可是涉及到真正的钱，一旦少计算，就会造成<strong>资损</strong>，真的赔不起！</p><p>对于最后一步来讲，比较简单。如果消费消息失败，只要没有提交消息确认，MQ 服务端将会自动重试。</p><p><strong>最大的问题</strong>在于我们无法保证更新操作与发送消息一致性。无论我们采用先更新订单数据，再发送消息，还是先发送消息，再更新订单数据，都在存在一个成功，一个失败的可能。</p><p>如下所示，采用先发送消息，然后再更新数据库的方式。</p><p><img src="https://image.fyxemmmm.cn/blog/images/sw2.jpg"></p><p>上面流程消息发送成功之后，再进行本地事务的提交。这个流程看起来很完美，但是想象一下，如果在提交事务时数据库执行失败，导致事务回滚了。</p><p>然而此时消息已经发送出去，无法撤回。这就导致手续费系统紧接会消费消息，计算手续费并更新到数据库中。这就造成支付数据未更新，手续费系统却生成的不一致的情况。</p><p>那如果我们流程反一下，是不是就好了呢？</p><p><img src="https://image.fyxemmmm.cn/blog/images/sw3.jpg"></p><p>我们使用下面的伪码表示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 开始事务</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// 1.执行数据库操作</span>    <span class="token comment">// 2.提交事务</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 3.回滚事务</span><span class="token punctuation">}</span><span class="token comment">// 4.发送 mq 消息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里如果事务提交成功，但是 mq 消息发送失败，就会导致支付数据更新但是手续费数据未生成的的不一致情况。</p><p>这里有的同学可能会想到，将发送 mq 消息步骤移动到事务中，消息发送失败，回滚事务，不就完美了吗？</p><p>伪码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 开始事务</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token comment">// 1.执行数据库操作</span>  <span class="token comment">// 2.发送 mq 消息</span>  <span class="token comment">// 3.提交事务</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 4.回滚事务</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码看起来确实没什么问题，消息发送失败，回滚事务。</p><p>但是实际上第二步有可能存在消息已经发送到 MQ 服务端，但是由于网络问题未及时收到 MQ 的响应消息，从而导致消息发送端认为消息消息发送失败。</p><p>这就会导致订单事务回滚了，但是手续费系统却能消费消息，两边数据库又不一致了。</p><p>熟悉 MQ 的同学，可能会想到，消息发送失败，可以重试啊。</p><p>是的，我们可以增加重试次数，重新发送消息。但是这里我们需要注意，由于消息发送耦合在事务中，过多的重试会拉长数据库事务执行时间，事务处理时间过长，导致事务中锁的持有时间变长，影响整体的数据库吞吐量。</p><p>实际业务中，不太建议将消息发送耦合在数据库事务中。</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息是 RocketMQ 提供的<strong>事务</strong>功能，可以实现分布式事务，从而保证上面事务操作与消息发送要么都成功，要么都失败。</p><p>使用事务消息，整体流程如下：</p><p><img src="https://image.fyxemmmm.cn/blog/images/sw4.jpg"></p><p>首先我们将会发送一个半(<strong>half</strong>) 消息到 MQ 中，通知其开启一个事务。这里半消息并不是说消息内容不完整，实际上它包含所有完整的消息内容。</p><p>这个半消息与普通的消息唯一的区别在于，在事物提交之前，这个消息对消费者来说是<strong>不可见</strong>的，消费者不会消费这个消息。</p><p>一旦半消息发送成功，我们就可以执行数据库事务。然后根据事务的执行结果再决定提交或回滚事务消息。</p><p>如果事务提交成功，将会发送确认消息至 MQ，手续费系统就可以成功消费到这条消息。</p><p>如果事务被回滚，将会发送回滚通知至 MQ，然后 MQ 将会删除这条消息。对于手续费系统来说，都不会知道这条消息的存在。</p><p>这就解决了要么都成功，要么都失败的一致性要求。</p><p>实际上面的流程还是存在问题，如果我们<strong>提交/回滚</strong>事务消息失败怎么办？</p><p>对于这个问题，RocketMQ 给出一种<strong>事务反查</strong>的机制。我们需要需要注册一个回调接口，用于反查本地事务状态。</p><p>RocketMQ 若未收到提交或回滚的请求，将会定期去反查回调接口，然后可以根据反查结果决定回滚还是提交事务。</p><p>RocketMQ 事务消息流程整体如下：</p><p><img src="https://image.fyxemmmm.cn/blog/images/sw5.jpg"></p><p>事务消息示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionMQProducerExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">UnsupportedEncodingException</span> <span class="token punctuation">{</span>        <span class="token class-name">TransactionMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionMQProducer</span><span class="token punctuation">(</span><span class="token string">"test_transaction_producer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不定义将会使用默认的</span>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span>                        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>                        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"client-transaction-msg-check-thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> thread<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setExecutorService</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TransactionListener</span> transactionListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionListenerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setTransactionListener</span><span class="token punctuation">(</span>transactionListener<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 改成自己的地址</span>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Order</span> order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token string">"66666"</span><span class="token punctuation">,</span> <span class="token string">"books"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Message</span> msg <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"transaction_tp"</span><span class="token punctuation">,</span>                        JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 发送半消息</span>        <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">.</span><span class="token function">getSendStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TransactionListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">TransactionListener</span> <span class="token punctuation">{</span>        <span class="token comment">/**         * 半消息发送成功将会自动执行该逻辑         *         * @param msg         * @param arg         * @return         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 执行本地事务</span>            <span class="token class-name">Order</span> order <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                order <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Order</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">boolean</span> isSuccess <span class="token operator">=</span> <span class="token function">updateOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>isSuccess<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 本地事务执行成功，提交半消息</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"本地事务执行成功，提交事务事务消息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 本地事务执行成功，回滚半消息</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"本地事务执行失败，回滚事务消息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"本地事务执行异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 异常情况返回未知状态</span>            <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/**         * 更新订单         * 这里模拟数据库更新，返回事务执行成功         *         * @param order         * @return         */</span>        <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">updateOrder</span><span class="token punctuation">(</span><span class="token class-name">Order</span> order<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/***         * 若提交/回滚事务消息失败，rocketmq 自动反查事务状态         * @param msg         * @return         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">Order</span> order <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Order</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">boolean</span> isSuccess <span class="token operator">=</span> <span class="token function">queryOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getOrderId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>isSuccess<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 本地事务执行成功，提交半消息</span>                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">// 本地事务执行成功，回滚半消息</span>                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"查询失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 异常情况返回未知状态</span>            <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/**         * 查询订单状态         * 模拟返回查询成功         *         * @param orderId         * @return         */</span>        <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">queryOrder</span><span class="token punctuation">(</span><span class="token class-name">String</span> orderId<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Data</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> orderId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> goods<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token class-name">String</span> orderId<span class="token punctuation">,</span> <span class="token class-name">String</span> goods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>orderId <span class="token operator">=</span> orderId<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>goods <span class="token operator">=</span> goods<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中：</p><ol><li>我们需要为生产者指定一个<strong>唯一</strong>的 <code>ProducerGroup</code></li><li>需要继承 <code>TransactionListener</code> 注解回调接口，其中 <code>executeLocalTransaction</code> 方法执行本地事务，<code>checkLocalTranscation</code> 用来执行检查本地事务。</li><li>返回事务状态有三种：<ul><li>LocalTransactionState.UNKNOW 中间状态，RocketMQ 将会反查</li><li>LocalTransactionState.COMMIT_MESSAGE 提交事务，消息这后续将会消费这条消息</li><li>LocalTransactionState.ROLLBACK_MESSAGE，回滚事务，RocketMQ 将会删除这条消息</li></ul></li></ol><h3 id="事务消息使用注意点"><a href="#事务消息使用注意点" class="headerlink" title="事务消息使用注意点"></a>事务消息使用注意点</h3><p><strong>事务消息最大反查次数</strong></p><p>由于单个消息反查次数过多，将会导致半消息队列堆积，影响性能。 RocketMQ 默认将单个消息的检查次数限制为 15 次。</p><p>我们可以通过修改 <code>broker</code> 配置文件，增加如下配置：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># N 为最大检查次数transactionCheckMax=N<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当检查次数超过最大次数后，RocketMQ 将会丢弃消息并且打印错误日志。</p><p>若想自定义丢弃消息行为，需要修改 RocketMQ broker 端代码，继承 <code>AbstractTransactionalMessageCheckListener</code> 重写 <code>resolveDiscardMsg</code> 方法，加入自定义逻辑。</p><p><strong>同步的双重写入机制</strong></p><p>为了确保事务消息不丢失，并且保证事务完整性，需要将事务消息复制到集群其他节点，建议使用同步双重写入机制。</p><p><strong>事务反查时间设置</strong></p><p>我们可以设置以下参数，设置 MQ 服务端多久之后开始反查事务消息（自事务消息保存成功之后开始计算）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">msg<span class="token punctuation">.</span><span class="token function">putUserProperty</span><span class="token punctuation">(</span><span class="token class-name">MessageConst</span><span class="token punctuation">.</span>PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS<span class="token punctuation">,</span> <span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者我们可以在 <code>broker.conf</code> 设置以下参数：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># 单位为 ms,默认为 6 stransactionTimeout=60000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发送端主动设置配置参数优先级大于 <code>broker</code> 端配置。</p><p>另外 RocketMQ 还有一个配置用于控制事务性消息检查间隔：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">## 默认为 60stransactionCheckInterval=5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果自定义配置如上,事务消息检查间隔为 5 秒，事务消息设置检查时间为 60 s。</p><p>这就代表 broker 每隔 5s 检查一次事务消息，如果此时事务消息到 MQ 服务端时间还未超过 60s，此时将不会反查，直到时间大于 60s。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang [ 逃逸分析 ]</title>
      <link href="/2021/09/02/golang-tao-yi-fen-xi/"/>
      <url>/2021/09/02/golang-tao-yi-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，可 GC 并不是没有代价的。写 C 语言的时候，在一个函数内声明的变量，在函数退出后会自动释放掉，因为这些变量分配在栈上。如果你想要变量的数据能在函数退出后还能访问，就需要调用 <code>malloc</code> 方法在堆上申请内存，如果程序不再需要这块内存了，再调用 <code>free</code> 方法释放掉。Go 语言不需要你主动调用 <code>malloc</code> 来分配堆空间，编译器会自动分析，找出需要 <code>malloc</code> 的变量，使用堆内存。编译器的这个分析过程就叫做逃逸分析。</p><p>所以你在一个函数中通过 <code>dict := make(map[string]int)</code> 创建一个 map 变量，其背后的数据是放在栈空间上还是堆空间上，是不一定的。这要看编译器分析的结果。</p><p>可逃逸分析并不是百分百准确的，它有缺陷。有的时候你会发现有些变量其实在栈空间上分配完全没问题的，但编译后程序还是把这些数据放在了堆上。如果你了解 Go 语言编译器逃逸分析的机制，在写代码的时候就可以有意识的绕开这些缺陷，使你的程序更高效。</p><h2 id="关于堆栈"><a href="#关于堆栈" class="headerlink" title="关于堆栈"></a>关于堆栈</h2><p>Go 语言虽然在内存管理方面降低了编程门槛，即使你不了解堆栈也能正常开发，但如果你要在性能上较真的话，还是要掌握这些基础知识。</p><p>这里不对堆内存和栈内存的区别做太多阐述。简单来说就是，<strong>栈分配廉价，堆分配昂贵。</strong>栈空间会随着一个函数的结束自动释放，堆空间需要 GC 模块不断的跟踪扫描回收。如果对这两个概念有些迷糊，建议阅读下面 ２ 个文章：</p><ul><li><a href="https://links.jianshu.com/go?to=https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Language Mechanics On Stacks And Pointers</a></li><li><a href="https://links.jianshu.com/go?to=https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">Language Mechanics On Escape Analysis</a></li></ul><p>这里举一个小例子，来对比下堆栈的差别：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>     <span class="token comment">// 变量 i 会在栈上分配</span>     i <span class="token operator">:=</span> <span class="token number">10</span>     <span class="token keyword">return</span> i<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment">// 变量 j 会在堆上分配</span>    j <span class="token operator">:=</span> <span class="token number">10</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>j<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>stack</code> 函数中的变量 <code>i</code> 在函数退出会自动释放；而 <code>heap</code> 函数返回的是对变量<code>i</code>的引用，也就是说 <code>heap()</code>退出后，表示变量 <code>i</code>  还要能被访问，它会自动被分配到堆空间上。</p><p>他们编译出来的代码如下：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">// go build --gcflags '-l' test.go// go tool objdump ./testTEXT main.stack(SB) /tmp/test.go  test.go:7     0x487240        48c74424080a000000  MOVQ $0xa, 0x8(SP)    test.go:7     0x487249        c3          RET         TEXT main.heap(SB) /tmp/test.go  test.go:9     0x487250        64488b0c25f8ffffff  MOVQ FS:0xfffffff8, CX            test.go:9     0x487259        483b6110        CMPQ 0x10(CX), SP             test.go:9     0x48725d        7639            JBE 0x487298                  test.go:9     0x48725f        4883ec18        SUBQ $0x18, SP                test.go:9     0x487263        48896c2410      MOVQ BP, 0x10(SP)             test.go:9     0x487268        488d6c2410      LEAQ 0x10(SP), BP             test.go:10        0x48726d        488d05ac090100      LEAQ 0x109ac(IP), AX              test.go:10        0x487274        48890424        MOVQ AX, 0(SP)                test.go:10        0x487278        e8f33df8ff      CALL runtime.newobject(SB)        test.go:10        0x48727d        488b442408      MOVQ 0x8(SP), AX              test.go:10        0x487282        48c7000a000000      MOVQ $0xa, 0(AX)              test.go:11        0x487289        4889442420      MOVQ AX, 0x20(SP)             test.go:11        0x48728e        488b6c2410      MOVQ 0x10(SP), BP             test.go:11        0x487293        4883c418        ADDQ $0x18, SP                test.go:11        0x487297        c3          RET                   test.go:9     0x487298        e8a380fcff      CALL runtime.morestack_noctxt(SB)     test.go:9     0x48729d        ebb1            JMP main.heap(SB)           // ...TEXT runtime.newobject(SB) /usr/share/go/src/runtime/malloc.go  malloc.go:1067    0x40b070        64488b0c25f8ffffff  MOVQ FS:0xfffffff8, CX            malloc.go:1067    0x40b079        483b6110        CMPQ 0x10(CX), SP             malloc.go:1067    0x40b07d        763d            JBE 0x40b0bc                  malloc.go:1067    0x40b07f        4883ec28        SUBQ $0x28, SP                malloc.go:1067    0x40b083        48896c2420      MOVQ BP, 0x20(SP)             malloc.go:1067    0x40b088        488d6c2420      LEAQ 0x20(SP), BP             malloc.go:1068    0x40b08d        488b442430      MOVQ 0x30(SP), AX             malloc.go:1068    0x40b092        488b08          MOVQ 0(AX), CX                malloc.go:1068    0x40b095        48890c24        MOVQ CX, 0(SP)                malloc.go:1068    0x40b099        4889442408      MOVQ AX, 0x8(SP)              malloc.go:1068    0x40b09e        c644241001      MOVB $0x1, 0x10(SP)           malloc.go:1068    0x40b0a3        e888f4ffff      CALL runtime.mallocgc(SB)         malloc.go:1068    0x40b0a8        488b442418      MOVQ 0x18(SP), AX             malloc.go:1068    0x40b0ad        4889442438      MOVQ AX, 0x38(SP)             malloc.go:1068    0x40b0b2        488b6c2420      MOVQ 0x20(SP), BP             malloc.go:1068    0x40b0b7        4883c428        ADDQ $0x28, SP                malloc.go:1068    0x40b0bb        c3          RET                   malloc.go:1067    0x40b0bc        e87f420400      CALL runtime.morestack_noctxt(SB)     malloc.go:1067    0x40b0c1        ebad            JMP runtime.newobject(SB)       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑的复杂度不言而喻，上面的汇编中可看到， <code>heap()</code> 函数调用了 <code>runtime.newobject()</code> 方法，它会调用 <code>mallocgc</code> 方法从 <code>mcache</code> 上申请内存，申请的内部逻辑前面文章已经讲述过。堆内存分配不仅分配上逻辑比栈空间分配复杂，它最致命的是会带来很大的管理成本，Go 语言要消耗很多的计算资源对其进行标记回收（也就是 GC 成本）。</p><blockquote><p>不要以为使用了堆内存就一定会导致性能低下，使用栈内存会带来性能优势。因为实际项目中，系统的性能瓶颈一般都不会出现在内存分配上。千万不要盲目优化，找到系统瓶颈，用数据驱动优化。</p></blockquote><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>Go 编辑器会自动帮我们找出需要进行动态分配的变量，它是在编译时追踪一个变量的生命周期，如果能确认一个数据只在函数空间内访问，不会被外部使用，则使用栈空间，否则就要使用堆空间。</p><p>我们在 <code>go build</code> 编译代码时，可使用 <code>-gcflags '-m'</code> 参数来查看逃逸分析日志。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">go build -gcflags '-m -m' test.go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上面的两个函数为例，编译的日志输出是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>i escapes to heap<span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span>  from ~r0 <span class="token punctuation">(</span><span class="token keyword">return</span><span class="token punctuation">)</span> at <span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> moved to heap<span class="token punctuation">:</span> i<span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">:</span> <span class="token function">heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> escapes to heap<span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">:</span>     from <span class="token operator">...</span> argument <span class="token punctuation">(</span>arg to <span class="token operator">...</span><span class="token punctuation">)</span> at <span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">:</span>     from <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">...</span> argument<span class="token punctuation">)</span> <span class="token punctuation">(</span>indirection<span class="token punctuation">)</span> at <span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">:</span>     from <span class="token operator">...</span> argument <span class="token punctuation">(</span>passed to call<span class="token punctuation">[</span>argument content escapes<span class="token punctuation">]</span><span class="token punctuation">)</span> at <span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token operator">/</span>tmp<span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span> main <span class="token operator">...</span> argument does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志中的 <code>&amp;i escapes to heap</code> 表示该变量数据逃逸到了堆上。</p><h3 id="逃逸分析的缺陷"><a href="#逃逸分析的缺陷" class="headerlink" title="逃逸分析的缺陷"></a>逃逸分析的缺陷</h3><p>需要使用堆空间则逃逸，这没什么可争议的。但编译器有时会将<strong>不需要</strong>使用堆空间的变量，也逃逸掉。这里是容易出现性能问题的大坑。网上有很多相关文章，列举了一些导致逃逸情况，其实总结起来就一句话：</p><p><strong>多级间接赋值容易导致逃逸</strong>。</p><p>这里的多级间接指的是，对某个引用类对象中的引用类成员进行赋值。Go 语言中的引用类数据类型有 <code>func</code>, <code>interface</code>, <code>slice</code>, <code>map</code>, <code>chan</code>, <code>*Type(指针)</code>。</p><p>记住公式 <code>Data.Field = Value</code>，如果 <code>Data</code>, <code>Field</code> 都是引用类的数据类型，则会导致 <code>Value</code> 逃逸。这里的等号 <code>=</code> 不单单只赋值，也表示参数传递。</p><p>根据公式，我们假设一个变量 <code>data</code> 是以下几种类型，相应的可得出结论：</p><ul><li><code>[]interface{}</code>: <code>data[0] = 100</code> 会导致 <code>100</code> 逃逸</li><li><code>map[string]interface{}</code>: <code>data["key"] = "value"</code> 会导致 <code>"value"</code> 逃逸</li><li><code>map[interface{}]interface{}</code>: <code>data["key"] = "value"</code> 会导致 <code>key</code> 和 <code>value</code> 都逃逸</li><li><code>map[string][]string</code>: <code>data["key"] = []string{"hello"}</code> 会导致切片逃逸</li><li><code>map[string]*int</code>:  赋值时 <code>*int</code> 会 逃逸</li><li><code>[]*int</code>: <code>data[0] = &amp;i</code> 会使 <code>i</code> 逃逸</li><li><code>func(*int)</code>: <code>data(&amp;i)</code> 会使 <code>i</code> 逃逸</li><li><code>func([]string)</code>: <code>data([]{"hello"})</code> 会使 <code>[]string{"hello"}</code> 逃逸</li><li><code>chan []string</code>: <code>data &lt;- []string{"hello"}</code> 会使 <code>[]string{"hello"}</code> 逃逸</li><li>以此类推，不一一列举了</li></ul><p>下面给出一些实际的例子：</p><h4 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h4><p>如果变量值是一个函数，函数的参数又是引用类型，则传递给它的参数都会逃逸。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">testEscape</span><span class="token punctuation">(</span>i <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    t<span class="token punctuation">,</span> te <span class="token operator">:=</span> test<span class="token punctuation">,</span> testEscape <span class="token comment">// 函数变量</span>    <span class="token comment">// 直接调用</span>    <span class="token function">test</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>        <span class="token comment">// 不逃逸</span>    <span class="token function">testEscape</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token comment">// 不逃逸</span>    <span class="token comment">// 间接调用</span>    <span class="token function">t</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>   <span class="token comment">// 不逃逸</span>    <span class="token function">te</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span> <span class="token comment">// 逃逸</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span> testEscape i does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>j escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span>     from <span class="token function">te</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span> <span class="token punctuation">(</span>parameter to indirect call<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span> moved to heap<span class="token punctuation">:</span> j<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span> main <span class="token operator">&amp;</span>n does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上例中 <code>te</code> 的类型是 <code>func(*int)</code>，属于引用类型，参数 <code>*int</code> 也是引用类型，则调用 <code>te(&amp;j)</code> 形成了为 <code>te</code> 的参数(成员) <code>*int</code> 赋值的现象，即 <code>te.i = &amp;j</code> 会导致逃逸。代码中其他几种调用都没有形成<strong>多级间接赋值</strong>情况。<br> 同理，如果函数的参数类型是 <code>slice</code>, <code>map</code> 或 <code>interface{}</code> 都会导致参数逃逸。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">testSlice</span><span class="token punctuation">(</span>slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">testMap</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">testInterface</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span>    ts<span class="token punctuation">,</span> tm<span class="token punctuation">,</span> ti <span class="token operator">:=</span> testSlice<span class="token punctuation">,</span> testMap<span class="token punctuation">,</span> testInterface    <span class="token function">ts</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// ts.slice = x 导致 x 逃逸</span>    <span class="token function">tm</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment">// tm.m = y 导致 y 逃逸</span>    <span class="token function">ti</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token comment">// ti.i = z 导致 z 逃逸</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span> testSlice slice does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span> testMap m does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">:</span> testInterface i does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span>     from x <span class="token punctuation">(</span>assign<span class="token operator">-</span>pair<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span>     from <span class="token function">ts</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span>parameter to indirect call<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">33</span><span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">33</span><span class="token punctuation">:</span>     from y <span class="token punctuation">(</span>assign<span class="token operator">-</span>pair<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">33</span><span class="token punctuation">:</span>     from <span class="token function">tm</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">(</span>parameter to indirect call<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span> z escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span>     from <span class="token function">ti</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">(</span>parameter to indirect call<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匿名函数的调用也是一样的，它本质上也是一个函数变量。有兴趣的可以自己测试一下。</p><h4 id="间接赋值"><a href="#间接赋值" class="headerlink" title="间接赋值"></a>间接赋值</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Data <span class="token keyword">struct</span> <span class="token punctuation">{</span>    data  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span>    slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    ch    <span class="token keyword">chan</span> <span class="token builtin">int</span>    inf   <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    p     <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    d1 <span class="token operator">:=</span> Data<span class="token punctuation">{</span><span class="token punctuation">}</span>    d1<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// GOOD: does not escape</span>    d1<span class="token punctuation">.</span>slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment">// GOOD: does not escape</span>    d1<span class="token punctuation">.</span>ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment">// GOOD: does not escape</span>    d1<span class="token punctuation">.</span>inf <span class="token operator">=</span> <span class="token number">3</span>                  <span class="token comment">// GOOD: does not escape</span>    d1<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>             <span class="token comment">//  GOOD: does not escape</span>    d2 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span>             <span class="token comment">// d2 是指针变量， 下面为该指针变量中的指针成员赋值</span>    d2<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// BAD: escape to heap</span>    d2<span class="token punctuation">.</span>slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment">// BAD:  escape to heap</span>    d2<span class="token punctuation">.</span>ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment">// BAD:  escape to heap</span>    d2<span class="token punctuation">.</span>inf <span class="token operator">=</span> <span class="token number">3</span>                  <span class="token comment">// BAD:  escape to heap</span>    d2<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>             <span class="token comment">// BAD:  escape to heap</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span>    from d2<span class="token punctuation">.</span>data <span class="token punctuation">(</span>star<span class="token operator">-</span>dot<span class="token operator">-</span>equals<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span>    from d2<span class="token punctuation">.</span>slice <span class="token punctuation">(</span>star<span class="token operator">-</span>dot<span class="token operator">-</span>equals<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span>    from d2<span class="token punctuation">.</span>ch <span class="token punctuation">(</span>star<span class="token operator">-</span>dot<span class="token operator">-</span>equals<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span> <span class="token number">3</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span>     from d2<span class="token punctuation">.</span>inf <span class="token punctuation">(</span>star<span class="token operator">-</span>dot<span class="token operator">-</span>equals<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span>    from d2<span class="token punctuation">.</span>p <span class="token punctuation">(</span>star<span class="token operator">-</span>dot<span class="token operator">-</span>equals<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span> main <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span> main <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span> main <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span> main <span class="token number">3</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span> main <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span> main <span class="token function">new</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span> does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><p>只要使用了 <code>Interface</code> 类型(不是 <code>interafce{}</code>)，那么赋值给它的变量一定会逃逸。因为 <code>interfaceVariable.Method()</code> 先是间接的定位到它的实际值，再调用实际值的同名方法，执行时实际值作为参数传递给方法。相当于<code>interfaceVariable.Method.this = realValue</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Iface <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Dummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> Integer <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span>i Integer<span class="token punctuation">)</span> <span class="token function">Dummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        iface Iface        i     Integer    <span class="token punctuation">)</span>    iface <span class="token operator">=</span> i    iface<span class="token punctuation">.</span><span class="token function">Dummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//  make i escape to heap</span>    <span class="token comment">// 形成 iface.Dummy.i = i</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="引用类型的-channel"><a href="#引用类型的-channel" class="headerlink" title="引用类型的 channel"></a>引用类型的 channel</h4><p>向 channel 中发送数据，本质上就是为 channel 内部的成员赋值，就像给一个 slice 中的某一项赋值一样。所以 <code>chan *Type</code>, <code>chan map[Type]Type</code>, <code>chan []Type</code>, <code>chan interface{}</code> 类型都会导致发送到 channel 中的数据逃逸。</p><p>这本来也是情理之中的，发送给 channel 的数据是要与其他函数分享的，为了保证发送过去的指针依然可用，只能使用堆分配。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        chInteger   <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span>        chMap       <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>        chSlice     <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>        chInterface <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">32</span>    <span class="token punctuation">)</span>    chInteger <span class="token operator">&lt;-</span> <span class="token operator">&amp;</span>a  <span class="token comment">// 逃逸</span>    chMap <span class="token operator">&lt;-</span> b       <span class="token comment">// 逃逸</span>    chSlice <span class="token operator">&lt;-</span> c     <span class="token comment">// 逃逸</span>    chInterface <span class="token operator">&lt;-</span> d <span class="token comment">// 逃逸</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>a escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span>  from chInteger <span class="token operator">&lt;-</span> <span class="token operator">&amp;</span>a <span class="token punctuation">(</span>send<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span> moved to heap<span class="token punctuation">:</span> a<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">31</span><span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span> literal escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">31</span><span class="token punctuation">:</span>   from b <span class="token punctuation">(</span>assigned<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">31</span><span class="token punctuation">:</span>   from chMap <span class="token operator">&lt;-</span> b <span class="token punctuation">(</span>send<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> literal escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">:</span>   from c <span class="token punctuation">(</span>assigned<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">:</span>   from chSlice <span class="token operator">&lt;-</span> c <span class="token punctuation">(</span>send<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span> d escapes to heap<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span>  from chInterface <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">(</span>send<span class="token punctuation">)</span> at <span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span> test <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span> test <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span> test <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> does not escape<span class="token punctuation">.</span><span class="token operator">/</span>escape<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span> test <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数如 <code>func(arg ...string)</code> 实际与 <code>func(arg []string)</code> 是一样的，会增加一层访问路径。这也是 <code>fmt.Sprintf</code> 总是会使参数逃逸的原因。</p><p>例子非常多，这里不能一一列举，我们只需要记住分析方法就好，即，2 级或更多级的访问赋值会<strong>容易</strong>导致数据逃逸。这里加上<strong>容易</strong>二字是因为随着语言的发展，相信这些问题会被慢慢解决，但现阶段，这个可以作为我们分析逃逸现象的依据。</p><p>下面代码中包含 2 种很常规的写法，但他们却有着很大的性能差距，建议自己想下为什么。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    roles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>User<span class="token punctuation">)</span> <span class="token function">SetRoles</span><span class="token punctuation">(</span>roles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    u<span class="token punctuation">.</span>roles <span class="token operator">=</span> roles<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">SetRoles</span><span class="token punctuation">(</span>u User<span class="token punctuation">,</span> roles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> User <span class="token punctuation">{</span>    u<span class="token punctuation">.</span>roles <span class="token operator">=</span> roles    <span class="token keyword">return</span> u<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Benchmark 和 pprof 给出的结果:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">BenchmarkUserSetRoles<span class="token operator">-</span><span class="token number">8</span>     <span class="token number">50000000</span>            <span class="token number">22.3</span> ns<span class="token operator">/</span>op        <span class="token number">16</span> B<span class="token operator">/</span>op          <span class="token number">1</span> allocs<span class="token operator">/</span>opBenchmarkSetRoles<span class="token operator">-</span><span class="token number">8</span>         <span class="token number">2000000000</span>           <span class="token number">0.51</span> ns<span class="token operator">/</span>op        <span class="token number">0</span> B<span class="token operator">/</span>op          <span class="token number">0</span> allocs<span class="token operator">/</span>op  <span class="token number">768.01</span>MB   <span class="token number">768.01</span>MB <span class="token punctuation">(</span>flat<span class="token punctuation">,</span> cum<span class="token punctuation">)</span>   <span class="token number">100</span><span class="token operator">%</span> of Total         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>      <span class="token number">3</span><span class="token punctuation">:</span><span class="token keyword">import</span> <span class="token string">"testing"</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>      <span class="token number">4</span><span class="token punctuation">:</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>      <span class="token number">5</span><span class="token punctuation">:</span><span class="token keyword">func</span> <span class="token function">BenchmarkUserSetRoles</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>      <span class="token number">6</span><span class="token punctuation">:</span>   u <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>      <span class="token number">7</span><span class="token punctuation">:</span>   <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>  <span class="token number">768.01</span>MB   <span class="token number">768.01</span>MB      <span class="token number">8</span><span class="token punctuation">:</span>       u<span class="token punctuation">.</span><span class="token function">SetRoles</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"admin"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> 看这里         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>      <span class="token number">9</span><span class="token punctuation">:</span>   <span class="token punctuation">}</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>     <span class="token number">10</span><span class="token punctuation">:</span><span class="token punctuation">}</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>     <span class="token number">11</span><span class="token punctuation">:</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>     <span class="token number">12</span><span class="token punctuation">:</span><span class="token keyword">func</span> <span class="token function">BenchmarkSetRoles</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span>          <span class="token punctuation">.</span>     <span class="token number">13</span><span class="token punctuation">:</span>   <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>ROUTINE <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> testing<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span>launch in <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>testing<span class="token operator">/</span>benchmark<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token operator">...</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>熟悉堆栈概念可以让我们更容易看透 Go 程序的性能问题，并进行优化。</p><p>多级间接赋值会导致 Go 编译器出现不必要的逃逸，在一些情况下可能我们只需要修改一下数据结构就会使性能有大幅提升。这也是很多人不推荐在 Go 中使用指针的原因，因为它会增加一级访问路径，而 <code>map</code>, <code>slice</code>, <code>interface{}</code>等类型是不可避免要用到的，为了减少不必要的逃逸，只能拿指针开刀了。</p><p>大多数情况下，性能优化都会为程序带来一定的复杂度。建议实际项目中还是怎么方便怎么写，功能完成后通过性能分析找到瓶颈所在，再对局部进行优化。</p><hr><p>常见内存逃逸情况<br>1、在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，则溢出。<br>2、发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。<br>3、在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。<br>4、因为切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。<br>5、在interface类型上调用方法，在Interface调用方法是动态调度的，只有在运行时才知道。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文带你搞懂 golang channel 实现原理</title>
      <link href="/2021/09/01/channel-shi-xian-yuan-li/"/>
      <url>/2021/09/01/channel-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Section1-channel使用实例"><a href="#Section1-channel使用实例" class="headerlink" title="Section1 channel使用实例"></a>Section1 channel使用实例</h1><p>channel主要是为了实现go的并发特性，用于并发通信的，也就是在不同的协程单元goroutine之间同步通信。</p><p>下面主要从三个方面来讲解：</p><ul><li><p>make channel，主要也就是hchan的数据结构原型；</p></li><li><p>发送和接收数据时，goroutine会怎么调度；</p></li><li><p>设计思考；</p></li></ul><h2 id="1-1-make-channel"><a href="#1-1-make-channel" class="headerlink" title="1.1 make channel"></a>1.1 make channel</h2><p>我们创建channel时候有两种，一种是带缓冲的channel一种是不带缓冲的channel。创建方式分别如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// buffered</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Task<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">// unbuffered</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>buffered channel</p><p>如果我们创建一个带buffer的channel，底层的数据模型如下图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/channel-0.png"><br>当我们向channel里面写入数据时候，会直接把数据存入circular queue(send)。当Queue存满了之后就会是如下的状态：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-1.png"></p><p>当dequeue一个元素时候，如下所示：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-2.png"></p><p>从上图可知，recvx自增加一，表示出队了一个元素，其实也就是循环数组实现FIFO语义。</p><p>那么还有一个问题，当我们新建channel的时候，底层创建的hchan数据结构是在哪里分配内存的呢？其实Section2里面源码分析时候已经做了分析，hchan是在heap里面分配的。</p><p>如下图所示：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-3.png"></p><p>当我们使用make去创建一个channel的时候，实际上返回的是一个指向channel的pointer，所以我们能够在不同的function之间直接传递channel对象，而不用通过指向channel的指针。</p><h2 id="1-2-sends-and-receives"><a href="#1-2-sends-and-receives" class="headerlink" title="1.2 sends and receives"></a>1.2 sends and receives</h2><p>不同goroutine在channel上面进行读写时，涉及到的过程比较复杂，比如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-4.png"></p><p>上图中G1会往channel里面写入数据，G2会从channel里面读取数据。</p><p>G1作用于底层hchan的流程如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-5.png"></p><ol><li>先获取全局锁；</li><li>然后enqueue元素(通过移动拷贝的方式)；</li><li>释放锁；</li></ol><p>G2读取时候作用于底层数据结构流程如下图所示：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-6.png"></p><ol><li>先获取全局锁；</li><li>然后dequeue元素(通过移动拷贝的方式)；</li><li>释放锁；</li></ol><p>上面的读写思路其实很简单，除了hchan数据结构外，不要通过共享内存去通信；而是通过通信(复制)实现共享内存。</p><p>写入满channel的场景</p><p>如下图所示：channel写入3个task之后队列已经满了，这时候G1再写入第四个task的时候会发生什么呢？<br><img src="https://image.fyxemmmm.cn/blog/images/channel-7.png"></p><p>G1这时候会暂停直到出现一个receiver。</p><p>这个地方需要介绍一下Golang的scheduler的。我们知道goroutine是用户空间的线程，创建和管理协程都是通过Go的runtime，而不是通过OS的thread。</p><p>但是Go的runtime调度执行goroutine却是基于OS thread的。如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-8.png"></p><p>当向已经满的channel里面写入数据时候，会发生什么呢？如下图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/channel-9.png"></p><p>上图流程大概如下：</p><ol><li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态；</li><li>将M和G1绑定关系断开；</li><li>scheduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G。</li></ol><p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。</p><p>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p><p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-10.png"></p><p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行<code>ch&lt;-task4</code>的时候，G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-11.png"></p><p>这个时候，如果G1进行一个读取channel操作，读取前和读取后的变化图如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-12.png"></p><p>整个过程如下：</p><ol><li>G2调用 <code>t:=&lt;-ch</code> 获取一个元素；</li><li>从channel的buffer里面取出一个元素task1；</li><li>从sender等待队列里面pop一个sudog；</li><li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li><li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li></ol><p>这个时候将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-13.png"></p><ol><li>首先G2会调用goready(G1)，唤起scheduler的调度；</li><li>将G1设置成Runable状态；</li><li>G1会加入到局部调度器P的local queue队列，等待运行。</li></ol><p>读取空channel的场景</p><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-14.png"></p><p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。</p><p>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p><ol><li>将recvq中的task存入buffer；</li><li>goready(G2) 唤醒G2；</li></ol><p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。如下图：<br><img src="https://image.fyxemmmm.cn/blog/images/channel-15.png"></p><p>具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲。</p><h2 id="1-3-channel主要特性"><a href="#1-3-channel主要特性" class="headerlink" title="1.3 channel主要特性"></a>1.3 channel主要特性</h2><p>（1）goroutine-safe<br>hchan mutex</p><p>（2）store values, pass in FIFO.<br>copying into and out of hchan buffer</p><p>（3）can cause goroutines to pause and resume.<br>a）hchan sudog queues</p><p>b）calls into the runtime scheduler (gopark, goready)</p><p>（4）channel的高性能所在：<br>a）调用runtime scheduler实现，OS thread不需要阻塞；<br>b）跨goroutine栈可以直接进行读写；</p><h1 id="Section2-源码分析"><a href="#Section2-源码分析" class="headerlink" title="Section2 源码分析"></a>Section2 源码分析</h1><h2 id="2-1-channel数据存储结构"><a href="#2-1-channel数据存储结构" class="headerlink" title="2.1 channel数据存储结构"></a>2.1 channel数据存储结构</h2><p>在源码<code>runtime/chan.go</code> 里面定义了channel的数据模型，channel可以理解成一个缓冲队列，这个缓冲队列用来存储元素，并且提供FIFO的语义。源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> hchan <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token comment">//channel队列里面总的数据量</span>qcount   <span class="token builtin">uint</span>           <span class="token comment">// total data in the queue</span><span class="token comment">// 循环队列的容量，如果是非缓冲的channel就是0</span>dataqsiz <span class="token builtin">uint</span>           <span class="token comment">// size of the circular queue</span><span class="token comment">// 缓冲队列，数组类型。</span>buf      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// points to an array of dataqsiz elements</span><span class="token comment">// 元素占用字节的size</span>elemsize <span class="token builtin">uint16</span><span class="token comment">// 当前队列关闭标志位，非零表示关闭</span>closed   <span class="token builtin">uint32</span><span class="token comment">// 队列里面元素类型</span>elemtype <span class="token operator">*</span>_type <span class="token comment">// element type</span><span class="token comment">// 队列send索引</span>sendx    <span class="token builtin">uint</span>   <span class="token comment">// send index</span><span class="token comment">// 队列索引</span>recvx    <span class="token builtin">uint</span>   <span class="token comment">// receive index</span><span class="token comment">// 等待channel的G队列。</span>recvq    waitq  <span class="token comment">// list of recv waiters</span><span class="token comment">// 向channel发送数据的G队列。</span>sendq    waitq  <span class="token comment">// list of send waiters</span><span class="token comment">// lock protects all fields in hchan, as well as several</span><span class="token comment">// fields in sudogs blocked on this channel.</span><span class="token comment">//</span><span class="token comment">// Do not change another G's status while holding this lock</span><span class="token comment">// (in particular, do not ready a G), as this can deadlock</span><span class="token comment">// with stack shrinking.</span><span class="token comment">// 全局锁</span>lock mutex<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>channel的数据结构相对比较简单，主要是两个结构：<br>1）一个数组实现的环形队列，数组有两个下标索引分别表示读写的索引，用于保存channel缓冲区数据。<br>2）channel的send和recv队列，队列里面都是持有goroutine的sudog元素，队列都是双链表实现的。<br>3）channel的全局锁。</p><h2 id="2-2-make-channel"><a href="#2-2-make-channel" class="headerlink" title="2.2 make channel"></a>2.2 make channel</h2><p>我们新建一个channel的时候一般使用 <code>make(chan, n)</code> 语句，这个语句的执行编译器会重写然后执行 chan.go里面的 makechan函数。函数源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makechan</span><span class="token punctuation">(</span>t <span class="token operator">*</span>chantype<span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>hchan <span class="token punctuation">{</span>elem <span class="token operator">:=</span> t<span class="token punctuation">.</span>elem<span class="token comment">// compiler checks this but be safe.</span><span class="token keyword">if</span> elem<span class="token punctuation">.</span>size <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span> <span class="token punctuation">{</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"makechan: invalid channel element type"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> hchanSize<span class="token operator">%</span>maxAlign <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> elem<span class="token punctuation">.</span>align <span class="token operator">&gt;</span> maxAlign <span class="token punctuation">{</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"makechan: bad alignment"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">maxSliceCap</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token operator">*</span>elem<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> maxAlloc<span class="token operator">-</span>hchanSize <span class="token punctuation">{</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"makechan: size out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span><span class="token comment">// buf points into the same allocation, elemtype is persistent.</span><span class="token comment">// SudoG's are referenced from their owning thread so they can't be collected.</span><span class="token comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><span class="token keyword">var</span> c <span class="token operator">*</span>hchan<span class="token keyword">switch</span> <span class="token punctuation">{</span><span class="token keyword">case</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> elem<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token comment">// Queue or element size is zero.</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>hchan<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span>hchanSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// Race detector uses this location for synchronization.</span>c<span class="token punctuation">.</span>buf <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">case</span> elem<span class="token punctuation">.</span>kind<span class="token operator">&amp;</span>kindNoPointers <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token comment">// Elements do not contain pointers.</span><span class="token comment">// Allocate hchan and buf in one call.</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>hchan<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span>hchanSize<span class="token operator">+</span><span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token operator">*</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>buf <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> hchanSize<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token comment">// Elements contain pointers.</span>c <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>hchan<span class="token punctuation">)</span>c<span class="token punctuation">.</span>buf <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token operator">*</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">}</span>c<span class="token punctuation">.</span>elemsize <span class="token operator">=</span> <span class="token function">uint16</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">)</span>c<span class="token punctuation">.</span>elemtype <span class="token operator">=</span> elemc<span class="token punctuation">.</span>dataqsiz <span class="token operator">=</span> <span class="token function">uint</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token keyword">if</span> debugChan <span class="token punctuation">{</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"makechan: chan="</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token string">"; elemsize="</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token string">"; elemalg="</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>alg<span class="token punctuation">,</span> <span class="token string">"; dataqsiz="</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> c<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数接收两个参数，一个是channel里面保存的元素的数据类型，一个是缓冲的容量(如果为0表示是非缓冲buffer)，创建流程如下：</p><ul><li>根据传递的缓冲大小size是否为零，分别创建不带buffer的channel或则带size大小的缓冲channel：<ul><li>对于不带缓冲channel，申请一个hchan数据结构的内存大小；</li><li>对于带缓冲channel，new一个hchan对象，并初始化buffer内存；</li></ul></li><li>更新 chan中循环队列的关键属性：elemsize、elemtype、dataqsiz。</li></ul><p>所以，整个创建channel的过程还是比较简单的。</p><h2 id="2-3-协程从channel接收数据-goroutine-receive-data"><a href="#2-3-协程从channel接收数据-goroutine-receive-data" class="headerlink" title="2.3 协程从channel接收数据(goroutine receive data)"></a>2.3 协程从channel接收数据(goroutine receive data)</h2><p>所有执行 <code>ep &lt; c</code> 使用ep接收channel数据的代码，最后都会调用到chan.go里面的 <code>chanrecv函数</code>。</p><p>函数的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> block <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>selected<span class="token punctuation">,</span> received <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从源码注释就可以知道，该函数从channel里面接收数据，然后将接收到的数据写入到ep指针指向的对象里面。</p><p>还有一个参数block，表示当channel无法返回数据时是否阻塞等待。当block=false并且channel里面没有数据时候，函数直接返回(false,false)。</p><p>接收channel的数据的流程如下：</p><ul><li>CASE1：前置channel为nil的场景：<ul><li>如果block为非阻塞，直接return；</li><li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li></ul></li><li>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</li><li>调用 <code>lock(&amp;c.lock)</code> 锁住channel的全局锁；</li><li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li><li>CASE3：sender队列非空，调用<code>func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)</code> 函数处理：<ul><li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li><li>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：<ul><li>1.先取channel缓冲队列的对头元素复制给receiver(也就是ep)；</li><li>2.将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了。</li></ul></li><li>释放channel的全局锁；</li><li>调用goready函数标记当前goroutine处于ready，可以运行的状态；</li></ul></li><li>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引；</li><li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)；</li><li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞。</li></ul><h2 id="2-4-协程向channel写入数据-goroutine-sender-data"><a href="#2-4-协程向channel写入数据-goroutine-sender-data" class="headerlink" title="2.4 协程向channel写入数据(goroutine sender data)"></a>2.4 协程向channel写入数据(goroutine sender data)</h2><p>所有执行 <code>c &lt; ep</code> 将ep发送到channel的代码，最后都会调用到chan.go里面的 <code>chansend函数</code>。</p><p>函数的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">chansend</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> block <span class="token builtin">bool</span><span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数有三个参数，第一个代表channel的数据结构，第二个是要指向写入的数据的指针，第三个block代表写入操作是否阻塞。</p><p>向channel写入数据主要流程如下：</p><ul><li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return；</li><li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return；</li><li>调用 <code>lock(&amp;c.lock)</code> 锁住channel的全局锁；</li><li>CASE3：不能向已经关闭的channel send数据，会导致panic。</li><li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine：<ul><li>调用sendDirect方法，将待写入的消息发送给接收的goroutine；</li><li>释放channel的全局锁；</li><li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度。</li></ul></li><li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁；</li><li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul><li>获取当前goroutine的sudog，然后入channel的send队列；</li><li>将当前goroutine休眠</li></ul></li></ul><h2 id="2-5-channel-close关闭channel源码分析"><a href="#2-5-channel-close关闭channel源码分析" class="headerlink" title="2.5 channel close关闭channel源码分析"></a>2.5 channel close关闭channel源码分析</h2><p>当我们执行channel的close操作的时候会关闭channel。</p><p>关闭的主要流程如下所示：</p><ul><li>获取全局锁；</li><li>设置channel数据结构chan的关闭标志位；</li><li>获取当前channel上面的读goroutine并链接成链表；</li><li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li><li>释放全局锁；</li><li>唤醒所有的读写goroutine。</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang [ 内存管理 ]</title>
      <link href="/2021/08/27/golang-nei-cun-guan-li/"/>
      <url>/2021/08/27/golang-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>要搞明白 Go 语言的内存管理，就必须先理解操作系统以及机器硬件是如何管理内存的。因为 Go 语言的内部机制是建立在这个基础之上的，它的设计，本质上就是尽可能的会发挥操作系统层面的优势，而避开导致低效情况。</p><h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><p>其实现在计算机内存管理的方式都是一步步演变来的，最开始是非常简单的，后来为了满足各种需求而增加了各种各样的机制，越来越复杂。这里我们只介绍和开发者息息相关的几个机制。</p><h3 id="最原始的方式"><a href="#最原始的方式" class="headerlink" title="最原始的方式"></a>最原始的方式</h3><p>我们可以把内存看成一个数组，每个数组元素的大小是 <code>1B</code>，也就是 8 位(bit)。CPU 通过内存地址来获取内存中的数据，内存地址可以看做成数组的游标（index）。</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc1.webp"></p><p>CPU 在执行指令的时候，就是通过内存地址，将物理内存上的数据载入到寄存器，然后执行机器指令。但随着发展，出现了多任务的需求，也就是希望多个任务能同时在系统上运行。这就出现了一些问题：</p><ol><li><strong>内存访问冲突：</strong>程序很容易出现 bug，就是 2 或更多的程序使用了同一块内存空间，导致数据读写错乱，程序崩溃。更有一些黑客利用这个缺陷来制作病毒。</li><li><strong>内存不够用：</strong>因为每个程序都需要自己单独使用的一块内存，内存的大小就成了任务数量的瓶颈。</li><li><strong>程序开发成本高：</strong>你的程序要使用多少内存，内存地址是多少，这些都不能搞错，对于人来说，开发正确的程序很费脑子。</li></ol><p>举个例子，假设有一个程序，当代码运行到某处时，需要使用 <code>100M</code> 内存，其他时候 <code>1M</code> 内存就够；为了避免和其他程序冲突，程序初始化时，就必须申请独立 <code>100M</code> 内存以保证正常运行，这就是一种很大的浪费，因为这 <code>100M</code> 它大多数时候用不上，其他程序还不能用。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存的出现，很好的为了解决上述的一些列问题。用户程序只能使用虚拟的内存地址来获取数据，系统会将这个虚拟地址翻译成实际的物理地址。</p><p>所有程序统一使用一套连续虚拟地址，比如 <code>0x0000 ~ 0xffff</code>。从程序的角度来看，它觉得自己独享了一整块内存。不用考虑访问冲突的问题。系统会将虚拟地址翻译成物理地址，从内存上加载数据。</p><p>对于内存不够用的问题，虚拟内存本质上是将磁盘当成最终存储，而主存作为了一个 cache。程序可以从虚拟内存上申请很大的空间使用，比如 <code>1G</code>；但操作系统不会真的在物理内存上开辟 <code>1G</code> 的空间，它只是开辟了很小一块，比如 <code>1M</code> 给程序使用。<br> 这样程序在访问内存时，操作系统看访问的地址是否能转换成物理内存地址。能则正常访问，不能则再开辟。这使得内存得到了更高效的利用。</p><p>如下图所示，每个进程所使用的虚拟地址空间都是一样的，但他们的虚拟地址会被映射到主存上的不同区域，甚至映射到磁盘上（当内存不够用时）。</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc2.webp"></p><p>虚拟地址</p><p>其实本质上很简单，就是操作系统将程序常用的数据放到内存里加速访问，不常用的数据放在磁盘上。这一切对用户程序来说完全是透明的，用户程序可以假装所有数据都在内存里，然后通过虚拟内存地址去访问数据。在这背后，操作系统会自动将数据在主存和磁盘之间进行交换。</p><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>虚拟内存的实现方式，大多数都是通过<strong>页表</strong>来实现的。操作系统虚拟内存空间分成一页一页的来管理，每页的大小为 <code>4K</code>（当然这是可以配置的，不同操作系统不一样）。磁盘和主内存之间的置换也是以<strong>页</strong>为单位来操作的。<code>4K</code> 算是通过实践折中出来的通用值，太小了会出现频繁的置换，太大了又浪费内存。</p><p><code>虚拟地址 -&gt; 物理地址</code> 的映射关系由<strong>页表（Page Table）</strong>记录，它其实就是一个数组，数组中每个元素叫做<strong>页表条目（Page Table Entry，简称 PTE）</strong>，PTE 由一个有效位和 n 位地址字段构成，有效位标识这个虚拟地址是否分配了物理内存。</p><p>页表被操作系统放在物理内存的指定位置，CPU  上有个 Memory Management Unit（MMU） 单元，CPU 把虚拟地址给 MMU，MMU 去物理内存中查询页表，得到实际的物理地址。当然 MMU 不会每次都去查的，它自己也有一份缓存叫Translation Lookaside Buffer (TLB)，是为了加速地址翻译。</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc3.webp"></p><p>虚拟地址翻译</p><blockquote><p>你慢慢会发现整个计算机体系里面，缓存是无处不在的，整个计算机体系就是建立在一级级的缓存之上的，无论软硬件。</p></blockquote><p>让我们来看一下 CPU 内存访问的完整过程：</p><ol><li>CPU 使用虚拟地址访问数据，比如执行了 MOV 指令加载数据到寄存器，把地址传递给 MMU。</li><li>MMU 生成 PTE 地址，并从主存（或自己的 Cache）中得到它。</li><li>如果 MMU 根据 PTE 得到真实的物理地址，正常读取数据。流程到此结束。</li><li>如果 PTE 信息表示没有关联的物理地址，MMU 则触发一个缺页异常。</li><li>操作系统捕获到这个异常，开始执行异常处理程序。在物理内存上创建一页内存，并更新页表。</li><li>缺页处理程序在物理内存中确定一个<strong>牺牲页</strong>，如果这个牺牲页上有数据，则把数据保存到磁盘上。</li><li>缺页处理程序更新 PTE。</li><li>缺页处理程序结束，再回去执行上一条指令（导致缺页异常的那个指令，也就是 MOV 指令）。这次肯定命中了。</li></ol><h4 id="内存命中率"><a href="#内存命中率" class="headerlink" title="内存命中率"></a>内存命中率</h4><p>你可能已经发现，上述的访问步骤中，从第 4 步开始都是些很繁琐的操作，频繁的执行对性能影响很大。毕竟访问磁盘是非常慢的，它会引发程序性能的急剧下降。如果内存访问到第 3 步成功结束了，我们就说<strong>页命中</strong>了；反之就是<strong>未命中</strong>，或者说<strong>缺页</strong>，表示它开始执行第 4 步了。</p><p>假设在 n 次内存访问中，出现命中的次数是 m，那么 <code>m / n * 100%</code> 就表示命中率，这是衡量内存管理程序好坏的一个很重要的指标。</p><p>如果物理内存不足了，数据会在主存和磁盘之间频繁交换，命中率很低，性能出现急剧下降，我们称这种现象叫<strong>内存颠簸</strong>。这时你会发现系统的 swap 空间利用率开始增高， CPU 利用率中 <code>iowait</code> 占比开始增高。</p><p>大多数情况下，只要物理内存够用，页命中率不会非常低，不会出现内存颠簸的情况。因为大多数程序都有一个特点，就是<strong>局部性</strong>。</p><p><strong>局部性就是说被引用过一次的存储器位置，很可能在后续再被引用多次；而且在该位置附近的其他位置，也很可能会在后续一段时间内被引用。</strong></p><p>前面说过计算机到处使用一级级的缓存来提升性能，归根结底就是利用了<strong>局部性</strong>的特征，如果没有这个特性，一级级的缓存不会有那么大的作用。所以一个局部性很好的程序运行速度会更快。</p><hr><h2 id="golang内存管理"><a href="#golang内存管理" class="headerlink" title="golang内存管理"></a>golang内存管理</h2><p>了解操作系统对内存的管理机制后，现在可以去看下 Go 语言是如何利用底层的这些特性来优化内存的。Go 的内存管理基本上参考 <code>tcmalloc</code> 来实现的，只是细节上根据自身的需要做了一些小的优化调整。</p><p>Go 的内存是自动管理的，我们可以随意定义变量直接使用，不需要考虑变量背后的内存申请和释放的问题。本文意在搞清楚 Go 在方面帮我们做了什么，使我们不用关心那些复杂内存的问题，还依旧能写出较为高效的程序。</p><h2 id="池"><a href="#池" class="headerlink" title="池"></a>池</h2><p>程序动态申请内存空间，是要使用系统调用的，比如 Linux 系统上是调用 <code>mmap</code> 方法实现的。但对于大型系统服务来说，直接调用 <code>mmap</code> 申请内存，会有一定的代价。比如：</p><ol><li>系统调用会导致程序进入内核态，内核分配完内存后（也就是上篇所讲的，对虚拟地址和物理地址进行映射等操作），再返回到用户态。</li><li>频繁申请很小的内存空间，容易出现大量内存碎片，增大操作系统整理碎片的压力。</li><li>为了保证内存访问具有良好的局部性，开发者需要投入大量的精力去做优化，这是一个很重的负担。</li></ol><p>如何解决上面的问题呢？有经验的人，可能很快就想到解决方案，那就是我们常说的<strong>对象池</strong>（也可以说是缓存）。</p><p>假设系统需要频繁动态申请内存来存放一个数据结构，比如 <code>[10]int</code>。那么我们完全可以在程序启动之初，一次性申请几百甚至上千个 <code>[10]int</code>。这样完美的解决了上面遇到的问题：</p><ol><li>不需要频繁申请内存了，而是从对象池里拿，程序不会频繁进入内核态</li><li>因为一次性申请一个连续的大空间，对象池会被重复利用，不会出现碎片。</li><li>程序频繁访问的就是对象池背后的同一块内存空间，局部性良好。</li></ol><p>这样做会造成一定的内存浪费，我们可以定时检测对象池的大小，保证可用对象的数量在一个合理的范围，少了就提前申请，多了就自动释放。</p><p>如果某种资源的申请和回收是昂贵的，我们都可以通过建立<strong>资源池</strong>的方式来解决，其他比如<strong>连接池</strong>，<strong>内存池</strong>等等，都是一个思路。</p><h2 id="Golang-内存管理"><a href="#Golang-内存管理" class="headerlink" title="Golang 内存管理"></a>Golang 内存管理</h2><p>Golang 的内存管理本质上就是一个内存池，只不过内部做了很多的优化。比如自动伸缩内存池大小，合理的切割内存块等等。</p><h3 id="内存池-mheap"><a href="#内存池-mheap" class="headerlink" title="内存池 mheap"></a>内存池 mheap</h3><p>Golang 的程序在启动之初，会一次性从操作系统那里申请一大块内存作为内存池。这块内存空间会放在一个叫 <code>mheap</code> 的 <code>struct</code> 中管理，mheap 负责将这一整块内存切割成不同的区域，并将其中一部分的内存切割成合适的大小，分配给用户使用。</p><p>我们需要先知道几个重要的概念：</p><ul><li><strong><code>page</code></strong>: 内存页，一块 <code>8K</code> 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 <code>page</code> 为单位的。</li><li><strong><code>span</code></strong>: 内存块，<strong>一个或多个连续的</strong> <code>page</code> 组成一个 <code>span</code>。如果把 <code>page</code> 比喻成工人，<code>span</code> 可看成是小队，工人被分成若干个队伍，不同的队伍干不同的活。</li><li><strong><code>sizeclass</code></strong>: 空间规格，每个 <code>span</code> 都带有一个 <code>sizeclass</code>，标记着该 <code>span</code> 中的 <code>page</code> 应该如何使用。使用上面的比喻，就是 <code>sizeclass</code> 标志着 <code>span</code> 是一个什么样的队伍。</li><li><strong><code>object</code></strong>: 对象，用来存储一个变量数据内存空间，一个 <code>span</code> 在初始化时，会被切割成一堆<strong>等大</strong>的 <code>object</code>。假设 <code>object</code> 的大小是 <code>16B</code>，<code>span</code> 大小是 <code>8K</code>，那么就会把 <code>span</code> 中的 <code>page</code> 就会被初始化 <code>8K / 16B = 512</code> 个 <code>object</code>。所谓内存分配，就是分配一个 <code>object</code> 出去。</li></ul><p>示意图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc4.webp"></p><p>上图中，不同颜色代表不同的 <code>span</code>，不同 <code>span</code> 的 <code>sizeclass</code> 不同，表示里面的 <code>page</code> 将会按照不同的规格切割成一个个等大的 <code>object</code> 用作分配。</p><p>使用 Go1.11.5 版本测试了下初始堆内存应该是 <code>64M</code> 左右，低版本会少点。</p><p>测试代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"runtime"</span><span class="token keyword">var</span> stat runtime<span class="token punctuation">.</span>MemStats<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    runtime<span class="token punctuation">.</span><span class="token function">ReadMemStats</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stat<span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>stat<span class="token punctuation">.</span>HeapSys<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部的整体内存布局如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc5.webp"></p><ul><li><code>mheap.spans</code>：用来存储 <code>page</code> 和 <code>span</code> 信息，比如一个 span 的起始地址是多少，有几个 page，已使用了多大等等。</li><li><code>mheap.bitmap</code> 存储着各个 <code>span</code> 中对象的标记信息，比如对象是否可回收等等。</li><li><code>mheap.arena_start</code>: 将要分配给应用程序使用的空间。</li></ul><p>再说明下，图中的空间大小，是 Go 向操作系统申请的虚拟内存地址空间，操作系统会将该段地址空间预留出来不做它用；而不是真的创建出这么大的虚拟内存，在页表中创建出这么大的映射关系。</p><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p><strong>用途相同</strong>的 <code>span</code> 会以链表的形式组织在一起。 这里的用途用 <code>sizeclass</code> 来表示，就是指该 <code>span</code> 用来存储哪种大小的对象。比如当分配一块大小为 <code>n</code> 的内存时，系统计算 <code>n</code> 应该使用哪种 <code>sizeclass</code>，然后根据 <code>sizeclass</code> 的值去找到一个可用的 <code>span</code> 来用作分配。其中 <code>sizeclass</code> 一共有 67 种（Go1.5 版本，后续版本可能会不会改变不好说），如图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc6.webp"></p><p>找到合适的 <code>span</code> 后，会从中取一个 <code>object</code> 返回给上层使用。这些 <code>span</code> 被放在一个叫做 mcentral 的结构中管理。</p><p>mheap 将从 OS 那里申请过来的内存初始化成一个大 <code>span</code>(sizeclass=0)。然后根据需要从这个大 <code>span</code> 中切出小 <code>span</code>，放在 mcentral 中来管理。大 <code>span</code> 由 <code>mheap.freelarge</code> 和 <code>mheap.busylarge</code> 等管理。如果 mcentral 中的 <code>span</code> 不够用了，会从 <code>mheap.freelarge</code> 上再切一块，如果 <code>mheap.freelarge</code> 空间不够，会再次从 OS 那里申请内存重复上述步骤。下面是 mheap 和 mcentral 的数据结构：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> mheap <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment">// other fields</span>    lock      mutex    free      <span class="token punctuation">[</span>_MaxMHeapList<span class="token punctuation">]</span>mspan <span class="token comment">// free lists of given length， 1M 以下</span>    freelarge mspan                <span class="token comment">// free lists length &gt;= _MaxMHeapList, &gt;= 1M</span>    busy      <span class="token punctuation">[</span>_MaxMHeapList<span class="token punctuation">]</span>mspan <span class="token comment">// busy lists of large objects of given length</span>    busylarge mspan                <span class="token comment">// busy lists of large objects length &gt;= _MaxMHeapList</span>    central <span class="token punctuation">[</span>_NumSizeClasses<span class="token punctuation">]</span><span class="token keyword">struct</span> <span class="token punctuation">{</span> <span class="token comment">// _NumSizeClasses = 67</span>        mcentral mcentral        <span class="token comment">// other fields</span>    <span class="token punctuation">}</span>    <span class="token comment">// other fields</span><span class="token punctuation">}</span><span class="token comment">// Central list of free objects of a given size.</span><span class="token keyword">type</span> mcentral <span class="token keyword">struct</span> <span class="token punctuation">{</span>    lock      mutex <span class="token comment">// 分配时需要加锁</span>    sizeclass <span class="token builtin">int32</span> <span class="token comment">// 哪种 sizeclass</span>    nonempty  mspan <span class="token comment">// 还有可用的空间的 span 链表</span>    empty     mspan <span class="token comment">// 没有可用的空间的 span 列表</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式可以避免出现外部碎片<em>（文章最后面有外部碎片的介绍）</em>，因为同一个 span 是按照固定大小分配和回收的，不会出现不可利用的一小块内存把内存分割掉。这个设计方式与现代操作系统中的伙伴系统有点类似。</p><h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>如果你阅读的比较仔细，会发现上面的 mcentral 结构中有一个 lock 字段；因为并发情况下，很有可能多个线程同时从 mcentral 那里申请内存的，必须要用锁来避免冲突。</p><p>但锁是低效的，在高并发的服务中，它会使内存申请成为整个系统的瓶颈；所以在 mcentral 的前面又增加了一层 mcache。</p><p>每一个 mcache 和每一个处理器(P) 是一一对应的，也就是说每一个 P 都有一个 mcache 成员。 Goroutine 申请内存时，首先从其所在的 P 的 mcache 中分配，如果 mcache 没有可用 <code>span</code>，再从 mcentral 中获取，并填充到 mcache 中。</p><p>从 mcache 上分配内存空间是不需要加锁的，因为在同一时间里，一个 P 只有一个线程在其上面运行，不可能出现竞争。没有了锁的限制，大大加速了内存分配。</p><p>所以整体的内存分配模型大致如下图所示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/nc7.webp"></p><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="zero-size"><a href="#zero-size" class="headerlink" title="zero size"></a>zero size</h4><p>有一些对象所需的内存大小是0，比如 <code>[0]int</code>, <code>struct{}</code>，这种类型的数据根本就不需要内存，所以没必要走上面那么复杂的逻辑。</p><p>系统会直接返回一个固定的内存地址。源码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> flags <span class="token builtin">uint32</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>    <span class="token comment">// 申请的 0 大小空间的内存</span>    <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zerobase<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">//.....</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        a <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        b <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token builtin">int</span>        c <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        d <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 运行结果，6 个变量的内存地址是相同的:</span><span class="token number">0x1180f88</span><span class="token number">0x1180f88</span><span class="token number">0x1180f88</span><span class="token number">0x1180f88</span><span class="token number">0x1180f88</span><span class="token number">0x1180f88</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>如上面所述，最大的 sizeclass 最大只能存放 <code>32K</code> 的对象。如果一次性申请超过 <code>32K</code> 的内存，系统会直接绕过 mcache 和 mcentral，直接从 mheap 上获取，mheap 中有一个 <code>freelarge</code> 字段管理着超大 span。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存的释放过程，没什么特别之处。就是分配的返过程，当 mcache 中存在较多空闲 span 时，会归还给 mcentral；而 mcentral 中存在较多空闲 span 时，会归还给 mheap；mheap 再归还给操作系统。这里就不详细介绍了。</p><p>总结一下，这种设计之所以快，主要有以下几个优势：</p><ol><li>内存分配大多时候都是在用户态完成的，不需要频繁进入内核态。</li><li>每个 P 都有独立的 span cache，多个 CPU 不会并发读写同一块内存，进而减少 CPU L1 cache 的 cacheline 出现 dirty 情况，增大 cpu cache 命中率。</li><li>内存碎片的问题，Go 是自己在用户态管理的，在 OS 层面看是没有碎片的，使得操作系统层面对碎片的管理压力也会降低。</li><li>mcache 的存在使得内存分配不需要加锁。</li></ol><hr><h4 id="为什么内存碎片可能影响性能？"><a href="#为什么内存碎片可能影响性能？" class="headerlink" title="为什么内存碎片可能影响性能？"></a>为什么内存碎片可能影响性能？</h4><blockquote><p>Linux 利用 Intel CPU的保护模式，采用页表的方式对内存进行管理。 虚拟线性地址对应着某个页。这之间的对应关系存在于页表之中。 由于几乎每次对虚拟内存中的页面访问都必须先解析页，从而得到物理内存中的对应地址，所以页表操作的性能非常关键。因此，Intel MMU 系统结构中实现了一个TLB（translate lookaside buffer）作为一个将虚拟地址映射到物理地址的硬件缓存，当请求访问一个虚拟地址时，处理器将首先检查TLB是否缓存了该虚拟地址到物理地址的映射，如果命中则直接返回，否则，就需要通过页表搜索需要的物理地址。</p><p>TLB很小，只有64 entries 。当内存碎片化后，一个进程的虚拟线性地址空间对应于数量众多的小片的页，TLB不能容纳这么多的页面表项，这就意味在这个进程的运行期内，MMU在寻址时，TLB总是不能命中，而需要不断的更新。这就大大的降低了执行的效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http2详解 [下]</title>
      <link href="/2021/08/26/http2-xiang-jie-xia/"/>
      <url>/2021/08/26/http2-xiang-jie-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="8-http2的世界"><a href="#8-http2的世界" class="headerlink" title="8. http2的世界"></a>8. http2的世界</h1><p>那么当http2被广泛采用的时候，世界将会成什么样呢？或者说，它会被真正的采用吗？</p><h2 id="8-1-http2会如何影响普通人？"><a href="#8-1-http2会如何影响普通人？" class="headerlink" title="8.1. http2会如何影响普通人？"></a>8.1. http2会如何影响普通人？</h2><p>到目前为止，http2还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考SPDY的例子和曾经做过的实验来进行大概的估计。</p><p>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了head of line blocking(线头阻塞)的困扰。</p><p>它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。</p><p>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</p><p>所有这些加起来，我认为页面载入时间和站点的响应速度都会更快。简而言之，它们都代表着更好的web体验。</p><p>但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期阶段，我们还无法看见客户端和服务器实现这些并真正受益于它所提供的强大功能。</p><h2 id="8-2-http2会如何影响web开发？"><a href="#8-2-http2会如何影响web开发？" class="headerlink" title="8.2. http2会如何影响web开发？"></a>8.2. http2会如何影响web开发？</h2><p>近年来，web开发者、web开发环境为HTTP 1.1存在的一些问题提供了一部分临时的解决方案。其中的一部分我已在上文中简单的介绍了，不妨简单的回忆一下。</p><p>很多工具和开发者可能会默认使用这些方案，但它们其中的一部分也许会损害到http2的性能，或者至少让我们无法真正利用到http2新提供的强大威力。Spriting和内联应该是http2里面最不需要的了。因为http2更倾向于使用更少的连接，所以Sharding甚至会伤害到http2的性能。</p><p>这里的问题在于：对于网站的开发者而言，在短期内开发和部署同一套前端来支持HTTP 1.1和http2的客户端访问并获得最大性能将会是一个挑战。</p><p>考虑到这些问题，我认为彻底发掘http2的潜力还有很长一段路要走。</p><h2 id="8-3-http2的各种实现"><a href="#8-3-http2的各种实现" class="headerlink" title="8.3. http2的各种实现"></a>8.3. http2的各种实现</h2><p>在这样一篇文章中详细说明每个实现细节注定乏味且毫无意义，我将用更通用的术语来解释实际的场景，并在此给大家提供一个http2的<a href="https://github.com/http2/http2-spec/wiki/Implementations">实现列表</a>作为参考。</p><p>在http2的早期就已经有大量的实现。并且在http2标准化工作期间，这个数量还持续增长。截至我写这篇文档的时候，共有40种实现已记录在案，他们中的大多数都实现了最新的草案。</p><h3 id="8-3-1-浏览器"><a href="#8-3-1-浏览器" class="headerlink" title="8.3.1. 浏览器"></a>8.3.1. 浏览器</h3><p>Firefox一直紧跟最新的协议，Twitter也紧追不舍提供了基于http2的服务。2014年4月期间<!--『从2014年4月开始』会不会更符合原意？-->，Google在少数测试服务器上提供http2支持。从同年5月开始，开发版的Chrome支持http2。Microsoft也在他们的产品预发布会上展示了支持http2的下一代浏览器。Safari (iOS 9 以及 Mac OS X El Capitan) 和 Opera也都表态它们将会支持http2。</p><h3 id="8-3-2-服务器"><a href="#8-3-2-服务器" class="headerlink" title="8.3.2 服务器"></a>8.3.2 服务器</h3><p>事实上，已经有不少的服务器实现了http2。</p><p>时下最流行的Nginx自1.9.5(发布于2015年9月22号)版本后提供了对http2的支持并且取缔了原来的SPDY模块(因此SPDY和http2无法同时运行在同一个Nginx服务器实例中)。</p><p>而Apache HTTPD服务器也实现了一个名为<a href="https://httpd.apache.org/docs/2.4/mod/mod_http2.html">mod_http2</a>的http2模块，并与2015年10月9号在2.4.17的版本中发布。</p><p>此外，<a href="https://h2o.examp1e.net/">H2O</a>, <a href="https://trafficserver.apache.org/">Apache Traffic Server</a>, <a href="https://nghttp2.org/">nghttp2</a>, <a href="https://caddyserver.com/">Caddy</a> 以及 <a href="https://www.litespeedtech.com/products/litespeed-web-server/overview">LiteSpeed</a> 也都发布了可以工作于http2下的服务器。</p><h3 id="8-3-3-其他"><a href="#8-3-3-其他" class="headerlink" title="8.3.3 其他"></a>8.3.3 其他</h3><p>curl和libcurl支持未加密的http2并借助某些TLS库支持了TLS版本。</p><p>Wireshark同样支持了http2, 所以用它来分析http2网络数据流着实是再好不过的了。</p><h2 id="8-4-对http2的常见批评"><a href="#8-4-对http2的常见批评" class="headerlink" title="8.4. 对http2的常见批评"></a>8.4. 对http2的常见批评</h2><p>在制定协议的讨论过程中往往存在许多争议，甚至会有不少人认为这样的协议最终会以失败告终。这里我想提一些常见的对协议的批评以及我的解释：</p><h3 id="8-4-1-“这个协议是Google设计制定的”"><a href="#8-4-1-“这个协议是Google设计制定的”" class="headerlink" title="8.4.1. “这个协议是Google设计制定的”"></a>8.4.1. “这个协议是Google设计制定的”</h3><p>江湖上有太多传言暗示着这个世界越来越被Google所控制，但事实显然并非如此。这个协议是IETF制定的，就跟过去30年间很多其他协议一样。但不得不承认，SPDY是Google非常出色的成果。它不仅仅证明了开发一个新协议的可行性，还充分展现了新协议所能带来的好处。</p><p>而Google也公开<a href="https://blog.chromium.org/2015/02/hello-http2-goodbye-spdy.html">声明</a>了他们会在2016年移除Chrome里对SPDY和NPN的支持，并且极力推动服务器迁移至HTTP/2。2016年2月他们<a href="https://blog.chromium.org/2016/02/transitioning-from-spdy-to-http2.html">声明</a>了SPDY和NPN会在Chrome 51被移除.</p><h3 id="8-4-2-“这个协议只在浏览器上有用”"><a href="#8-4-2-“这个协议只在浏览器上有用”" class="headerlink" title="8.4.2. “这个协议只在浏览器上有用”"></a>8.4.2. “这个协议只在浏览器上有用”</h3><p>在一定意义上，这是对的。开发http2的其中一个主要原因就是修复HTTP pipelining。如果在你的应用场景里本来就不需要pipelining，那么确实很有可能http2对你没有太大帮助。虽然这并不是唯一的提升，但显然这是非常重要的一个。</p><p>一旦当某些服务意识到在一个连接上建立多路复用流的强大威力时，我认为会有越来越多的程序采用http2。</p><p>小规模的REST API和采用HTTP 1.x的简单程序可能并不会从迁移到http2中获得多大的收益。但至少，迁移至http2对绝大部分用户来讲几乎是没有坏处的。</p><h3 id="8-4-3-“这个协议只对大型网站有用”"><a href="#8-4-3-“这个协议只对大型网站有用”" class="headerlink" title="8.4.3. “这个协议只对大型网站有用”"></a>8.4.3. “这个协议只对大型网站有用”</h3><p>完全不是这样。因为缺乏内容分发网络，小网站的网络延迟往往较高，而多路复用的能力可以极大的改善在高网络延迟下的体验。大型网站往往已经将内容分发到各处，所以速度其实已经非常快了。</p><h3 id="8-4-4-“TLS让速度变得更慢”"><a href="#8-4-4-“TLS让速度变得更慢”" class="headerlink" title="8.4.4. “TLS让速度变得更慢”"></a>8.4.4. “TLS让速度变得更慢”</h3><p>这个评价在某种程度上是对的。虽然TLS的握手确实增加了额外的开销，但也有越来越多的方案提出来减少TLS往返的时间。使用TLS而不是纯文本带来的开销是显著的，有可观证据表明，和传输同样的流量相比，TLS会消耗更多的CPU和其他资源。具体影响有多大以及怎么影响是一个和具体测量有关的课题。更多的例子可以参看<a href="https://istlsfastyet.com/">istlsfastyet.com</a>。</p><p>Telecom和一些其他网络服务商，例如ATIS开放网络联盟，表示为了为卫星、飞机等提供的快速网络体验，他们需要一些<a href="https://www.atis.org/openweballiance/docs/OWAKickoffSlides051414.pdf">不加密的流量</a>来提供caching，压缩和其他技术。</p><p>由于http2并不强制要求使用TLS，所以我们不应该为此担心。</p><p>如今，很多互联网使用者都希望TLS能被更广泛的使用来保护用户隐私。</p><p>实验也证明了通过使用TLS能比用在80端口实现一个新的基于文本的协议更容易成功。因为当前已经有太多中间商使用该方案，所以凡是基于80端口的协议，都很可能被理所当然的当作HTTP 1.1。</p><p>最后，得益于http2可以在单一连接上提供多路复用的流，正常使用普通浏览器也可以减少TLS握手的次数，所以使用HTTPS仍然会比HTTP 1.1更快。</p><h3 id="8-4-5-“不基于ASCII是没法忍受的”"><a href="#8-4-5-“不基于ASCII是没法忍受的”" class="headerlink" title="8.4.5. “不基于ASCII是没法忍受的”"></a>8.4.5. “不基于ASCII是没法忍受的”</h3><p>是的，如果我们可以直接读出协议内容，那么调试和追踪都会变得更为简单。但是基于文本的协议更容易产生错误，造成更多解析的问题。</p><p>假如你真的无法接受二进制协议，那么你也很难在HTTP 1.x中处理TLS和压缩。因为其实这些技术已经被使用了很久了。</p><h3 id="8-4-6-“它根本没有比HTTP-1-1快”"><a href="#8-4-6-“它根本没有比HTTP-1-1快”" class="headerlink" title="8.4.6. “它根本没有比HTTP/1.1快”"></a>8.4.6. “它根本没有比HTTP/1.1快”</h3><p>当然，到底该如何定义和衡量“快”就是另外一个话题了，但在SPDY的时代，已经有很多实验证明了该协议会让浏览器载入页面变得更快（例如华盛顿大学的<a href="https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-wang_xiao_sophia.pdf">“SPDY有多快？”</a>和Hervé Servy的<a href="https://www.neotys.com/blog/performance-of-spdy-enabled-web-servers/">“评估启用SPDY后的Web服务器的性能”</a>），同样这些实验也可以被用来证明http2。我期待能有越来越多的诸如此类的测试实验结果发布。而这篇文章<a href="https://blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/">httpwatch.com的一个简单测试</a>亦能证明HTTP/2名副其实。<!-- 那一句“我也期待XX”放在那怪怪的 --></p><h3 id="8-4-7-“它违反了网络分层”"><a href="#8-4-7-“它违反了网络分层”" class="headerlink" title="8.4.7. “它违反了网络分层”"></a>8.4.7. “它违反了网络分层”</h3><p>你确定这也是反对的理由么？网络分层并不是不可侵犯的。如果我们在制定http2的时候已经踏入了灰色地带，那我们当然可以尝试在限制内制定出更好更高效的协议。</p><h3 id="8-4-8-“它并没有修复很多HTTP-1-1的短板”"><a href="#8-4-8-“它并没有修复很多HTTP-1-1的短板”" class="headerlink" title="8.4.8. “它并没有修复很多HTTP/1.1的短板”"></a>8.4.8. “它并没有修复很多HTTP/1.1的短板”</h3><p>确实是这样。兼容HTTP/1.1的范式是我们的目标之一，所以一些老的HTTP功能仍然被保留。例如一些常用的协议头、可怕的cookies、验证头等等。但保留这些范式的好处就是我们在升级到新协议的时候少掉很多工作，也不需要重写很多底层的东西。Http2其实只是一个新的帧层。<!-- 那个"可怕的"cookies该怎么翻译好？ --></p><h2 id="8-5-http2会被广泛部署吗？"><a href="#8-5-http2会被广泛部署吗？" class="headerlink" title="8.5. http2会被广泛部署吗？"></a>8.5. http2会被广泛部署吗？</h2><p>现在讨论这个议题还言之尚早，但我仍然要在这里做出我的预估。</p><p>很多怀疑论者会以“看看IPv6现在的德性”为让我们回想起这个经历了10多年才开始慢慢被采用的协议。但http2毕竟不是IPv6。它是一个建立在TCP之上的使用基于原有HTTP协议升级过后的机制、端口号和TLS等的协议。大部分路由器或者防火墙不需要为此而进行更改。</p><p>Google向世界展示了他们的SPDY，证明了像这样的新协议也能在足够短的时间内拥有多种实现，并且能被浏览器和服务所采用。虽然如今支持SPDY服务器端数量在1%以内，但通过这些服务器所交换的数据却要大很多。很多非常流行的网站现在也有提供SPDY支持。</p><p>我认为建立在SPDY的基本范式之上的http2会被更广泛的部署，其中一个主要的原因是：它是一个IETF制定的协议。而SPDY则因为背负了“它是Google的协议”这个恶名，导致它的发展总是畏首畏脚。</p><p>在它首次发布的幕后有很多大型浏览器支持。来自Firefox，Chrome，Safari，Internet Explorer和Opera的代表宣布了他们会发布支持http2特性的浏览器，并且他们已经演示了一些能正常运作的实现。</p><p>也有很多像Google，Twitter和Facebook这样的服务器运营者希望尽快支持http2，也同样希望可以快点在主流服务器实现中出现对http2的支持（例如Apache HTTP Server和nginx）。而<a href="https://github.com/h2o/h2o">H2o</a>作为一个极具潜力的新生HTTP服务器，已经支持了http2。</p><p>那些大型代理程序开发者，例如HAProxy、Squid和Varnish也表示出了他们对支持http2的兴趣。</p><p>纵观2015年，http2的流量正在逐步上升。9月初，Firefox 40中http2流量占据了所有HTTP流量中的13%，HTTPS中的27%。与此同时，Google表示约有18%的流量来自HTTP/2。值得注意的是，Google同时也在实验其他协议，这也使得http2的使用量暂时比正常值低一些。</p><h1 id="9-Firefox里的http2"><a href="#9-Firefox里的http2" class="headerlink" title="9. Firefox里的http2"></a>9. Firefox里的http2</h1><p>Firefox紧跟着草案，并且很早之前就实现了http2的测试实现。在http2协议开发的时候，客户端和服务器需要采用同一的协议草案版本，进行测试也变得比较繁琐。所以请一定注意你的客户端和服务器支持的是一样的版本。</p><h2 id="9-1-首先，确保它已被启用"><a href="#9-1-首先，确保它已被启用" class="headerlink" title="9.1. 首先，确保它已被启用"></a>9.1. 首先，确保它已被启用</h2><p>从发布于2015年1月13日的Firefox 35之后，http2支持是默认开启的。</p><p>在地址栏里进入’about:config’，再搜索一个名为“network.http.spdy.enabled.http2draft”的选项，确保它被设置为<code>true</code>。Firefox 36添加了一个“network.http.spdy.enabled.http2”的配置项，并默认设置为<em>true</em>。后者控制的是“纯”http2版本，而前者控制了启用／禁用通过http2草案版本进行协商。从Firefox 36之后，这两者都默认为true。</p><h2 id="9-2-仅限TLS"><a href="#9-2-仅限TLS" class="headerlink" title="9.2. 仅限TLS"></a>9.2. 仅限TLS</h2><p>请记住Firefox只在TLS上实现了http2。你只会看到http2只在<code>https://</code>的网站里得到支持。</p><h2 id="9-3-透明！"><a href="#9-3-透明！" class="headerlink" title="9.3. 透明！ "></a>9.3. 透明！ <!--这个标题改成： 一切都是透明的  怎么样--></h2><p><img src="https://image.fyxemmmm.cn/blog/images/h210.png" alt="transparent http2 use"></p><p>在UI上，没有任何元素标明你正在使用http2。但想确认也并不复杂，一种方法是启用“Web developer-&gt;Network”，再查看响应头里面服务器发回来的内容。这个响应是“HTTP/2.0”，并且Firefox也插入了一个自己头“X-Firefox-Spdy:”，如上面截图所示。</p><p>你在这里看到的头文件是网络工具把二进制的http2格式转换成类似HTTP 1.x显示方式的文本格式。</p><h2 id="9-4-图形化HTTP-2"><a href="#9-4-图形化HTTP-2" class="headerlink" title="9.4. 图形化HTTP/2"></a>9.4. 图形化HTTP/2</h2><p>有一些Firefox的插件可以图形化HTTP/2，比如<a href="https://addons.mozilla.org/en-US/firefox/addon/http2-indicator/">“HTTP/2 and SPDY Indicator”</a>。</p><h1 id="10-Chromium里的http2"><a href="#10-Chromium里的http2" class="headerlink" title="10. Chromium里的http2"></a>10. Chromium里的http2</h1><p>Chromium团队并且很早之前就已经在dev和beta分支里面实现并支持了HTTP/2。从2015年1月27日发布的Chrome 40起，http2已经默认为一些用户启用该功能。虽然刚开始用户的数量会很少，但会慢慢增加。</p><p>Chrome 51移除了SPDY的支持来为http2铺路。在2016年2月的一篇<a href="https://blog.chromium.org/2016/02/transitioning-from-spdy-to-http2.html">博客</a>里面有如下一段话：</p><blockquote><p>“在Chrome里有超过25%的资源是通过HTTP/2来传输的，而SPDY只有不到5%。考虑到如此大范围的采用，自5月15日，也就是HTTP/2 RFC的周年纪念日起，Chrome将不再支持SPDY。”</p></blockquote><h2 id="10-1-首先，确保它已被启用"><a href="#10-1-首先，确保它已被启用" class="headerlink" title="10.1. 首先，确保它已被启用"></a>10.1. 首先，确保它已被启用</h2><p>在地址栏里进入<code>chrome://flags/#enable-spdy4</code>，如果没有被enable的话，点击”enable”启用它。</p><h2 id="10-2-TLS-only"><a href="#10-2-TLS-only" class="headerlink" title="10.2. TLS-only"></a>10.2. TLS-only</h2><p>请记住Chrome只在TLS上实现了http2。你只会在以<code>https://</code>做前缀的网站里得到http2的支持。</p><h2 id="10-3-图形化HTTP-2"><a href="#10-3-图形化HTTP-2" class="headerlink" title="10.3. 图形化HTTP/2"></a>10.3. 图形化HTTP/2</h2><p>有一些Chrome的插件可以图形化HTTP/2，比如<a href="https://chrome.google.com/webstore/detail/spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin">“HTTP/2 and SPDY Indicator”</a>。</p><h2 id="10-4-QUIC"><a href="#10-4-QUIC" class="headerlink" title="10.4. QUIC"></a>10.4. QUIC</h2><p>Chrome正在试验QUIC，所以或多或少稀释了HTTP/2的份额。</p><h1 id="11-curl中的http2"><a href="#11-curl中的http2" class="headerlink" title="11. curl中的http2"></a>11. curl中的http2</h1><p><a href="https://curl.haxx.se/">curl项目</a>从2013年9月就开始对http2提供实验性的支持。</p><p>为了遵从curl的要旨，我们尽可能全方位地支持http2。curl通常被用作一个网站连接测试工具，希望这项使命也能在http2上被得以延续。</p><p>curl使用一个叫做<a href="https://nghttp2.org/">nghttp2</a>的库来提供http2帧层的支持。curl依赖于nghttp2 1.0以上版本。</p><p>请注意当前linux curl和libcurl并没有默认启用对HTTP/2协议的支持。</p><h2 id="11-1-跟HTTP-1-x非常相似"><a href="#11-1-跟HTTP-1-x非常相似" class="headerlink" title="11.1. 跟HTTP 1.x非常相似"></a>11.1. 跟HTTP 1.x非常相似</h2><p>curl会在内部把收到的http2头部转换为HTTP1.x风格的头部再呈现给用户，这样一来，它们就和目前的HTTP非常类似。这也使得无论是用curl还是HTTP，转换都非常容易。<!-- TOREVIEW -->类似地，curl会用相同的方式对发出的HTTP头部做转换，即发给curl的HTTP 1.x风格头部会在被发送到http2服务器之前完成转换。这使得户无需关心底层到底使用的是哪个版本的HTTP协议。</p><h2 id="11-2-不安全的纯文本"><a href="#11-2-不安全的纯文本" class="headerlink" title="11.2. 不安全的纯文本"></a>11.2. 不安全的纯文本</h2><p>curl通过升级头部支持基于标准TCP的http2. 当发起一个使用http2的HTTP请求，如果可能，curl会请求服务器把连接升级到http2.</p><h2 id="11-3-TLS和相关库"><a href="#11-3-TLS和相关库" class="headerlink" title="11.3. TLS和相关库"></a>11.3. TLS和相关库</h2><p>curl可以使用许多不同TLS的底层库来提供TLS支持，http2也得这样。TLS兼容http2的挑战来自于对ALPN以及一些NPN扩展的支持。</p><p>基于最新版本的OpenSSL或NSS编译curl可以同时获得ALPN和NPN支持。而使用GnuTLS或PolarSSL只能得到ALPN。</p><h2 id="11-4-命令行中使用"><a href="#11-4-命令行中使用" class="headerlink" title="11.4. 命令行中使用"></a>11.4. 命令行中使用</h2><p>无论是用纯文本还是通过TLS，必须使用<code>--http2</code>参数来让curl使用http2。在未使用该参数的默认情况下，curl会使用HTTP/1.1。</p><h2 id="11-5-libcurl参数"><a href="#11-5-libcurl参数" class="headerlink" title="11.5. libcurl参数"></a>11.5. libcurl参数</h2><h3 id="11-5-1-启用HTTP-2"><a href="#11-5-1-启用HTTP-2" class="headerlink" title="11.5.1 启用HTTP/2"></a>11.5.1 启用HTTP/2</h3><p>应用程序和从前一样使用<code>https://</code>或者<code>http://</code>风格的URL，但你可以通过将<code>curl_easy_setopt</code>的<code>SURLOPT_HTTP_VERSION</code>参数设置为<code>CURL_HTTP_VERSION_2</code>来使libcurl尝试使用http2。它将优先尽可能地使用http2，如果不行的话，会继续使用HTTP 1.1。</p><h3 id="11-5-2-多路复用"><a href="#11-5-2-多路复用" class="headerlink" title="11.5.2 多路复用"></a>11.5.2 多路复用</h3><p>正如libcurl想尽可能量维持以前的用法，你需要通过<a href="https://curl.haxx.se/libcurl/c/CURLMOPT_PIPELINING.html">CURLMOPT_PIPELINING</a>参数为你的程序启用HTTP/2多路复用功能。不然的话，它会保持一个连接只发送一个请求。</p><p>另一个需要注意的小细节是，当你通过libcurl同时请求多个传输的时候，请使用多接口模式。这样能使应用程序能同时启用任意数量的传输。如果你宁愿让libcurl等待也要把它们放到同一个连接来传输的话，请使用<a href="https://curl.haxx.se/libcurl/c/CURLOPT_PIPEWAIT.html">CURLOPT_PIPEWAIT</a>参数。</p><h3 id="11-5-3-服务器推送"><a href="#11-5-3-服务器推送" class="headerlink" title="11.5.3 服务器推送"></a>11.5.3 服务器推送</h3><p>libcurl 7.44.0及其后续版本开始支持HTTP/2服务器推送功能。你可以通过在<a href="https://curl.haxx.se/libcurl/c/CURLMOPT_PUSHFUNCTION.html">CURLMOPT_PUSHFUNCTION</a>参数中设定一个推送回调来激活该功能。如果应用程序接受了该推送，它将为CURL建立一个新的传输，以便接受内容。<!-- 最后一句需要review --></p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http2详解 [中]</title>
      <link href="/2021/08/25/http2-xiang-jie-zhong/"/>
      <url>/2021/08/25/http2-xiang-jie-zhong/</url>
      
        <content type="html"><![CDATA[<h1 id="5-http2的基本概念"><a href="#5-http2的基本概念" class="headerlink" title="5. http2的基本概念"></a>5. http2的基本概念</h1><p>http2到底做了些什么呢？而HTTPbis小组究竟又应该把它制定到什么样的程度呢？</p><p>事实上，http2有着非常严格的边界，这也给小组成员的创新带来了些许限制。</p><ul><li><p>http2必须维持HTTP的范式。毕竟它只是一个让客户端发送请求到服务器的基于TCP的协议。</p></li><li><p>不能改变 http:// 和 https:// 这样的URL，也不能对其添加新的结构。使用这类URL的网站太多了，没法指望他们全部改变。</p></li><li><p>HTTP1的服务器和客户端依然会存在很久，所以我们必须提供HTTP1到http2服务器的代理。</p></li><li><p>随后，我们也要让这种代理能够将http2的功能一对一的映射到HTTP 1.1的客户端。</p></li><li><p>删除或者减少协议里面那些可选的部分。虽然这并不算的上是一个需求，但是SPDY和Google的团队都非常喜欢这点。通过让协议里所有的内容都成为了强制性要求，可以防止人们在实现的时候偷懒，从而规避一些将来可能会发生的问题。</p></li><li><p>不再使用小版本号。服务器和客户端都必须确定自己是否完整兼容http2或者彻底不兼容。如果将来该协议需要被扩充或者变更，那么新的协议将会是http3，而不是http 2.x。</p></li></ul><h2 id="5-1-http2和现有的URI结构"><a href="#5-1-http2和现有的URI结构" class="headerlink" title="5.1. http2和现有的URI结构"></a>5.1. http2和现有的URI结构</h2><p>如上所述，现有的URI结构正在被HTTP 1.x使用而不能被更换，所以http2也必须沿用该结构。因此不得不找到一种方式将使用的协议升级至http2，比如可以要求服务器让它作响应时使用http2来替代旧的协议。</p><p>HTTP 1.1本身就制定过“升级”的方案：提供一个首部字段，表示允许服务器在收到旧协议请求的同时，可以向客户端发送新协议的响应。但这一方案往往需要花费一次额外的往返通信来作为升级的代价。</p><p>而这一代价是SPDY团队不想接受的。因为他们只实现了基于TLS的SPDY，所以他们开发了一个TLS的扩展去简化协议的协商。这个扩展被称作NPN（Next Protocol Negotiation），借助于此，服务器会通知客户端所有它支持的协议，让客户端从中选择一个合适的来进行通讯。</p><h2 id="5-2-为-https-所准备的http2"><a href="#5-2-为-https-所准备的http2" class="headerlink" title="5.2. 为 https:// 所准备的http2"></a>5.2. 为 https:// 所准备的http2<!--这节比较复杂，需要review--></h2><p>有相当多的人关注到了http2可以在TLS上正常的运作，而SPDY依赖于TLS，所以按理说TLS也应成为http2 必需的组件，不过出乎大家意料的是http2将TLS标记成了可选。然而，全球两大浏览器领导者 —— Firefox和Chrome都明确地表示，他们只会实现基于TLS的http2.</p><p>选择TLS的原因的其中之一是希望保护以及尊重用户的隐私，而早期的评估结果也表明，在TLS上建立新的协议更有可能获得成功。而这其中部分原因是人们普遍认为任何来自80端口的流量都是基于HTTP 1.1亦或者是其某个变种的，而不是另外一种全新的协议。</p><p>关于是否应该强制使用TLS的主题在邮件组内和会议上引起了不小的争议 —— 这到底是好是坏呢？不管怎么样，对于这种备受争议的话题还是请谨慎讨论，尤其是当你面对一个HTTPbis小组成员的时候。</p><p>诸如此类，还有一个激烈而长期的讨论，即：如果选择了使用TLS，那http2是否应该强制规定密码列表，也许应该建立起一个黑名单，又或者它根本就不需要从TLS层得到任何东西。不过这个问题还是留给TLS工作组去解决吧，最后的规范中指定了TLS最低版本为1.2，并且会有加密组的限制。</p><h2 id="5-3-基于TLS之上的http2协商"><a href="#5-3-基于TLS之上的http2协商" class="headerlink" title="5.3 基于TLS之上的http2协商 "></a>5.3 基于TLS之上的http2协商 <!-- 这个标题翻译的不好 --></h2><p>Next Protocol Negotiation (NPN)是一个用来在TLS服务器上协商SPDY的协议。IETF将这个非正式标准进行规范化，从而演变成了ALPN（Application Layer Protocol Negotiation）。ALPN会随着http2的应用被推广，而SPDY的客户端与服务器则会继续使用NPN。</p><p>由于NPN先于ALPN诞生，而ALPN又经历了一些标准化过程，所以许多早期的http2客户端和服务器在协商http2时会将这两者同时实现。与此同时，考虑到SPDY会使用NPN，而许多服务器又会同时提供SPDY以及http2，所以在这些服务器上同时支持ALPN以及NPN显然会成为最理所当然的选择。</p><p>ALPN和NPN的主要区别在于：谁来决定通信协议。在ALPN的描述中，是让客户端先发送一个协议优先级列表给服务器，由服务器最终选择一个合适的。而NPN则正好相反，客户端有着最终的决定权。</p><h2 id="5-4-为-http-所准备的http2"><a href="#5-4-为-http-所准备的http2" class="headerlink" title="5.4 为 http:// 所准备的http2"></a>5.4 为 http:// 所准备的http2</h2><p>正如我们之前所提到的，对于纯文本的HTTP1.1来说，协商http2的方法就是通过给服务器发送一个带<strong>升级</strong>头部的报文。如果服务器支持http2，它将以“101 Switching”作为回复的状态码，并从此开始在该连接上使用http2。也许你很容易就发现这样一个升级的流程会需要消耗掉一整个的往返时延，但好处是http2连接相比HTTP1可以被更大限度地重用和保持。</p><p>虽然有些浏览器厂商的发言人宣称他们不会实现这样的http2会话方式，但IE团队已公开表示他们会实现，与此同时，curl也已经支持了这种方式。</p><p>直到今天，没有任何主流浏览器支持非TLS的http2.</p><h1 id="6-http2协议"><a href="#6-http2协议" class="headerlink" title="6. http2协议"></a>6. http2协议</h1><p>背景介绍就到此为止了，历史的脚步已经将我们推到了今天。现在让我们深入看看该协议的规范，看看那些细节和概念。</p><h2 id="6-1-二进制"><a href="#6-1-二进制" class="headerlink" title="6.1. 二进制"></a>6.1. 二进制</h2><p>http2是一个二进制协议。</p><p>仔细想想，如果你是一个曾经跟互联网协议打过交道，那你很可能会本能反对二进制协议，你甚至准备好了一大堆理由来证明基于文本/ascii的协议是多么的有用，正如你曾无数次地通过telnet等应用手工地输入HTTP来发起请求。</p><p>基于二进制的http2可以使成帧的使用变得更为便捷。在HTTP1.1和其他基于文本的协议中，对帧的起始和结束识别起来相当复杂。而通过移除掉可选的空白符以及其他冗余后，再来实现这些会变得更容易。</p><p>而另一方面，这项决议同样使得我们可以更加便捷的从帧结构中分离出那部分协议本身的内容。而在HTTP1中，各个部分相互交织，犹如一团乱麻。</p><p>事实上，由于协议提供了压缩这一特性，而其经常运行在TLS之上的事实又再次降低了基于纯文本实现的价值，反正也没办法直接从数据流上看到文本。因此通常情况下，我们必须习惯使用类似Wireshark这样的工具对http2的协议层一探究竟。</p><p>我们可以使用curl这样的工具来调试协议，而如果要进一步地分析网络数据流则需要诸如Wireshark这样的http2解析器。</p><h2 id="6-2-二进制格式"><a href="#6-2-二进制格式" class="headerlink" title="6.2. 二进制格式"></a>6.2. 二进制格式</h2><img style="float: right;" src="https://image.fyxemmmm.cn/blog/images/h26.png"><p>http2会发送有着不同类型的二进制帧，但他们都有如下的公共字段：Type, Length, Flags, Stream Identifier和frame payload <!-- 这些字段要翻译么？ --></p><p>规范中一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP 1.1的DATA和HEADERS。之后我会更详细的介绍它们其中的一部分。</p><h2 id="6-3-多路复用的流"><a href="#6-3-多路复用的流" class="headerlink" title="6.3. 多路复用的流"></a>6.3. 多路复用的流</h2><p>上一节提到的Stream Identifier将http2连接上传输的每个帧都关联到一个“流”。流是一个独立的，双向的帧序列可以通过一个http2的连接在服务端与客户端之间不断的交换数据。<!-- 这一句翻译的不太好。 --></p><p>每个单独的http2连接都可以包含多个并发的流，这些流中交错的包含着来自两端的帧。流既可以被客户端/服务器端单方面的建立和使用，也可以被双方共享，或者被任意一边关闭。在流里面，每一帧发送的顺序非常关键。接收方会按照收到帧的顺序来进行处理。</p><p>流的多路复用意味着在同一连接中来自各个流的数据包会被混合在一起。就好像两个（或者更多）独立的“数据列车”被拼凑到了一辆列车上，但它们最终会在终点站被分开。下图就是两列“数据火车”的示例</p><p><img src="https://image.fyxemmmm.cn/blog/images/h27.jpg" alt="one train"><br><img src="https://image.fyxemmmm.cn/blog/images/h28.jpg" alt="another train"></p><p>它们就是这样通过多路复用的方式被组装到了同一列火车上。</p><p><img src="https://image.fyxemmmm.cn/blog/images/h29.jpg" alt="multiplexed train"></p><h2 id="6-4-优先级和依赖性"><a href="#6-4-优先级和依赖性" class="headerlink" title="6.4. 优先级和依赖性"></a>6.4. 优先级和依赖性</h2><p>每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流。</p><p>借助于PRIORITY帧，客户端同样可以告知服务器当前的流依赖于其他哪个流。该功能让客户端能建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况。</p><p>优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到页面所包含流的优先级。 <!--或者是当你在切换标签页的时候，浏览器可以提升那个突然被切换到的页面所包含的流的优先级--></p><h2 id="6-5-头压缩"><a href="#6-5-头压缩" class="headerlink" title="6.5. 头压缩"></a>6.5. 头压缩</h2><p>HTTP是一种无状态的协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为http2并没有改变这个范式，所以它也以同样原理工作。</p><p>这也保证了HTTP可重复性。当一个客户端从同一服务器请求了大量资源（例如页面的图片）的时候，所有这些请求看起来几乎都是一致的，而这些大量一致的东西则正好值得被压缩。</p><p>每个页面请求的资源数量在增多（如前所述），同时 cookies 的使用和请求的大小也在日渐增长。cookies需要被包含在所有请求中，且他们在多个请求中经常是一模一样的。</p><p>HTTP 1.1请求的大小正变得越来越大，有时甚至会大于TCP窗口的初始大小，这会严重拖累发送请求的速度。因为它们需要等待带着ACK的响应回来以后，才能继续被发送。这也是另一个需要压缩的理由。</p><h3 id="6-5-1-压缩是非常棘手的课题"><a href="#6-5-1-压缩是非常棘手的课题" class="headerlink" title="6.5.1. 压缩是非常棘手的课题"></a>6.5.1. 压缩是非常棘手的课题</h3><p>HTTPS和SPDY的压缩机制被发现有受<a href="https://en.wikipedia.org/wiki/BREACH_%28security_exploit%29">BREACH</a>和<a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a>攻击的隐患。通过向流中注入一些已知的文本来观察输出的变化，攻击者可以从加密的载荷中推导出原始发送的数据。</p><p>为协议的动态内容进行压缩并使其免于被攻击，需要仔细且全面的考虑，而这也正是HTTPbis小组尝试去做的。</p><p><a href="https://www.rfc-editor.org/rfc/rfc7541.txt">HPACK</a>，HTTP/2头部压缩，顾名思义它是一个专为http2头部设计的压缩格式。确切的讲，它甚至被制定写入在另外一个单独的草案里。新的格式同时引入了一些其他对策让破解压缩变得困难，例如采用帧的可选填充和用一个bit作为标记，来让中间人不压缩指定的头部。<!-- 最后这句不太好 --> <!--这里中间人翻译成代理会不会更好，中间人一般都会自然联想到MITM攻击（比如我...）--></p><p>用Roberto Peon（HPACK的设计者之一）的话说</p><blockquote><p>“HPACK旨在提供一个一致性的实现使信息量的损失尽可能少，使编解码快速而方便，使接收方能控制压缩文本的大小，允许代理重新建立索引（如，通过代理在前后端共享状态），以及对哈夫曼编码串的更快速比较”<!-- 这一段需要review --></p></blockquote><h2 id="6-6-重置-后悔药"><a href="#6-6-重置-后悔药" class="headerlink" title="6.6. 重置 - 后悔药"></a>6.6. 重置 - 后悔药<!-- 这个翻译太别扭了。。--></h2><p>HTTP 1.1的有一个缺点是：当一个含有确切值的Content-Length的HTTP消息被送出之后，你就很难中断它了。当然，通常你可以断开整个TCP链接（但也不总是可以这样），但这样导致的代价就是需要通过三次握手来重新建立一个新的TCP连接。</p><p>一个更好的方案是只终止当前传输的消息并重新发送一个新的。在http2里面，我们可以通过发送RST_STREAM帧来实现这种需求，从而避免浪费带宽和中断已有的连接。</p><h2 id="6-7-服务器推送"><a href="#6-7-服务器推送" class="headerlink" title="6.7. 服务器推送"></a>6.7. 服务器推送</h2><p>这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。</p><p>服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个RST_STREAM帧来中止。</p><h2 id="6-8-流量控制"><a href="#6-8-流量控制" class="headerlink" title="6.8. 流量控制"></a>6.8. 流量控制</h2><p>每个http2流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。如果你正好知道SSH的工作原理的话，这两者非常相似。</p><p>对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p><p>而只有数据帧会受到流量控制。</p><h1 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h1><p>http2协议强制规定了接收方必须读取并忽略掉所有未知帧（即未知帧类型的帧）。双方可以在逐跳原则（hop-by-hop basis）基础上协商使用新的帧，但这些帧的状态无法被改变，也不受流控制。</p><p>是否应该允许添加扩展的这个话题在制定http2协议的时候被反复讨论了很久，但在draft-12之后，最终尘埃落定确定了允许添加扩展。</p><p>但扩展不再是协议本身的一部分，它被记录在核心协议规范之外。现在已经有两种类型的帧被工作组记录在案，它们很可能率先被纳入协议的扩展部分，而这两个曾被当作“原生”的帧非常流行，所以接下来我会详细讨论它们。</p><h2 id="7-1-备选服务（Alternative-Services）"><a href="#7-1-备选服务（Alternative-Services）" class="headerlink" title="7.1. 备选服务（Alternative Services）"></a>7.1. 备选服务（Alternative Services）</h2><p>随着http2逐渐被接受，我们有理由相信，相对于HTTP 1.x，TCP连接会更长并被保持的更久。对客户端来讲，最好是到每个主机/站点的每一条连接都可以做尽可能多的事情，而这也需要每个连接可以保持更长的时间。</p><p>但这会影响到HTTP负载均衡器的正常工作，比如在一个网站会出于性能的考虑，当然也可能是正常的维护或者一些类似的原因，想建议客户端连接到另外一个主机的时候。<!-- 这一段需要review --></p><p>服务器将会通过发送<a href="https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-10">Alt-Svc头</a>（或者http2的ALTSVC帧）来告知客户端另一个备选服务。即另外一条指向不同的服务源、主机或端口，但却能获取同样内容的路由。</p><p>客户端应该尝试异步的去连接到该服务，如果连接成功的话，即可以使用该备选服务。<!-- 这一段需要review --></p><h3 id="7-1-1-机会型TLS（Opportunistic-TLS）"><a href="#7-1-1-机会型TLS（Opportunistic-TLS）" class="headerlink" title="7.1.1. 机会型TLS（Opportunistic TLS）"></a>7.1.1. 机会型TLS（Opportunistic TLS）</h3><p>Alt-Svc头部意味着允许服务器基于<code>http://</code>提供内容，与此同时，这个头部也意味着告知客户端：同样的内容也可以通过TLS连接来获取。</p><p>这是个还在讨论中的功能。因为这样的连接会产生一个未认证的、在任何地方也不会被标示为“安全”的TLS连接，也不会在客户端界面上出现任何锁标识，所以没法让用户知道这其实不是常规的HTTP连接。这就是很多人强烈反对机会型TLS的原因。</p><h2 id="7-2-阻塞（Blocked）"><a href="#7-2-阻塞（Blocked）" class="headerlink" title="7.2. 阻塞（Blocked）"></a>7.2. 阻塞（Blocked）</h2><p>这个类型的帧意味着：当服务端存在需要发送的内容，但流控制却禁止发送任何数据时，那么此类型的帧将会被发送且<strong>仅</strong>发送一次。这种帧设计的目的在于，如果你接收到了此帧，那么连接中必然有错误发生或者是得到了低于期望的传输速度。<!-- 这一段需要review --></p><p>在此帧被放到协议扩展部分之前，draft-12中的一段话：</p><blockquote><p>”阻塞帧被包含在草案版本中作为实验性的特性，如果它无法获得良好的反馈，那么该特性最后会被移除。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http2详解 [上]</title>
      <link href="/2021/08/24/http2-xiang-jie-shang/"/>
      <url>/2021/08/24/http2-xiang-jie-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>这篇文档会从技术和协议层面来介绍http2。</p><p>如果你有在这篇文章中发现任何我的失误造成的错误或疏漏，请帮我指正。我会在后续版本中修改。</p><p>为了让阅读体验更流畅，在这篇文章中我会使用“http2”来指代这一新协议，但请记住该协议的正式名字是HTTP/2。</p><hr><h1 id="2-HTTP的现状"><a href="#2-HTTP的现状" class="headerlink" title="2. HTTP的现状"></a>2. HTTP的现状</h1><p>几乎所有互联网上的内容都采用了HTTP 1.1作为通信协议。人们在该协议上投入了大量精力，所以基于它的基础架构也得以日臻完善。而得益于此，在现有的HTTP协议之上构建新的方案会比从底层建立新的协议要容易得多。</p><h2 id="2-1-HTTP-1-1过于庞大"><a href="#2-1-HTTP-1-1过于庞大" class="headerlink" title="2.1 HTTP 1.1过于庞大"></a>2.1 HTTP 1.1过于庞大</h2><p>HTTP刚诞生的时候只被当作是一个相对简单直观的协议，但时间证明了早期的设计并不尽人意。于1996年发布的、描述HTTP 1.0规范的RFC 1945只有60页，但仅仅3年之后、描述HTTP 1.1规范的RFC 2616就一下增长到了176页。而当我们在IETF小组对该规范进行更新时，它更是被拆分成了总页数更多的六个文档（这就是RFC 7230及其文件族的由来与诞生）。总而言之，HTTP 1.1包含了太多细节和可选的部分，这让它变得过于庞大。</p><h2 id="2-2-过多的可选项"><a href="#2-2-过多的可选项" class="headerlink" title="2.2 过多的可选项"></a>2.2 过多的可选项</h2><p>HTTP 1.1不仅包含了非常多的细枝末节，同时也为未来的扩展预留了很多选项。这种事无巨细的风格导致在现有的软件生态中，几乎没有任何实现真正实现了协议中提及的所有细节，甚至要弄清楚“所有细节”到底包括哪些细节都非常困难。而这也导致了很多最初不常用的功能在后来的实现中很少会被支持，而有些最初实现了的功能，却又很少被使用。</p><p>随着时间推移，这些当初看似被边缘化的功能逐渐被用上，客户端和服务器的互用性（interoperability）问题就被暴露了出来。HTTP管线化（HTTP pipelining）就是一个非常好的例子。</p><h2 id="2-3-未能被充分利用的TCP"><a href="#2-3-未能被充分利用的TCP" class="headerlink" title="2.3 未能被充分利用的TCP"></a>2.3 未能被充分利用的TCP</h2><p>HTTP 1.1很难榨干TCP协议所能提供的所有性能。HTTP客户端和浏览器必须要另辟蹊径的去找到新的解决方案来降低页面载入时间。</p><p>与此同时，人们也尝试去用新的协议来替代TCP，但结果证明这也非常困难。无奈之下，我们只能尝试同时改进TCP协议本身和基于TCP的上层协议。</p><p>简单来说，我们可以通过更好的利用TCP来减少传输过程中的暂停，并充分挖掘利用那些本可以用于发送/接受更多数据的时间。下面几段我们将会着重讨论这些问题。</p><h2 id="2-4-传输大小和资源数量"><a href="#2-4-传输大小和资源数量" class="headerlink" title="2.4 传输大小和资源数量"></a>2.4 传输大小和资源数量</h2><p>如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。  近年来加载网站首页需要的下载的数据量在逐渐增加，并已经超过了1.9MB。但在这里我们更应该关心的是：平均每个页面为了完成显示与渲染所需要下载的资源数已经超过了100个。</p><p>正如下图所示，这种趋势已经持续了很长一段时间，并且没有减缓的迹象。该图表中绿色直线展示了传输数据大小的增长，红色直线展示了平均请求资源数量的增长。</p><p><img src="https://image.fyxemmmm.cn/blog/images/h21.png" alt="transfer size growth"></p><h2 id="2-5-恼人的延迟"><a href="#2-5-恼人的延迟" class="headerlink" title="2.5 恼人的延迟"></a>2.5 恼人的延迟</h2><img style="float: right;" src="https://image.fyxemmmm.cn/blog/images/h22.png"><p>HTTP 1.1对网络延迟非常敏感。部分原因是HTTP pipelining还存有很多问题，所以对大部分用户来说这项技术是被默认关闭的。</p><p>虽然近几年来网络带宽增长非常快，然而我们却并没有看到网络延迟有对应程度的降低。在高延迟的网络上（比如移动设备），即使拥有高连接速率，也很难获得优质快速的网络体验。</p><p>另外一个需要低延迟的场景是某些视频服务，如视频会议、游戏和一些类似无法预生成待发送数据流的服务。</p><h2 id="2-6-线头阻塞（Head-of-line-blocking）"><a href="#2-6-线头阻塞（Head-of-line-blocking）" class="headerlink" title="2.6 线头阻塞（Head-of-line blocking）"></a>2.6 线头阻塞（Head-of-line blocking）</h2><p>HTTP pipelining是这样一种技术：在等待上一个请求响应的同时，发送下一个请求。(译者注：作者这个解释并不完全正确，HTTP pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。)但就像在超市收银台或者银行柜台排队时一样，你并不知道前面的顾客是干脆利索的还是会跟收银员/柜员磨蹭到世界末日（译者注：不管怎么说，服务器（即收银员/柜员）是要按照顺序处理请求的，如果前一个请求非常耗时（顾客磨蹭），那么后续请求都会受到影响），这就是所谓的线头阻塞（head-of-line blocking）。</p><img style="float: right;" src="https://image.fyxemmmm.cn/blog/images/h23.png"><p>当然，你可以在选择队伍时候就做好功课，去排一个你认为最快的队伍，或者甚至另起一个新的队伍（译者注：即新建一个TCP连接）。但不管怎么样，你总归得先选择一个队伍，而且一旦选定之后，就不能更换队伍。</p><p>但是，另起新队伍会导致资源耗费和性能损失（译者注：新建 TCP 连接的开销非常大）。这种另起新队伍的方式只在新队伍数量很少的情况下有作用，因此它并不具备可扩展性。（译者注：这段话意思是说，靠大量新建连接是不能有效解决延迟问题的，即HTTP pipelining并不能彻底解决head-of-line blocking问题。）所以针对此问题并没有完美的解决方案。</p><p>这就是为什么即使到了今天，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining这一功能的原因。</p><p>而关于这个问题的更多细节，可以参阅Firefox的 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=264354">bugzilla #264354</a>。</p><h1 id="3-那些年，克服延迟之道"><a href="#3-那些年，克服延迟之道" class="headerlink" title="3. 那些年，克服延迟之道"></a>3. 那些年，克服延迟之道</h1><p>再困难的问题也有解决的方案，但这些方案却良莠不齐。</p><h2 id="3-1-Spriting"><a href="#3-1-Spriting" class="headerlink" title="3.1 Spriting"></a>3.1 Spriting</h2><img style="float: right;" src="https://image.fyxemmmm.cn/blog/images/h24.jpg"><p>Spriting是一种将很多较小的图片合并成一张大图，再用JavaScript或者CSS将小图重新“切割”出来的技术。</p><p>网站可以利用这一技巧来达到提速的目的——在HTTP 1.1里，下载一张大图比下载100张小图快得多。</p><p>但是当某些页面只需要显示其中一两张小图时，这种缓存整张大图的方案就显得过于臃肿。同时，当缓存被清楚的时候的时候，Spriting会导致所有小图片被同时删除，而不能选择保留其中最常用的几个。</p><h2 id="3-2-内联（Inlining）"><a href="#3-2-内联（Inlining）" class="headerlink" title="3.2 内联（Inlining）"></a>3.2 内联（Inlining）</h2><p>Inlining是另外一种防止发送很多小图请求的技巧，它将图片的原始数据嵌入在CSS文件里面的URL里。而这种方案的优缺点跟Spriting很类似。</p><pre><code>.icon1 {    background: url(data:image/png;base64,&lt;data&gt;) no-repeat;  }.icon2 {    background: url(data:image/png;base64,&lt;data&gt;) no-repeat;  }</code></pre><h2 id="3-3-拼接（Concatenation）"><a href="#3-3-拼接（Concatenation）" class="headerlink" title="3.3 拼接（Concatenation）"></a>3.3 拼接（Concatenation）</h2><p>大型网站往往会包含大量的JavaScript文件。开发人员可以利用一些前端工具将这些文件合并为一个大的文件，从而让浏览器能只花费一个请求就将其下载完，而不是发无数请求去分别下载那些琐碎的JavaScript文件。但凡事往往有利有弊，如果某页面只需要其中一小部分代码，它也必须下载完整的那份；而文件中一个小小的改动也会造成大量数据的被重新下载。</p><p>这种方案也给开发者造成了很大的不便。</p><h2 id="3-4-分片（Sharding）"><a href="#3-4-分片（Sharding）" class="headerlink" title="3.4 分片（Sharding）"></a>3.4 分片（Sharding）</h2><p>最后一个我要说的性能优化技术叫做“Sharding”。顾名思义，Sharding就是把你的服务分散在尽可能多的主机上。这种方案乍一听比较奇怪，但是实际上在这背后却蕴藏了它独辟蹊径的道理！</p><p>最初的HTTP 1.1规范提到一个客户端最多只能对同一主机建立两个TCP连接。因此，为了不和规范冲突，一些聪明的网站使用了新的主机名，这样的话，用户就能和网站建立更多的连接，从而降低载入时间。</p><p>后来，两个连接的限制被取消了，现在的客户端可以轻松地和每个主机建立6-8个连接。但由于连接的上限依然存在，所以网站还是会用这种技术来提升连接的数量。而随着资源个数的提升（上面章节的图例），网站会需要更多的连接来保证HTTP协议的效率，从而提升载入速度。在现今的网站上，使用50甚至100个连接来打开一个页面已经并不罕见。根据<a href="https://httparchive.org/">httparchive.org</a>的最新记录显示，在Top 30万个URL中平均使用40（！）个TCP连接来显示页面，而且这个数字仍然在缓慢的增长中。</p><p>另外一个将图片或者其他资源分发到不同主机的理由是可以不使用cookies，毕竟现今cookies的大小已经非常可观了。无cookies的图片服务器往往意味着更小的HTTP请求以及更好的性能！</p><p>下面的图片展示了访问一个瑞典著名网站的时产生的数据包，请注意这些请求是如何被分发到不同主机的。</p><p><img src="https://image.fyxemmmm.cn/blog/images/h25.jpg" alt="image sharding at expressen.se"></p><h1 id="4-升级HTTP"><a href="#4-升级HTTP" class="headerlink" title="4. 升级HTTP"></a>4. 升级HTTP</h1><p>花点功夫去改善HTTP协议显然是极好的事情。我们可以着手于以下几个方面：</p><ol><li>降低协议对延迟的敏感</li><li>修复pipelining和head of line blocking的问题</li><li>防止主机需求更高的连接数量</li><li>保留所有现有的接口，内容，URI格式和结构</li><li>由IETF的HTTPbis工作组来制定  <!-- 这一段有点莫名其妙 --></li></ol><h2 id="4-1-IETF和HTTPbis工作组"><a href="#4-1-IETF和HTTPbis工作组" class="headerlink" title="4.1. IETF和HTTPbis工作组"></a>4.1. IETF和HTTPbis工作组</h2><p>The Internet Engineering Task Force (IETF)是一个开发和推广互联网标准的组织。他们的重心是在协议层面。他们最出名的工作是制定了TCP、DNS、FTP和它们最佳实践的RFC规范，但HTTP和许多其他协议却进展缓慢。<!-- 最后一句话不太好 --></p><p>IETF成立了独立的“工作小组”以便完成某些特定领域内的目标，他们建立了一个“章程”用以制定达到目标的指导方针和规范。在这里，任何人都可以参与讨论和开发，并且每个人有同等的话语权，没人关心你来自哪个公司或组织。</p><p>HTTPbis工作组（我们待会儿再解释这个名字）在2007年夏天成立之后就着手于HTTP1.1标准的更新。在组内，关于下一版本HTTP协议的讨论实际上在2012年后期才开始。而HTTP1.1的更新工作在2014年初完成，并被整理成<a href="https://tools.ietf.org/html/rfc7320">RFC 7320</a>系列。</p><p>2014年6月初，HTTPbis工作组名义上的最终版文档会议在纽约召开。而剩下的讨论以及等IETF走完流程通过官方的RFC版本预计在来年完成。<!-- 这一段有点别扭 --> <!-- 而余下的讨论以及IETF流程会等到正式通过官方的RFC版本后继续，并预计来年完成。  不太确定这样翻好不好 --></p><p>一些HTTP领域的权威缺席了工作组的讨论和会议。我并不想在此提及任何公司和产品。但藉此，现在互联网上也有一些参与者因此获得了更多信心——不需要这些公司参与IETF也能做得很好。。。  </p><h3 id="4-1-1-名字中的“bis”"><a href="#4-1-1-名字中的“bis”" class="headerlink" title="4.1.1. 名字中的“bis”"></a>4.1.1. 名字中的“bis”</h3><p>工作组名字中的“bis”来自拉丁语中表示<a href="https://en.wiktionary.org/wiki/bis#Latin">“二”</a>的副词，Bis通常被IETF用作名字的后缀来以表示标准的升级或者一些二次工作，比如这里是针对HTTP1.1。</p><h2 id="4-2-起源于SPDY的http2"><a href="#4-2-起源于SPDY的http2" class="headerlink" title="4.2. 起源于SPDY的http2"></a>4.2. 起源于SPDY的http2</h2><p><a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>是由Google牵头开发的协议。他们将其开源，使得每个人都可以参与开发。但很明显，他们通过控制浏览器的实现和享用着优质服务的大量用户来获益。<!-- 这一句段翻译的怪怪的 --></p><p>当HTTPbis小组决定开始制定http2的时候，SPDY已经充分证实了它是一个非常好用的方案。当时已经有人在互联网上成功部署SPDY，并且也有一些文章讨论他的性能。因此，http2便基于SPDY/3草案进行一些修改之后发布了http2的draft-00。</p><!-- Review备注：有几段怪怪的，已标出 -->]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自签证书 &amp; 原理</title>
      <link href="/2021/08/20/zi-qian-ca-zheng-shu/"/>
      <url>/2021/08/20/zi-qian-ca-zheng-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="自签ca证书，及颁发证书"><a href="#自签ca证书，及颁发证书" class="headerlink" title="自签ca证书，及颁发证书"></a>自签ca证书，及颁发证书</h1><p>cd /etc/pki/CA</p><h2 id="服务端生成ca证书"><a href="#服务端生成ca证书" class="headerlink" title="服务端生成ca证书"></a>服务端生成ca证书</h2><p>自签名证书，依赖自己的私钥</p><ol><li><p>生成私钥文件</p><p><strong>(umask 077;openssl genrsa -out private/cakey.pem 4096)</strong></p></li><li><p>直接生成自签名的证书</p><p><strong>openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650</strong></p><blockquote><p><code>x509代表生成的是自签名的证书，不带x509代表是向ca生成的证书，不是自签名的</code> </p><p><strong>要借助私钥文件生成自签名的证书</strong></p></blockquote><p><img src="https://image.fyxemmmm.cn/blog/images/crt1.png" alt="ca证书生成"></p></li><li><p>查看证书信息</p><p><strong>openssl x509 -in cacert.pem -noout -text</strong></p><p><img src="https://image.fyxemmmm.cn/blog/images/crt2.png" alt="ca证书"></p></li></ol><h2 id="服务端生成证书数据库"><a href="#服务端生成证书数据库" class="headerlink" title="服务端生成证书数据库"></a>服务端生成证书数据库</h2><blockquote><p>这里由于我们是自己的宿主机作为ca的管理、吊销及维护，所以需要一个数据库</p></blockquote><ol><li><p><strong>touch /etc/pki/CA/index.txt</strong> 添加数据库文件</p></li><li><p><strong>touch /etc/pki/CA/serial</strong> 新证书要从几开始编号，这个是记录用的，16进制数</p></li><li><p><strong>echo 0F &gt; /etc/pki/CA/serial</strong> 下次颁发证书的时候 就是15这个编号了</p><p><img src="https://image.fyxemmmm.cn/blog/images/crt3.png" alt="颁发证书的编号"></p></li></ol><h2 id="客户端侧用户申请证书"><a href="#客户端侧用户申请证书" class="headerlink" title="客户端侧用户申请证书"></a>客户端侧用户申请证书</h2><blockquote><p>证书可能是给某个服务用，比如给https服务用，https可能有自己配置数据的文件夹</p></blockquote><ol><li><p>生成应用私钥</p><p><strong>(umask 066; openssl genrsa -out app.key 1024)</strong></p><blockquote><p>注: 你申请证书的时间不是由你说了算，是颁发机构说了算</p></blockquote></li><li><p>生成csr文件</p><p><strong>openssl req -new -key app.key -out app.csr</strong>  <code>之前ca通过x509参数生成的是自签名的证书 而且可以有有效期，这里是生成证书请求文件</code></p><p><img src="https://image.fyxemmmm.cn/blog/images/crt4.png" alt="三项必须一致，且commonName填写服务的名称"></p></li></ol><h2 id="服务端颁发证书"><a href="#服务端颁发证书" class="headerlink" title="服务端颁发证书"></a>服务端颁发证书</h2><p><strong>openssl ca -in /root/app.csr -out certs/app.crt -days 365 app.crt</strong>是别人用私钥生成的证书请求文件，会读取服务端宿主机的配置文件，所以没指定ca的私钥，也不需要的 <code>这就是用服务端的ca自签名</code></p><p><img src="https://image.fyxemmmm.cn/blog/images/crt5.png"></p><p>如果提交的东西都对，就可以y 进行签名了</p><p><img src="https://image.fyxemmmm.cn/blog/images/crt6.png"></p><p>证书申请完毕， 然后发给客户端使用 即可</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>查看证书有效性</p><p><strong>openssl ca -status 0F</strong></p><p>查看证书的有效期</p><p><strong>openssl x509 -in app.crt -noout -dates</strong></p>]]></content>
      
      
      <categories>
          
          <category> 加密与安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 证书 </tag>
            
            <tag> ca </tag>
            
            <tag> 自签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解http协议</title>
      <link href="/2021/08/19/yi-zhang-tu-dai-ni-li-jie-http/"/>
      <url>/2021/08/19/yi-zhang-tu-dai-ni-li-jie-http/</url>
      
        <content type="html"><![CDATA[<h2 id="一张图带你弄懂http协议"><a href="#一张图带你弄懂http协议" class="headerlink" title="一张图带你弄懂http协议"></a>一张图带你弄懂http协议</h2><p><img src="https://image.fyxemmmm.cn/blog/images/http.jpg"></p><blockquote><p>http优化点：<br><strong>初始拥塞窗口(慢启动)</strong> <strong>– 10个MMS，一开始一次性发10个，初始带宽就起来了</strong><br>rto <strong>一来一回，ping一下，这个rto比我们ping的值大一点，是定时器来采样的</strong><br>rto超时 就会重新经历慢启动<br>因为慢启动 tls<br>接收端 16kb收到了之后，openssl才能解压， 2个rtt， 体验很差 –&gt; 所以要使用fastopen<br>广播报文都只支持udp的</p></blockquote><h3 id="http缓存的工作原理"><a href="#http缓存的工作原理" class="headerlink" title="http缓存的工作原理"></a>http缓存的工作原理</h3><p>缓存都有指纹 叫etag或者时间</p><p><strong>然后get发送请求的时候带上etag，服务端判断etag有没有变化，没有变化，就把资源返回304（只有描述信息，节约了带宽）</strong></p><p>请求里带了指纹 if-none-match，包含了文件的长度和修改的时间，做了16进制的编码</p><p>服务器通过指纹比较没问题，又发(etag)回来了，304返回</p><p>No-cache 要和服务端协商一下，得到服务端304可以使用</p><p><img src="https://image.fyxemmmm.cn/blog/images/etag.png" alt="缓存工作原理"></p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬核! 图解 golang [select case] 原理</title>
      <link href="/2021/08/18/ying-he-golang-select-yuan-li/"/>
      <url>/2021/08/18/ying-he-golang-select-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>Go 的select语句是一种仅能用于channl发送和接收消息的专用语句，此语句运行期间是阻塞的；当select中没有case语句的时候，会阻塞当前的groutine。所以，有人也会说select是用来阻塞监听goroutine的。<br> 还有人说：select是Golang在语言层面提供的I/O多路复用的机制，其专门用来检测多个channel是否准备完毕：可读或可写。</p><p>以上说法都正确。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>我们来回顾一下是什么是<code>I/O多路复用</code>。</p><h3 id="普通多线程（或进程）I-O"><a href="#普通多线程（或进程）I-O" class="headerlink" title="普通多线程（或进程）I/O"></a>普通多线程（或进程）I/O</h3><p>每来一个进程，都会建立连接，然后阻塞，直到接收到数据返回响应。<br> 普通这种方式的缺点其实很明显：系统需要创建和维护额外的线程或进程。因为大多数时候，大部分阻塞的线程或进程是处于等待状态，只有少部分会接收并处理响应，而其余的都在等待。系统为此还需要多做很多额外的线程或者进程的管理工作。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select1.webp"></p><p>为了解决图中这些多余的线程或者进程，于是有了”I/O多路复用”</p><h3 id="I-O多路复用-1"><a href="#I-O多路复用-1" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select2.webp"></p><p>每个线程或者进程都先到图中”装置“中注册，然后阻塞，然后只有一个线程在”运输“，当注册的线程或者进程准备好数据后，”装置“会根据注册的信息得到相应的数据。从始至终kernel只会使用图中这个黄黄的线程，无需再对额外的线程或者进程进行管理，提升了效率。</p><h2 id="select组成结构"><a href="#select组成结构" class="headerlink" title="select组成结构"></a>select组成结构</h2><p>select的实现经历了多个版本的修改，当前版本为：1.11<br> select这个语句底层实现实际上主要由两部分组成：<code>case语句</code>和<code>执行函数</code>。<br> 源码地址为：/go/src/runtime/select.go</p><p>每个case语句，单独抽象出以下结构体：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> scase <span class="token keyword">struct</span> <span class="token punctuation">{</span>    c           <span class="token operator">*</span>hchan         <span class="token comment">// chan</span>    elem        unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 读或者写的缓冲区地址</span>    kind        <span class="token builtin">uint16</span>   <span class="token comment">//case语句的类型，是default、传值写数据(channel &lt;-) 还是  取值读数据(&lt;- channel)</span>    pc          <span class="token builtin">uintptr</span> <span class="token comment">// race pc (for race detector / msan)</span>    releasetime <span class="token builtin">int64</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体可以用下图表示：</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select3.webp"></p><p> 其中比较关键的是：<code>hchan</code>，它是channel的指针。<br> 在一个select中，所有的case语句会构成一个<code>scase</code>结构体的数组。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select4.webp"></p><p>然后执行select语句实际上就是调用<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select5.webp"></p><p><code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数参数：</p><ul><li>cas0 为上文提到的case语句抽象出的结构体<code>scase</code>数组的第一个元素地址</li><li>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder。</li><li>nncases表示<code>scase</code>数组的长度</li></ul><p><code>selectgo</code>返回所选scase的索引(该索引与其各自的select {recv，send，default}调用的序号位置相匹配)。此外，如果选择的scase是接收操作(recv)，则返回是否接收到值。</p><p>谁负责调用<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数呢？</p><p>在<code>/reflect/value.go</code>中有个<code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code>函数，此函数的实现在<code>/runtime/select.go</code>文件中的<code>func reflect_rselect(cases []runtimeSelect) (int, bool)</code>函数中:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">reflect_rselect</span><span class="token punctuation">(</span>cases <span class="token punctuation">[</span><span class="token punctuation">]</span>runtimeSelect<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">//如果cases语句为空，则阻塞当前groutine</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">//实例化case的结构体</span>    sel <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>scase<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span><span class="token punctuation">)</span>    order <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> cases <span class="token punctuation">{</span>        rc <span class="token operator">:=</span> <span class="token operator">&amp;</span>cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">switch</span> rc<span class="token punctuation">.</span>dir <span class="token punctuation">{</span>        <span class="token keyword">case</span> selectDefault<span class="token punctuation">:</span>            sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scase<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> caseDefault<span class="token punctuation">}</span>        <span class="token keyword">case</span> selectSend<span class="token punctuation">:</span>            sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scase<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> caseSend<span class="token punctuation">,</span> c<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>val<span class="token punctuation">}</span>        <span class="token keyword">case</span> selectRecv<span class="token punctuation">:</span>            sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scase<span class="token punctuation">{</span>kind<span class="token punctuation">:</span> caseRecv<span class="token punctuation">,</span> c<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> elem<span class="token punctuation">:</span> rc<span class="token punctuation">.</span>val<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> raceenabled <span class="token operator">||</span> msanenabled <span class="token punctuation">{</span>            <span class="token function">selectsetpc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sel<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">selectgo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sel<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>order<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>cases<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那谁调用的<code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code>呢？<br> 在<code>/refect/value.go</code>中，有一个<code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code>的函数，其调用了<code>rselect</code>函数，并将最终Go中select语句的返回值的返回。</p><p>以上这三个函数的调用栈按顺序如下：</p><ul><li><code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code></li><li><code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code></li><li><code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code></li></ul><p>这仨函数中无论是返回值还是参数都大同小异，可以简单粗暴的认为：函数参数传入的是case语句，返回值返回被选中的case语句。<br> 那谁调用了<code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code>呢？<br> 可以简单的认为是系统了。<br> 来个简单的图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select6.webp"></p><p>前两个函数<code>Select</code>和<code>rselect</code>都是做了简单的初始化参数，调用下一个函数的操作。select真正的核心功能，是在最后一个函数<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>中实现的。</p><h3 id="selectgo函数做了什么"><a href="#selectgo函数做了什么" class="headerlink" title="selectgo函数做了什么"></a>selectgo函数做了什么</h3><p>打乱传入的case结构体顺序</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select7.webp"></p><p>锁住其中的所有的channel</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select8.webp"></p><p>遍历所有的channel，查看其是否可读或者可写</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select9.webp"></p><p>如果其中的channel可读或者可写，则解锁所有channel，并返回对应的channel数据</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select10.webp"></p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select11.webp"></p><p>假如没有channel可读或者可写，但是有default语句，则同上:返回default语句对应的scase并解锁所有的channel。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select11.webp"></p><p>假如既没有channel可读或者可写，也没有default语句，则将当前运行的groutine阻塞，并加入到当前所有channel的等待队列中去。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select12.webp"></p><p>然后解锁所有channel，等待被唤醒。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select13.webp"></p><p>此时如果有个channel可读或者可写ready了，则唤醒，并再次加锁所有channel，</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select14.webp"></p><p>遍历所有channel找到那个对应的channel和G，唤醒G，并将没有成功的G从所有channel的等待队列中移除。</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select15.webp"></p><p>如果对应的scase值不为空，则返回需要的值，并解锁所有channel</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select16.webp"></p><p>如果对应的scase为空，则循环此过程。</p><h3 id="select和channel之间的关系"><a href="#select和channel之间的关系" class="headerlink" title="select和channel之间的关系"></a>select和channel之间的关系</h3><p>在想想select和channel做了什么事儿，我觉得和多路复用是一回事儿</p><p><img src="https://image.fyxemmmm.cn/blog/images/%E8%B5%84%E6%BA%90/select17.webp"></p><blockquote><p>select 语法是配套于 channel 一起用的语法，核心点是实现了 IO 多路复用的原理，能够在应用层去监听多个 channel 是否已经准备就绪。</p></blockquote><h2 id="小结-select-case："><a href="#小结-select-case：" class="headerlink" title="小结 select case："></a>小结 select case：</h2><blockquote><p>把 select 里面每个 case 在编译后转成 scase 结构体<br>先用 runtime.fastrandn 打乱全部 case 的初始顺序<br>调用 select go 方法逐个锁住 channel 们。去遍历是否有就绪的 channel，有的话则命中其中一个就绪 channel。如果没有就绪的 channel 就会走 default 逻辑，若 default 逻辑都没有就会先解锁所有 channel，让 select 对应的协程就会 gopark 进行休眠，等待 channel 就绪的通知。当有 channel 就绪就会唤醒，重新走刚开始的步骤，命中其中一个就绪 channel</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka原理分析</title>
      <link href="/2021/08/17/kafka/"/>
      <url>/2021/08/17/kafka/</url>
      
        <content type="html"><![CDATA[<p><strong>Kafka痛点分析&amp;核心目标</strong></p><p>当Kafka支撑的实时作业数量很多，单机承载的Topic和Partition数量很大。这种场景下很容易出现的问题是：同一台机器上不同Partition间竞争PageCache资源，相互影响，导致整个Broker的处理延迟上升、吞吐下降。</p><p><img src="https://image.fyxemmmm.cn/blog/images/kafka.png" alt="Kafka处理读写流程的示意图"></p><p><strong>对于Produce请求</strong>：Server端的I/O线程统一将请求中的数据写入到操作系统的PageCache后立即返回，当消息条数到达一定阈值后，Kafka应用本身或操作系统内核会触发强制刷盘操作（如左侧流程图所示）。</p><p><strong>对于Consume请求</strong>：主要利用了操作系统的ZeroCopy机制，当Kafka Broker接收到读数据请求时，会向操作系统发送sendfile系统调用，操作系统接收后，首先试图从PageCache中获取数据（如中间流程图所示）；如果数据不存在，会触发缺页异常中断将数据从磁盘读入到临时缓冲区中（如右侧流程图所示），随后通过DMA操作直接将数据拷贝到网卡缓冲区中等待后续的TCP传输。</p><p>综上所述，Kafka对于单一读写请求均拥有很好的吞吐和延迟。处理写请求时，数据写入PageCache后立即返回，数据通过异步方式批量刷入磁盘，既保证了多数写请求都能有较低的延迟，同时批量顺序刷盘对磁盘更加友好。处理读请求时，实时消费的作业可以直接从PageCache读取到数据，请求延迟较小，同时ZeroCopy机制能够减少数据传输过程中用户态与内核态的切换，大幅提升了数据传输的效率。</p><p>但当同一个Broker上同时存在多个Consumer时，就可能会由于多个Consumer竞争PageCache资源导致它们同时产生延迟。下面我们以两个Consumer为例详细说明：</p><p><img src="https://image.fyxemmmm.cn/blog/images/kafka2.png"></p><p>如上图所示，Producer将数据发送到Broker，PageCache会缓存这部分数据。当所有Consumer的消费能力充足时，所有的数据都会从PageCache读取，全部Consumer实例的延迟都较低。此时如果其中一个Consumer出现消费延迟（图中的Consumer Process2），根据读请求处理流程可知，此时会触发磁盘读取，在从磁盘读取数据的同时会预读部分数据到PageCache中。当PageCache空间不足时，会按照LRU策略开始淘汰数据，此时延迟消费的Consumer读取到的数据会替换PageCache中实时的缓存数据。后续当实时消费请求到达时，由于PageCache中的数据已被替换掉，会产生预期外的磁盘读取。这样会导致两个后果：</p><ol><li><strong>消费能力充足的Consumer消费时会失去PageCache的性能红利。</strong></li><li><strong>多个Consumer相互影响，预期外的磁盘读增多，HDD负载升高。</strong></li></ol><p><strong>数据分析</strong></p><p>如果Kafka集群TP99流量在170MB/s，TP95流量在100MB/s，TP50流量为50-60MB/s；单机的PageCache平均分配为80GB，取TP99的流量作为参考，在此流量以及PageCache分配情况下，PageCache最大可缓存数据时间跨度为80*1024/170/60 = 8min，可见当前Kafka服务整体对延迟消费作业的容忍性极低。该情况下，一旦部分作业消费延迟，实时消费作业就可能会受到影响。</p><p><strong>痛点分析总结</strong></p><p>总结上述的原理分析以及数据统计，目前Kafka存在如下问题：</p><ol><li>实时消费与延迟消费的作业在PageCache层次产生竞争，导致实时消费产生非预期磁盘读。</li><li>传统HDD随着读并发升高性能急剧下降。</li><li>存在20%的延迟消费作业。</li></ol><p>按目前的PageCache空间分配以及集群流量分析，Kafka无法对实时消费作业提供稳定的服务质量保障，该痛点亟待解决。</p><p><strong>预期目标</strong></p><p>根据上述痛点分析，我们的预期目标为保证实时消费作业不会由于PageCache竞争而被延迟消费作业影响，保证Kafka对实时消费作业提供稳定的服务质量保障。</p><p><strong>解决方案</strong></p><p><strong>可以选择使用SSD</strong></p><p>根据上述原因分析可知，解决目前痛点可从以下两个方向来考虑：</p><ol><li>消除实时消费与延迟消费间的PageCache竞争，如：让延迟消费作业读取的数据不回写PageCache，或增大PageCache的分配量等。</li><li>在HDD与内存之间加入新的设备，该设备拥有比HDD更好的读写带宽与IOPS。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 tcp timewait</title>
      <link href="/2021/08/17/tcp-timewait/"/>
      <url>/2021/08/17/tcp-timewait/</url>
      
        <content type="html"><![CDATA[<p><strong>你遇到过TIME_WAIT的问题吗？</strong></p><p>我相信很多都遇到过这个问题。一旦有用户在喊：网络变慢了。第一件事情就是，netstat -a | grep TIME_WAIT | wc -l 一下，哎呀妈呀，几千个TIME_WAIT。</p><p>然后，做的第一件事情就是：打开Google或者Bing，输入关键词：too many time wait。一定能找到解决方案，而排在最前面或者被很多人到处转载的解决方案一定是：</p><blockquote><p>打开 sysctl.conf 文件，修改以下几个参数：</p><p>net.ipv4.tcp_tw_recycle = 1</p><p>net.ipv4.tcp_tw_reuse = 1</p><p>net.ipv4.tcp_timestamps = 1</p></blockquote><p>你也会被告知，开启tw_recylce和tw_reuse一定需要timestamps的支持，而且这些配置一般不建议开启，但是对解决TIME_WAIT很多的问题，有很好的用处。</p><p>接下来，你就直接修改了这几个参数，reload一下，发现，咦，没几分钟，TIME_WAIT的数量真的降低了，也没发现哪个用户说有问题，然后就没有然后了。</p><p>做到这一步，相信50%或者更高比例的开发就已经止步了。问题好像解决了，但是，要彻底理解并解决这个问题，可能就没这么简单，或者说，还有很长的路要走！</p><p><strong>什么是TIME-WAIT和CLOSE-WAIT?</strong></p><p>所谓，要解决问题，就要先理解问题。随便改两行代码，发现bug“没有了”，也不是bug真的没有了，只是隐藏在更深的地方，你没有发现，或者以你的知识水平，你无法发现而已。</p><p>大家知道，由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。</p><ul><li>主动关闭连接的一方，调用close()；<strong>协议层发送FIN包</strong></li><li><strong>被动关闭的一方收到FIN包后，协议层回复ACK</strong>；然后<strong>被动关闭的一方，进入CLOSE_WAIT状态，</strong>主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作</li><li>被动关闭的一方在完成所有数据发送后，调用close()操作；此时，<strong>协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态</strong>；</li><li><strong>主动关闭的一方收到FIN包，协议层回复ACK</strong>；此时，<strong>主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态</strong></li><li>等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态</li></ul><p>通过上面的一次socket关闭操作，你可以得出以下几点：</p><ol><li>主动关闭连接的一方 - 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态</li><li>被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接</li><li>TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；</li><li>在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！</li></ol><p>所以，这里凭你的直觉，TIME_WAIT并不可怕（not really，后面讲），CLOSE_WAIT才可怕，因为CLOSE_WAIT很多，表示说要么是你的应用程序写的有问题，没有合适的关闭socket；要么是说，你的服务器CPU处理不过来（CPU太忙）或者你的应用程序一直睡眠到其它地方(锁，或者文件I/O等等)，你的应用程序获得不到合适的调度时间，造成你的程序没法真正的执行close操作。</p><p>这里又出现两个问题：</p><ol><li>上文提到的连接重用，那连接到底是个什么概念？</li><li>协议层为什么要设计一个TIME_WAIT状态？这个状态为什么默认等待2MSL时间才会进入CLOSED</li></ol><p>先解释清楚这两个问题，我们再来看，开头提到的几个网络配置究竟有什么用，以及TIME_WAIT的后遗症问题。</p><p><strong>Socket连接到底是个什么概念？</strong></p><p>大家经常提socket，那么，到底什么是一个socket？其实，socket就是一个 五元组，包括：</p><ol><li>源IP</li><li>源端口</li><li>目的IP</li><li>目的端口</li><li>类型：TCP or UDP</li></ol><p>这个五元组，即标识了一条可用的连接。注意，有很多人把一个socket定义成四元组，也就是 源IP:源端口 + 目的IP:目的端口，这个定义是不正确的。</p><p>例如，如果你的本地出口IP是180.172.35.150，那么你的浏览器在连接某一个Web服务器，例如百度的时候，这条socket连接的四元组可能就是：</p><blockquote><p>[180.172.35.150:45678, tcp, 180.97.33.108:80]</p></blockquote><p>源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口。</p><p>如果这个时候，你再开一个浏览器，访问百度，将会产生一条新的连接：</p><blockquote><p>[180.172.35.150:43678, tcp, 180.97.33.108:80]</p></blockquote><p>这条新的连接的源端口为一个新的随机端口 43678。</p><p>如此来看，如果你的本机需要压测百度，那么，你最多可以创建多少个连接呢？</p><p><strong>第二个问题，TIME_WAIT有什么用？</strong></p><p>如果我们来做个类比的话，TIME_WAIT的出现，对应的是你的程序里的异常处理，它的出现，就是为了解决网络的丢包和网络不稳定所带来的其他问题：</p><p>第一，防止前一个连接【五元组，我们继续以 180.172.35.150:45678, tcp, 180.97.33.108:80 为例】上延迟的数据包或者丢失重传的数据包，被后面复用的连接【前一个连接关闭后，此时你再次访问百度，新的连接可能还是由180.172.35.150:45678, tcp, 180.97.33.108:80 这个五元组来表示，也就是源端口凑巧还是45678】错误的接收（异常：数据丢了，或者传输太慢了），参见下图：</p><ul><li>SEQ=3的数据包丢失，重传第一次，没有得到ACK确认</li><li>如果没有TIME_WAIT，或者TIME_WAIT时间非常端，那么关闭的连接【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】，马上被重用【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】，并连续发送SEQ=1,2 的数据包</li><li>此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收</li></ul><p>第二，确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的，参见下图：</p><p><img src="https://image.fyxemmmm.cn/blog/images/img1.webp"><br><img src="https://image.fyxemmmm.cn/blog/images/tw-1.png"><br><img src="https://image.fyxemmmm.cn/blog/images/tw-2.png"></p><ul><li>主动关闭方关闭了连接，发送了FIN；</li><li>被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态</li><li>主动关闭的一方回去了ACK，主动关闭一方进入TIME_WAIT状态；</li><li>但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态</li><li>此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST</li><li>造成主动创建连接的一方，由于收到了RST，则连接无法成功</li></ul><p>所以，你看到了，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成数据粗乱，或者短暂性的连接失败。</p><p>那么，为什么说，TIME_WAIT状态会是持续2MSL（2倍的max segment lifetime）呢？这个时间可以通过修改内核参数调整吗？第一，这个2MSL，是RFC 793里定义的，参见RFC的截图标红的部分：</p><p><img src="https://image.fyxemmmm.cn/blog/images/img2.webp"></p><p>这个定义，更多的是一种保障（IP数据包里的TTL，即数据最多存活的跳数，真正反应的才是数据在网络上的存活时间），确保最后丢失了ACK，被动关闭的一方再次重发FIN并等待回复的ACK，一来一去两个来回。内核里，写死了这个MSL的时间为：30秒（有读者提醒，RFC里建议的MSL其实是2分钟，但是很多实现都是30秒），所以TIME_WAIT的即为1分钟：</p><p>所以，再次回想一下前面的问题，如果一条连接，即使在四次握手关闭了，由于TIME_WAIT的存在，这个连接，在1分钟之内，也无法再次被复用，那么，如果你用一台机器做压测的客户端，你一分钟能发送多少并发连接请求？如果这台是一个负载均衡服务器，一台负载均衡服务器，一分钟可以有多少个连接同时访问后端的服务器呢？</p><p><strong>TIME_WAIT很多，可怕吗？</strong></p><p>如果你通过 ss -tan state time-wait | wc -l 发现，系统中有很多TIME_WAIT，很多人都会紧张。多少算多呢？几百几千？如果是这个量级，其实真的没必要紧张。第一，这个量级，因为TIME_WAIT所占用的内存很少很少；因为记录和寻找可用的local port所消耗的CPU也基本可以忽略。</p><p><strong>会占用内存吗？当然</strong>！任何你可以看到的数据，内核里都需要有相关的数据结构来保存这个数据啊。一条Socket处于TIME_WAIT状态，它也是一条“存在”的socket，内核里也需要有保持它的数据：</p><ol><li><p>内核里有保存所有连接的一个hash table，这个hash table里面既包含TIME_WAIT状态的连接，也包含其他状态的连接。主要用于有新的数据到来的时候，从这个hash table里快速找到这条连接。不同的内核对这个hash table的大小设置不同，你可以通过dmesg命令去找到你的内核设置的大小：</p></li><li><p>还有一个hash table用来保存所有的bound ports，主要用于可以快速的找到一个可用的端口或者随机端口：</p></li></ol><p>由于内核需要保存这些数据，必然，会占用一定的内存。</p><p><strong>会消耗CPU吗？</strong>当然！每次找到一个随机端口，还是需要遍历一遍bound ports的吧，这必然需要一些CPU时间。</p><p>TIME_WAIT很多，既占内存又消耗CPU，这也是为什么很多人，看到TIME_WAIT很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1万条TIME_WAIT的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于CPU，能减少它当然更好，但是不至于因为1万多个hash item就担忧。</p><p>如果，你真的想去调优，还是需要搞清楚别人的调优建议，以及调优参数背后的意义！</p><p><strong>TIME_WAIT调优，你必须理解的几个调优参数</strong></p><p>在具体的图例之前，我们还是先解析一下相关的几个参数存在的意义。</p><ol><li><p><strong>net.ipv4.tcp_timestamps</strong></p><p>RFC 1323 在 TCP Reliability一节里，引入了timestamp的TCP option，两个4字节的时间戳字段，其中第一个4字节字段用来保存发送该数据包的时间，第二个4字节字段用来保存最近一次接收对方发送到数据的时间。有了这两个时间字段，也就有了后续优化的余地。</p><p>tcp_tw_reuse 和 tcp_tw_recycle就依赖这些时间字段。</p></li><li><p><strong>net.ipv4.tcp_tw_reuse</strong></p><p>字面意思，reuse TIME_WAIT状态的连接。</p><p>时刻记住一条socket连接，就是那个五元组，出现TIME_WAIT状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的HTTP请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用TIME_WAIT状态的连接。</p><p>通过字面解释，以及例子说明，你看到了，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接”连接其他服务器，总是自己先关闭连接(TIME_WAIT在自己这方)，关闭后又不断的重新连接对方。</p><p>那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。</p><p>这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用TIME_WAIT的socket。</p></li><li><p><strong>net.ipv4.tcp_tw_recycle</strong></p><p>字面意思，销毁掉 TIME_WAIT。</p><p>当开启了这个配置后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。</p><p>有了这个配置，还是需要保障 丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于TIME_WAIT状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入TIME_WAIT状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。</p><p>这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，TIME_WAIT状态的socket处于服务端，服务端快速的回收该状态的连接。</p></li></ol><p>由此，如果客户端处于NAT的网络(多个客户端，同一个IP出口的网络环境)，如果配置了tw_recycle，就可能在一个RTO的时间内，只能有一个客户端和自己连接成功(不同的客户端发包的时间不一致，造成服务端直接把数据包丢弃掉)。</p><p>我尽量尝试用文字解释清楚，但是，来点案例和图示，应该有助于我们彻底理解。</p><p>我们来看这样一个网络情况：</p><ol><li>客户端IP地址为：180.172.35.150，我们可以认为是浏览器</li><li>负载均衡有两个IP，外网IP地址为 115.29.253.156，内网地址为10.162.74.10；外网地址监听80端口</li><li>负载均衡背后有两台Web服务器，一台IP地址为 10.162.74.43，监听80端口；另一台为 10.162.74.44，监听 80 端口</li><li>Web服务器会连接数据服务器，IP地址为 10.162.74.45，监听 3306 端口</li></ol><p>这种简单的架构下，我们来看看，在不同的情况下，我们今天谈论的tw_reuse/tw_recycle对网络连接的影响。</p><p>先做个假定：</p><ol><li>客户端通过HTTP/1.1连接负载均衡，也就是说，HTTP协议投Connection为keep-alive，所以我们假定，客户端 对 负载均衡服务器 的socket连接，客户端会断开连接，所以，TIME_WAIT出现在客户端</li><li>Web服务器和MySQL服务器的连接，我们假定，Web服务器上的程序在连接结束的时候，调用close操作关闭socket资源连接，所以，TIME_WAIT出现在 Web 服务器端。</li></ol><p>那么，在这种假定下：</p><ol><li>Web服务器上，肯定可以配置开启的配置：tcp_tw_reuse；如果Web服务器有很多连向DB服务器的连接，可以保证socket连接的复用。</li><li>那么，负载均衡服务器和Web服务器，谁先关闭连接，则决定了我们怎么配置tcp_tw_reuse/tcp_tw_recycle了</li></ol><p><strong>场景一：负载均衡服务器首先关闭连接</strong> </p><p>在这种情况下，因为负载均衡服务器对Web服务器的连接，TIME_WAIT大都出现在负载均衡服务器上。</p><p>在负载均衡服务器上的配置：</p><ul><li>net.ipv4.tcp_tw_reuse = 1 //尽量复用连接</li><li>net.ipv4.tcp_tw_recycle = 0 //不能保证客户端不在NAT的网络啊</li></ul><p>在Web服务器上的配置为：</p><ul><li>net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用</li><li>net.ipv4.tcp_tw_recycle： 设置成1和0都没有任何意义。想一想，在负载均衡和它的连接中，它是服务端，但是TIME_WAIT出现在负载均衡服务器上；它和DB的连接，它是客户端，recycle对它并没有什么影响，关键是reuse</li></ul><p><strong>场景二：Web服务器首先关闭来自负载均衡服务器的连接</strong></p><p>在这种情况下，Web服务器变成TIME_WAIT的重灾区。负载均衡对Web服务器的连接，由Web服务器首先关闭连接，TIME_WAIT出现在Web服务器上；Web服务器对DB服务器的连接，由Web服务器关闭连接，TIME_WAIT也出现在它身上，此时，负载均衡服务器上的配置：</p><ul><li>net.ipv4.tcp_tw_reuse：0 或者 1 都行，都没有实际意义</li><li>net.ipv4.tcp_tw_recycle=0 //一定是关闭recycle</li></ul><p>在Web服务器上的配置：</p><ul><li>net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用</li><li>net.ipv4.tcp_tw_recycle=1 //由于在负载均衡和Web服务器之间并没有NAT的网络，可以考虑开启recycle，加速由于负载均衡和Web服务器之间的连接造成的大量TIME_WAIT</li></ul>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes高可用集群搭建</title>
      <link href="/2021/08/16/k8s-install/"/>
      <url>/2021/08/16/k8s-install/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-高可用集群搭建"><a href="#k8s-高可用集群搭建" class="headerlink" title="k8s 高可用集群搭建"></a>k8s 高可用集群搭建</h1><p><code>docker的安装自行搞定即可, 尽量不要用太高版本到version.19即可</code></p><p><strong>本文基于centos的操作系统，kubeadm来作为搭建方式</strong></p><ol><li><p>新建yum源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFsudo yum makecachesudo yum -y install kubelet-1.20.2  kubeadm-1.20.2  kubectl-1.20.2sudo systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用systemd作为docker的cgroup driver</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo vi  /etc/docker/daemon.json   （没有则创建）加入{  "exec-opts": ["native.cgroupdriver=systemd"]}systemctl daemon-reload  &amp;&amp; systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>切换到root用户执行 <strong>关键步骤</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># （如果是重置机器，需要执行）kubeadm resetrm /etc/cni/net.d -friptables -F yum -y remove kubelet-1.18.6  kubeadm-1.18.6  kubectl-1.18.6# （重置end）yum -y install kubelet-1.20.2  kubeadm-1.20.2  kubectl-1.20.2echo 1 &gt; /proc/sys/net/ipv4/ip_forwardmodprobe br_netfilterecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptablessystemctl daemon-reload  # 可能会报错 可以不执行这个systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>master节点执行以下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#主机执行：kubeadm init --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers  --kubernetes-version=1.20.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>得到token之后给worker依次执行， 加入到集群当中去， <code>初步就完成了集群的搭建</code> <strong>还差一个网络插件</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#得到token后，给另外worker去执行kubeadm join 192.168.0.191:6443 --token zx5rj1.19yqkv7q2uehatit \--discovery-token-ca-cert-hash sha256:b5a066c56e73896dc14530d5464eadd45732de6bd3806e878c80ed589e4ea502<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>给节点做一些完善工作</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#然后退出到普通用户, 用kubectl命令执行#去除主节点污点kubectl taint nodes --all node-role.kubernetes.io/master-   # (后面一个 – 是需要的)给工作节点打标签kubectl label node huawei-worker  node-role.kubernetes.io/node=node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们需要让外网也可以访问， <strong>也就是通过kubectl客户端工具能连接主机的外部ip地址，需要做此工作</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#让外网可以访问#先删除 apiserver的证书和key#主节点上cd /etc/kubernetes/pki &amp;&amp; rm -f apiserver.key &amp;&amp; rm -f  apiserver.crtsudo kubeadm init phase certs apiserver   --apiserver-cert-extra-sans 121.36.226.197kubeadm alpha certs renew apiserver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装网络插件， <strong>这里我们选择flannel</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://github.com/flannel-io/flannelFor Kubernetes v1.17+ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# apply里面的镜像要替换下，可以用katacoda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="大功告成啦-可以愉快的玩耍了！"><a href="#大功告成啦-可以愉快的玩耍了！" class="headerlink" title="大功告成啦~   可以愉快的玩耍了！"></a>大功告成啦~   可以愉快的玩耍了！</h3>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang context 实现原理</title>
      <link href="/2021/08/14/context-shi-xian-yuan-li/"/>
      <url>/2021/08/14/context-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p>本文主要谈谈以下几个方面的内容：</p><ol><li>context的使用。</li><li>context实现原理，哪些是需要注意的地方</li><li>context的最佳实践。</li></ol><p><code>context</code>是Go中广泛使用的程序包，由Google官方开发，在1.7版本引入。它用来简化在多个go routine传递上下文数据、(手动/超时)中止routine树等操作，比如，官方http包使用context传递请求的上下文数据，gRpc使用context来终止某个请求产生的routine树。由于它使用简单，现在基本成了编写go基础库的通用规范。笔者在使用context上有一些经验，遂分享下。</p><p>本文主要谈谈以下几个方面的内容：</p><ol><li>context的使用。</li><li>context实现原理，哪些是需要注意的地方。</li><li>在实践中遇到的问题，分析问题产生的原因。</li></ol><h2 id="1-使用"><a href="#1-使用" class="headerlink" title="1 使用"></a>1 使用</h2><h3 id="核心接口Context"><a href="#核心接口Context" class="headerlink" title="核心接口Context"></a>核心接口Context</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token comment">// Deadline returns the time when work done on behalf of this context</span>    <span class="token comment">// should be canceled. Deadline returns ok==false when no deadline is</span>    <span class="token comment">// set.</span>    <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token comment">// Done returns a channel that's closed when work done on behalf of this</span>    <span class="token comment">// context should be canceled.</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// Err returns a non-nil error value after Done is closed.</span>    <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>    <span class="token comment">// Value returns the value associated with this context for key.</span>    <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单介绍一下其中的方法：<br>- <code>Done</code>会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回。<br>- <code>Context</code>中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问。<br>- <code>Deadline</code>会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间。<br>- <code>Value</code>可以让routine共享一些数据，当然获得数据是协程安全的。</p><p>在请求处理的过程中，会调用各层的函数，每层的函数会创建自己的routine，是一个routine树。所以，context也应该反映并实现成一棵树。</p><p>要创建context树，第一步是要有一个根结点。<code>context.Background</code>函数的返回值是一个空的context，经常作为树的根结点，它一般由接收请求的第一个routine创建，不能被取消、没有值、也没有过期时间。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后该怎么创建其它的子孙节点呢？context包为我们提供了以下函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这四个函数的第一个参数都是父context，返回一个Context类型的值，这样就层层创建出不同的节点。子节点是从复制父节点得到的，并且根据接收的函数参数保存子节点的一些状态值，然后就可以将它传递给下层的routine了。</p><p><code>WithCancel</code>函数，返回一个额外的CancelFunc函数类型变量，该函数类型的定义为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> CancelFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用CancelFunc对象将撤销对应的Context对象，这样父结点的所在的环境中，获得了撤销子节点context的权利，当触发某些条件时，可以调用CancelFunc对象来终止子结点树的所有routine。在子节点的routine中，需要用类似下面的代码来判断何时退出routine：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>cxt<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">// do some cleaning and return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据cxt.Done()判断是否结束。当顶层的Request请求处理结束，或者外部取消了这次请求，就可以cancel掉顶层context，从而使整个请求的routine树得以退出。</p><p><code>WithDeadline</code>和<code>WithTimeout</code>比<code>WithCancel</code>多了一个时间参数，它指示context存活的最长时间。如果超过了过期时间，会自动撤销它的子context。所以context的生命期是由父context的routine和<code>deadline</code>共同决定的。</p><p><code>WithValue</code>返回parent的一个副本，该副本保存了传入的key/value，而调用Context接口的Value(key)方法就可以得到val。注意在同一个context中设置key/value，若key相同，值会被覆盖。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h2><h2 id="2-1-上下文数据的存储与查询"><a href="#2-1-上下文数据的存储与查询" class="headerlink" title="2.1 上下文数据的存储与查询"></a>2.1 上下文数据的存储与查询</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil key"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>valueCtx<span class="token punctuation">{</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>key <span class="token operator">==</span> key <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span>val    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>context上下文数据的存储就像一个树，每个结点只存储一个key/value对。<code>WithValue()</code>保存一个key/value对，它将父context嵌入到新的子context，并在节点中保存了key/value数据。<code>Value()</code>查询key对应的value数据，会从当前context中查询，如果查不到，会递归查询父context中的数据。</p><p>值得注意的是，<strong>context中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据。</strong></p><h2 id="2-2-手动cancel和超时cancel"><a href="#2-2-手动cancel和超时cancel" class="headerlink" title="2.2 手动cancel和超时cancel"></a>2.2 手动cancel和超时cancel</h2><p><code>cancelCtx</code>中嵌入了父Context，实现了canceler接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context      <span class="token comment">// 保存parent Context</span>    done <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    mu       sync<span class="token punctuation">.</span>Mutex    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    err      <span class="token builtin">error</span><span class="token punctuation">}</span><span class="token comment">// A canceler is a context type that can be canceled directly. The</span><span class="token comment">// implementations are *cancelCtx and *timerCtx.</span><span class="token keyword">type</span> canceler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cancelCtx</code>结构体中<code>children</code>保存它的所有<code>子canceler</code>， 当外部触发cancel时，会调用<code>children</code>中的所有<code>cancel()</code>来终止所有的<code>cancelCtx</code>。<code>done</code>用来标识是否已被cancel。当外部触发cancel、或者父Context的channel关闭时，此done也会关闭。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timerCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    cancelCtx     <span class="token comment">//cancelCtx.Done()关闭的时机：1）用户调用cancel 2）deadline到了 3）父Context的done关闭了</span>    timer    <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer    deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    c <span class="token operator">:=</span> <span class="token operator">&amp;</span>timerCtx<span class="token punctuation">{</span>        cancelCtx<span class="token punctuation">:</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>        deadline<span class="token punctuation">:</span>  deadline<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    d <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span>    <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span> <span class="token comment">// deadline has already passed</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>timerCtx</code>结构体中<code>deadline</code>保存了超时的时间，当超过这个时间，会触发<code>cancel</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/ctx1.jpg"></p><p>可以看出，<strong>cancelCtx也是一棵树，当触发cancel时，会cancel本结点和其子树的所有cancelCtx</strong>。</p><h2 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h2><p>由于go大量的官方库、第三方库使用了context，所以调用<code>接收context的函数</code>时要小心，要清楚context在什么时候cancel，什么行为会触发cancel。笔者在程序经常使用gRpc传出来的context，产生了一些非预期的结果，之后花时间总结了gRpc、内部基础库中context的生命期及行为，以避免出现同样的问题。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> context </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
