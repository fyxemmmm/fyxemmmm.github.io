<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes高可用集群搭建</title>
      <link href="/2021/08/16/k8s-install/"/>
      <url>/2021/08/16/k8s-install/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-高可用集群搭建"><a href="#k8s-高可用集群搭建" class="headerlink" title="k8s 高可用集群搭建"></a>k8s 高可用集群搭建</h1><p><code>docker的安装自行搞定即可, 尽量不要用太高版本到version.19即可</code></p><p><strong>本文基于centos的操作系统，kubeadm来作为搭建方式</strong></p><ol><li><p>新建yum源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFsudo yum makecachesudo yum -y install kubelet-1.20.2  kubeadm-1.20.2  kubectl-1.20.2sudo systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用systemd作为docker的cgroup driver</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo vi  /etc/docker/daemon.json   （没有则创建）加入{  "exec-opts": ["native.cgroupdriver=systemd"]}systemctl daemon-reload  &amp;&amp; systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>切换到root用户执行 <strong>关键步骤</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># （如果是重置机器，需要执行）kubeadm resetrm /etc/cni/net.d -friptables -F yum -y remove kubelet-1.18.6  kubeadm-1.18.6  kubectl-1.18.6# （重置end）yum -y install kubelet-1.20.2  kubeadm-1.20.2  kubectl-1.20.2echo 1 &gt; /proc/sys/net/ipv4/ip_forwardmodprobe br_netfilterecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptablessystemctl daemon-reload  # 可能会报错 可以不执行这个systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>master节点执行以下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#主机执行：kubeadm init --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers  --kubernetes-version=1.20.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>得到token之后给worker依次执行， 加入到集群当中去， <code>初步就完成了集群的搭建</code> <strong>还差一个网络插件</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#得到token后，给另外worker去执行kubeadm join 192.168.0.191:6443 --token zx5rj1.19yqkv7q2uehatit \--discovery-token-ca-cert-hash sha256:b5a066c56e73896dc14530d5464eadd45732de6bd3806e878c80ed589e4ea502<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>给节点做一些完善工作</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#然后退出到普通用户, 用kubectl命令执行#去除主节点污点kubectl taint nodes --all node-role.kubernetes.io/master-   # (后面一个 – 是需要的)给工作节点打标签kubectl label node huawei-worker  node-role.kubernetes.io/node=node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们需要让外网也可以访问， <strong>也就是通过kubectl客户端工具能连接主机的外部ip地址，需要做此工作</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#让外网可以访问#先删除 apiserver的证书和key#主节点上cd /etc/kubernetes/pki &amp;&amp; rm -f apiserver.key &amp;&amp; rm -f  apiserver.crtsudo kubeadm init phase certs apiserver   --apiserver-cert-extra-sans 121.36.226.197kubeadm alpha certs renew apiserver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装网络插件， <strong>这里我们选择flannel</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://github.com/flannel-io/flannelFor Kubernetes v1.17+ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# apply里面的镜像要替换下，可以用katacoda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="大功告成啦-可以愉快的玩耍了！"><a href="#大功告成啦-可以愉快的玩耍了！" class="headerlink" title="大功告成啦~   可以愉快的玩耍了！"></a>大功告成啦~   可以愉快的玩耍了！</h3>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang context实现原理</title>
      <link href="/2021/08/14/post-title-with-whitespace-copy/"/>
      <url>/2021/08/14/post-title-with-whitespace-copy/</url>
      
        <content type="html"><![CDATA[<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p>本文主要谈谈以下几个方面的内容：</p><ol><li>context的使用。</li><li>context实现原理，哪些是需要注意的地方</li><li>context的最佳实践。</li></ol><p><code>context</code>是Go中广泛使用的程序包，由Google官方开发，在1.7版本引入。它用来简化在多个go routine传递上下文数据、(手动/超时)中止routine树等操作，比如，官方http包使用context传递请求的上下文数据，gRpc使用context来终止某个请求产生的routine树。由于它使用简单，现在基本成了编写go基础库的通用规范。笔者在使用context上有一些经验，遂分享下。</p><p>本文主要谈谈以下几个方面的内容：</p><ol><li>context的使用。</li><li>context实现原理，哪些是需要注意的地方。</li><li>在实践中遇到的问题，分析问题产生的原因。</li></ol><h2 id="1-使用"><a href="#1-使用" class="headerlink" title="1 使用"></a>1 使用</h2><h3 id="核心接口Context"><a href="#核心接口Context" class="headerlink" title="核心接口Context"></a>核心接口Context</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token comment">// Deadline returns the time when work done on behalf of this context</span>    <span class="token comment">// should be canceled. Deadline returns ok==false when no deadline is</span>    <span class="token comment">// set.</span>    <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token comment">// Done returns a channel that's closed when work done on behalf of this</span>    <span class="token comment">// context should be canceled.</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// Err returns a non-nil error value after Done is closed.</span>    <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>    <span class="token comment">// Value returns the value associated with this context for key.</span>    <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单介绍一下其中的方法：<br>- <code>Done</code>会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回。<br>- <code>Context</code>中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问。<br>- <code>Deadline</code>会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间。<br>- <code>Value</code>可以让routine共享一些数据，当然获得数据是协程安全的。</p><p>在请求处理的过程中，会调用各层的函数，每层的函数会创建自己的routine，是一个routine树。所以，context也应该反映并实现成一棵树。</p><p>要创建context树，第一步是要有一个根结点。<code>context.Background</code>函数的返回值是一个空的context，经常作为树的根结点，它一般由接收请求的第一个routine创建，不能被取消、没有值、也没有过期时间。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后该怎么创建其它的子孙节点呢？context包为我们提供了以下函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这四个函数的第一个参数都是父context，返回一个Context类型的值，这样就层层创建出不同的节点。子节点是从复制父节点得到的，并且根据接收的函数参数保存子节点的一些状态值，然后就可以将它传递给下层的routine了。</p><p><code>WithCancel</code>函数，返回一个额外的CancelFunc函数类型变量，该函数类型的定义为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> CancelFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用CancelFunc对象将撤销对应的Context对象，这样父结点的所在的环境中，获得了撤销子节点context的权利，当触发某些条件时，可以调用CancelFunc对象来终止子结点树的所有routine。在子节点的routine中，需要用类似下面的代码来判断何时退出routine：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>cxt<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">// do some cleaning and return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据cxt.Done()判断是否结束。当顶层的Request请求处理结束，或者外部取消了这次请求，就可以cancel掉顶层context，从而使整个请求的routine树得以退出。</p><p><code>WithDeadline</code>和<code>WithTimeout</code>比<code>WithCancel</code>多了一个时间参数，它指示context存活的最长时间。如果超过了过期时间，会自动撤销它的子context。所以context的生命期是由父context的routine和<code>deadline</code>共同决定的。</p><p><code>WithValue</code>返回parent的一个副本，该副本保存了传入的key/value，而调用Context接口的Value(key)方法就可以得到val。注意在同一个context中设置key/value，若key相同，值会被覆盖。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h2><h2 id="2-1-上下文数据的存储与查询"><a href="#2-1-上下文数据的存储与查询" class="headerlink" title="2.1 上下文数据的存储与查询"></a>2.1 上下文数据的存储与查询</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil key"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>valueCtx<span class="token punctuation">{</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>key <span class="token operator">==</span> key <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span>val    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>context上下文数据的存储就像一个树，每个结点只存储一个key/value对。<code>WithValue()</code>保存一个key/value对，它将父context嵌入到新的子context，并在节点中保存了key/value数据。<code>Value()</code>查询key对应的value数据，会从当前context中查询，如果查不到，会递归查询父context中的数据。</p><p>值得注意的是，<strong>context中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据。</strong></p><h2 id="2-2-手动cancel和超时cancel"><a href="#2-2-手动cancel和超时cancel" class="headerlink" title="2.2 手动cancel和超时cancel"></a>2.2 手动cancel和超时cancel</h2><p><code>cancelCtx</code>中嵌入了父Context，实现了canceler接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context      <span class="token comment">// 保存parent Context</span>    done <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    mu       sync<span class="token punctuation">.</span>Mutex    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    err      <span class="token builtin">error</span><span class="token punctuation">}</span><span class="token comment">// A canceler is a context type that can be canceled directly. The</span><span class="token comment">// implementations are *cancelCtx and *timerCtx.</span><span class="token keyword">type</span> canceler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cancelCtx</code>结构体中<code>children</code>保存它的所有<code>子canceler</code>， 当外部触发cancel时，会调用<code>children</code>中的所有<code>cancel()</code>来终止所有的<code>cancelCtx</code>。<code>done</code>用来标识是否已被cancel。当外部触发cancel、或者父Context的channel关闭时，此done也会关闭。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timerCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    cancelCtx     <span class="token comment">//cancelCtx.Done()关闭的时机：1）用户调用cancel 2）deadline到了 3）父Context的done关闭了</span>    timer    <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer    deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    c <span class="token operator">:=</span> <span class="token operator">&amp;</span>timerCtx<span class="token punctuation">{</span>        cancelCtx<span class="token punctuation">:</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>        deadline<span class="token punctuation">:</span>  deadline<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    d <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span>    <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span> <span class="token comment">// deadline has already passed</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>timerCtx</code>结构体中<code>deadline</code>保存了超时的时间，当超过这个时间，会触发<code>cancel</code>。</p><p><img src="https://image.fyxemmmm.cn/blog/images/ctx1.jpg" alt="img"></p><p>可以看出，<strong>cancelCtx也是一棵树，当触发cancel时，会cancel本结点和其子树的所有cancelCtx</strong>。</p><h2 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h2><p>由于go大量的官方库、第三方库使用了context，所以调用<code>接收context的函数</code>时要小心，要清楚context在什么时候cancel，什么行为会触发cancel。笔者在程序经常使用gRpc传出来的context，产生了一些非预期的结果，之后花时间总结了gRpc、内部基础库中context的生命期及行为，以避免出现同样的问题。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> context </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
